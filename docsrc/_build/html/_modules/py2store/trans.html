
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>py2store.trans &#8212; py2store 0.0.7 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for py2store.trans</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">reduce</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span><span class="p">,</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Collection</span>
<span class="kn">from</span> <span class="nn">py2store.base</span> <span class="kn">import</span> <span class="n">Store</span><span class="p">,</span> <span class="n">KvReader</span><span class="p">,</span> <span class="n">AttrNames</span>
<span class="kn">from</span> <span class="nn">py2store.util</span> <span class="kn">import</span> <span class="n">lazyprop</span><span class="p">,</span> <span class="n">num_of_args</span><span class="p">,</span> <span class="n">attrs_of</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">py2store.utils.signatures</span> <span class="kn">import</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">KO</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Internal Utils</span>

<span class="k">def</span> <span class="nf">_all_but_first_arg_are_keyword_only</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; def foo(a, *, b, c=2): ...</span>
<span class="sd">    &gt;&gt;&gt; _all_but_first_arg_are_keyword_only(foo)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; def bar(a, b, *, c=2): ...</span>
<span class="sd">    &gt;&gt;&gt; _all_but_first_arg_are_keyword_only(bar)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kinds</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">kinds</span><span class="p">)</span>  <span class="c1"># consume first item, and all remaining should be KEYWORD_ONLY</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span> <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">)</span>


<span class="c1"># FIXME: doctest line numbers not shown correctly when wrapped by store_decorator!</span>
<div class="viewcode-block" id="store_decorator"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.store_decorator">[docs]</a><span class="k">def</span> <span class="nf">store_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to make store decorators.</span>

<span class="sd">    You provide a class-decorating function ``func`` that takes a store type (and possibly additional params)</span>
<span class="sd">    and returns another decorated store type.</span>

<span class="sd">    ``store_decorator`` takes that ``func`` and provides an enhanced class decorator specialized for stores.</span>
<span class="sd">    Namely it will:</span>
<span class="sd">    - Add ``__module__``, ``__qualname__``, ``__name__`` and ``__doc__`` arguments to it</span>
<span class="sd">    - Copy the aforementioned arguments to the decorated class, or copy the attributes of the original if not specified.</span>
<span class="sd">    - Output a decorator that can be used in four different ways: a class/instance decorator/factory.</span>

<span class="sd">    By class/instance decorator/factory we mean that if ``A`` is a class, ``a`` an instance of it,</span>
<span class="sd">    and ``deco`` a decorator obtained with ``store_decorator(func)``,</span>
<span class="sd">    we can use ``deco`` to</span>
<span class="sd">    - class decorator: decorate a class</span>
<span class="sd">    - class decorator factory: make a function that decorates classes</span>
<span class="sd">    - instance decorator: decorate an instance of a store</span>
<span class="sd">    - instancce decorator factor: make a function that decorates instances of stores</span>

<span class="sd">    For example, say we have the following ``deco`` that we made with ``store_decorator``:</span>

<span class="sd">    &gt;&gt;&gt; @store_decorator</span>
<span class="sd">    ... def deco(cls=None, *, x=1):</span>
<span class="sd">    ...     # do stuff to cls, or a copy of it...</span>
<span class="sd">    ...     cls.x = x  # like this for example</span>
<span class="sd">    ...     return cls</span>

<span class="sd">    And a class that has nothing to it:</span>

<span class="sd">    &gt;&gt;&gt; class A: ...</span>

<span class="sd">    Nammely, it doesn&#39;t have an ``x``</span>

<span class="sd">    &gt;&gt;&gt; hasattr(A, &#39;x&#39;)</span>
<span class="sd">    False</span>

<span class="sd">    We make a ``decorated_A`` with ``deco`` (class decorator example)</span>

<span class="sd">    &gt;&gt;&gt; deco(A, x=42)</span>
<span class="sd">    &lt;class &#39;trans.A&#39;&gt;</span>

<span class="sd">    and we see that we now have an ``x`` and it&#39;s 42</span>

<span class="sd">    &gt;&gt;&gt; hasattr(A, &#39;x&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; A.x</span>
<span class="sd">    42</span>

<span class="sd">    But we could have also made a factory to decorate ``A`` and anything else that comes our way.</span>

<span class="sd">    &gt;&gt;&gt; paint_it_42 = deco(x=42)</span>
<span class="sd">    &gt;&gt;&gt; decorated_A = paint_it_42(A)</span>
<span class="sd">    &gt;&gt;&gt; assert decorated_A.x == 42</span>
<span class="sd">    &gt;&gt;&gt; class B:</span>
<span class="sd">    ...     x = &#39;destined to disappear&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert paint_it_42(B).x == 42</span>

<span class="sd">    To be fair though, you&#39;ll probably see the factory usage appear in the following form,</span>
<span class="sd">    where the class is decorated at definition time.</span>

<span class="sd">    &gt;&gt;&gt; @deco(x=42)</span>
<span class="sd">    ... class B:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; assert B.x == 42</span>

<span class="sd">    If your exists already, and you want to keep it as is (with the same name), you can</span>
<span class="sd">    use subclassing to transform a copy of ``A`` instead, as below.</span>
<span class="sd">    Also note in the following example, that ``deco`` was used without parentheses,</span>
<span class="sd">    which is equivalent to ``@deco()``,</span>
<span class="sd">    and yes, store_decorator makes that possible to, as long as your params have defaults</span>

<span class="sd">    &gt;&gt;&gt; @deco</span>
<span class="sd">    ... class decorated_A(A):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; assert decorated_A.x == 1</span>
<span class="sd">    &gt;&gt;&gt; assert A.x == 42</span>

<span class="sd">    Finally, you can also decorate instances:</span>

<span class="sd">    &gt;&gt;&gt; class A: ...</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; hasattr(a, &#39;x&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; b = deco(a); assert b.x == 1; # b has an x and it&#39;s 1</span>
<span class="sd">    &gt;&gt;&gt; b = deco()(a); assert b.x == 1; # b has an x and it&#39;s 1</span>
<span class="sd">    &gt;&gt;&gt; b = deco(a, x=42); assert b.x == 42  # b has an x and it&#39;s 42</span>
<span class="sd">    &gt;&gt;&gt; b = deco(x=42)(a); assert b.x == 42; # b has an x and it&#39;s 42</span>

<span class="sd">    WARNING: Note though that the type of ``b`` is not the same type as ``a``</span>
<span class="sd">    &gt;&gt;&gt; isinstance(b, a.__class__)</span>
<span class="sd">    False</span>

<span class="sd">    No, ``b`` is an instance of a ``py2store.base.Store``, which is a class containing an</span>
<span class="sd">    instance of a store (here, ``a``).</span>

<span class="sd">    &gt;&gt;&gt; type(b)</span>
<span class="sd">    &lt;class &#39;py2store.base.Store&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; b.store == a</span>
<span class="sd">    True</span>

<span class="sd">    Now, here&#39;s some more example, slightly closer to real usage</span>

<span class="sd">    &gt;&gt;&gt; from py2store.trans import store_decorator</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def rm_deletion(store=None, *, msg=&#39;Deletions not allowed.&#39;):</span>
<span class="sd">    ...     name = getattr(store, &#39;__name__&#39;, &#39;Something&#39;) + &#39;_w_sommething&#39;</span>
<span class="sd">    ...     assert isinstance(store, type), f&quot;Should be a type, was {type(store)}: {store}&quot;</span>
<span class="sd">    ...     wrapped_store = type(name, (store,), {})</span>
<span class="sd">    ...     wrapped_store.__delitem__ = lambda self, k: msg</span>
<span class="sd">    ...     return wrapped_store</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; remove_deletion = store_decorator(rm_deletion)</span>

<span class="sd">    See how the signature of the wrapper has some extra inputs that were injected (__module__, __qualname__, etc.):</span>

<span class="sd">    &gt;&gt;&gt; print(str(signature(remove_deletion)))</span>
<span class="sd">    (store=None, *, msg=&#39;Deletions not allowed.&#39;, __module__=None, __name__=None, __qualname__=None, __doc__=None, __annotations__=None, __defaults__=None, __kwdefaults__=None)</span>

<span class="sd">    Using it as a class decorator factory (the most common way):</span>

<span class="sd">    As a class decorator &quot;factory&quot;, without parameters (and without ()):</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; @remove_deletion</span>
<span class="sd">    ... class WD(UserDict):</span>
<span class="sd">    ...     &quot;Here&#39;s the doc&quot;</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; wd = WD(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == UserDict(x=5, y=7)  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;Deletions not allowed.&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__doc__ == &quot;Here&#39;s the doc&quot;</span>

<span class="sd">    As a class decorator &quot;factory&quot;, with parameters:</span>

<span class="sd">    &gt;&gt;&gt; @remove_deletion(msg=&#39;No way. I do not trust you!!&#39;)</span>
<span class="sd">    ... class WD(UserDict): ...</span>
<span class="sd">    &gt;&gt;&gt; wd = WD(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == UserDict(x=5, y=7)  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;No way. I do not trust you!!&#39;</span>

<span class="sd">    The __doc__ is empty:</span>

<span class="sd">    &gt;&gt;&gt; assert WD.__doc__ == None</span>

<span class="sd">    But we could specify a doc if we wanted to:</span>

<span class="sd">    &gt;&gt;&gt; @remove_deletion(__doc__=&quot;Hi, I&#39;m a doc.&quot;)</span>
<span class="sd">    ... class WD(UserDict):</span>
<span class="sd">    ...     &quot;This is the original doc, that will be overritten&quot;</span>
<span class="sd">    &gt;&gt;&gt; assert WD.__doc__ == &quot;Hi, I&#39;m a doc.&quot;</span>


<span class="sd">    The class decorations above are equivalent to the two following:</span>

<span class="sd">    &gt;&gt;&gt; WD = remove_deletion(UserDict)</span>
<span class="sd">    &gt;&gt;&gt; wd = WD(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == UserDict(x=5, y=7)  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;Deletions not allowed.&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; WD = remove_deletion(UserDict, msg=&#39;No way. I do not trust you!!&#39;)</span>
<span class="sd">    &gt;&gt;&gt; wd = WD(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == UserDict(x=5, y=7)  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;No way. I do not trust you!!&#39;</span>

<span class="sd">    But we can also decorate instances. In this case they will be wrapped in a Store class</span>
<span class="sd">    before being passed on to the actual decorator.</span>

<span class="sd">    &gt;&gt;&gt; d = UserDict(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; wd = remove_deletion(d)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == d  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;Deletions not allowed.&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; d = UserDict(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; wd = remove_deletion(d, msg=&#39;No way. I do not trust you!!&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == d  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;No way. I do not trust you!!&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># wrapper_assignments = (&#39;__module__&#39;, &#39;__qualname__&#39;, &#39;__name__&#39;, &#39;__doc__&#39;, &#39;__annotations__&#39;)</span>
    <span class="n">wrapper_assignments</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="s1">&#39;__defaults__&#39;</span><span class="p">,</span> <span class="s1">&#39;__kwdefaults__&#39;</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_func_wrapping_store_in_cls_if_not_type</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">specials</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">wrapper_assignments</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">specials</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">store_instance</span> <span class="o">=</span> <span class="n">store</span>
            <span class="n">WrapperStore</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">Store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">WrapperStore</span><span class="p">(</span><span class="n">store_instance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">_all_but_first_arg_are_keyword_only</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="p">(</span>
                <span class="s2">&quot;To use decorating_store_cls, all but the first of your function&#39;s arguments need to be all keyword only. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;The signature was </span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}{</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">specials</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">r</span>

    <span class="n">_func_wrapping_store_in_cls_if_not_type</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="c1"># @wraps(func)</span>
    <span class="n">wrapper_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">KO</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">wrapper_assignments</span><span class="p">],</span>
        <span class="n">ch_to_all_pk</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>

    <span class="nd">@wrapper_sig</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># then we want a factory</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_func_wrapping_store_in_cls_if_not_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wrapped_store_cls</span> <span class="o">=</span> <span class="n">_func_wrapping_store_in_cls_if_not_type</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">wrapped_store_cls</span>

    <span class="c1"># Make sure the wrapper (yes, also the wrapper) has the same key dunders as the func</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">wrapper_assignments</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>


<span class="k">def</span> <span class="nf">ensure_set</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_class_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dflt_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__class__&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dflt_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dflt_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2"> has no name I could extract&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">name</span>


<span class="k">def</span> <span class="nf">store_wrap</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">class</span> <span class="nc">StoreWrap</span><span class="p">(</span><span class="n">Store</span><span class="p">):</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">persister</span> <span class="o">=</span> <span class="n">obj</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">persister</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">StoreWrap</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Store</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


<span class="c1"># # Older version, kept around for awhile, for review:</span>
<span class="c1"># def store_wrap(obj, name=None):</span>
<span class="c1">#     if isinstance(obj, type):</span>
<span class="c1">#         name = name or f&quot;{get_class_name(obj, &#39;StoreWrap&#39;)}Store&quot;</span>
<span class="c1">#</span>
<span class="c1">#         class StoreWrap(Store):</span>
<span class="c1">#             @wraps(obj.__init__)</span>
<span class="c1">#             def __init__(self, *args, **kwargs):</span>
<span class="c1">#                 persister = obj(*args, **kwargs)</span>
<span class="c1">#                 super().__init__(persister)</span>
<span class="c1">#</span>
<span class="c1">#         StoreWrap.__qualname__ = name</span>
<span class="c1">#         # if hasattr(obj, &#39;_cls_trans&#39;):</span>
<span class="c1">#         #     StoreWrap._cls_trans = obj._cls_trans</span>
<span class="c1">#         return StoreWrap</span>
<span class="c1">#     else:</span>
<span class="c1">#         return Store(obj)</span>


<span class="k">def</span> <span class="nf">_is_bound</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s2">&quot;__self__&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_first_param_is_an_instance_param</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">self_names</span>


<span class="c1"># TODO: Add validation of func: That all but perhaps 1 argument (not counting self) has a default</span>
<span class="k">def</span> <span class="nf">_has_unbound_self</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        func:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &gt;&gt;&gt; def f1(x): ...</span>
<span class="sd">    &gt;&gt;&gt; assert _has_unbound_self(f1) == 0</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def f2(self, x): ...</span>
<span class="sd">    &gt;&gt;&gt; assert _has_unbound_self(f2) == 1</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; f3 = lambda self, x: True</span>
<span class="sd">    &gt;&gt;&gt; assert _has_unbound_self(f3) == 1</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def bar(self, x): ...</span>
<span class="sd">    ...     def foo(dacc, x): ...</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; _has_unbound_self(a.bar)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; _has_unbound_self(a.foo)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; _has_unbound_self(A.bar)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; _has_unbound_self(A.foo)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># no argument, so we can&#39;t be wrapping anything!!!</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The function has no parameters, so I can&#39;t guess which one you want to wrap&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">_is_bound</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_first_param_is_an_instance_param</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">transparent_key_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">k</span>


<div class="viewcode-block" id="mk_kv_reader_from_kv_collection"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.mk_kv_reader_from_kv_collection">[docs]</a><span class="k">def</span> <span class="nf">mk_kv_reader_from_kv_collection</span><span class="p">(</span>
        <span class="n">kv_collection</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">getitem</span><span class="o">=</span><span class="n">transparent_key_method</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a KvReader class from a Collection class.</span>

<span class="sd">    Args:</span>
<span class="sd">        kv_collection: The Collection class</span>
<span class="sd">        name: The name to give the KvReader class (by default, it will be kv_collection.__qualname__ + &#39;Reader&#39;)</span>
<span class="sd">        getitem: The method that will be assigned to __getitem__. Should have the (self, k) signature.</span>
<span class="sd">            By default, getitem will be transparent_key_method, returning the key as is.</span>
<span class="sd">            This default is useful when you want to delegate the actual getting to a _obj_of_data wrapper.</span>

<span class="sd">    Returns: A KvReader class that subclasses the input kv_collection</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">kv_collection</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s2">&quot;Reader&quot;</span>
    <span class="n">reader_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
        <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">kv_collection</span><span class="p">,</span> <span class="n">KvReader</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;__getitem__&quot;</span><span class="p">:</span> <span class="n">getitem</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">reader_cls</span></div>


<span class="k">def</span> <span class="nf">raise_disabled_error</span><span class="p">(</span><span class="n">functionality</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">disabled_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">functionality</span><span class="si">}</span><span class="s2"> is disabled&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">disabled_function</span>


<span class="k">def</span> <span class="nf">disable_delitem</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__delitem__&quot;</span><span class="p">):</span>
        <span class="n">o</span><span class="o">.</span><span class="fm">__delitem__</span> <span class="o">=</span> <span class="n">raise_disabled_error</span><span class="p">(</span><span class="s2">&quot;deletion&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">o</span>


<span class="k">def</span> <span class="nf">disable_setitem</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__setitem__&quot;</span><span class="p">):</span>
        <span class="n">o</span><span class="o">.</span><span class="fm">__setitem__</span> <span class="o">=</span> <span class="n">raise_disabled_error</span><span class="p">(</span><span class="s2">&quot;writing&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">o</span>


<span class="k">def</span> <span class="nf">mk_read_only</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">disable_delitem</span><span class="p">(</span><span class="n">disable_setitem</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">is_iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>


<div class="viewcode-block" id="add_ipython_key_completions"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.add_ipython_key_completions">[docs]</a><span class="k">def</span> <span class="nf">add_ipython_key_completions</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add tab completion that shows you the keys of the store.</span>
<span class="sd">    Note: ipython already adds local path listing automatically,</span>
<span class="sd">     so you&#39;ll still get those along with your valid store keys.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_ipython_key_completions_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">store</span><span class="o">.</span><span class="n">_ipython_key_completions_</span> <span class="o">=</span> <span class="n">_ipython_key_completions_</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span>
            <span class="n">store</span><span class="p">,</span>
            <span class="s2">&quot;_ipython_key_completions_&quot;</span><span class="p">,</span>
            <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">_ipython_key_completions_</span><span class="p">,</span> <span class="n">store</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">store</span></div>


<span class="kn">from</span> <span class="nn">py2store.util</span> <span class="kn">import</span> <span class="n">copy_attrs</span>
<span class="kn">from</span> <span class="nn">py2store.errors</span> <span class="kn">import</span> <span class="n">OverWritesNotAllowedError</span>


<span class="k">def</span> <span class="nf">disallow_overwrites</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">error_msg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">disable_deletes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="s2">&quot;store needs to be a type&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s2">&quot;__setitem__&quot;</span><span class="p">):</span>

        <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">OverWritesNotAllowedError</span><span class="p">(</span>
                    <span class="s2">&quot;key </span><span class="si">{}</span><span class="s2"> already exists and cannot be overwritten. &quot;</span>
                    <span class="s2">&quot;If you really want to write to that key, delete it before writing&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">k</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>


<div class="viewcode-block" id="OverWritesNotAllowedMixin"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.OverWritesNotAllowedMixin">[docs]</a><span class="k">class</span> <span class="nc">OverWritesNotAllowedMixin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Mixin for only allowing a write to a key if they key doesn&#39;t already exist.</span>
<span class="sd">    Note: Should be before the persister in the MRO.</span>

<span class="sd">    &gt;&gt;&gt; class TestPersister(OverWritesNotAllowedMixin, dict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; p = TestPersister()</span>
<span class="sd">    &gt;&gt;&gt; p[&#39;foo&#39;] = &#39;bar&#39;</span>
<span class="sd">    &gt;&gt;&gt; #p[&#39;foo&#39;] = &#39;bar2&#39;  # will raise error</span>
<span class="sd">    &gt;&gt;&gt; p[&#39;foo&#39;] = &#39;this value should not be stored&#39; # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    py2store.errors.OverWritesNotAllowedError: key foo already exists and cannot be overwritten.</span>
<span class="sd">        If you really want to write to that key, delete it before writing</span>
<span class="sd">    &gt;&gt;&gt; p[&#39;foo&#39;]  # foo is still bar</span>
<span class="sd">    &#39;bar&#39;</span>
<span class="sd">    &gt;&gt;&gt; del p[&#39;foo&#39;]</span>
<span class="sd">    &gt;&gt;&gt; p[&#39;foo&#39;] = &#39;this value WILL be stored&#39;</span>
<span class="sd">    &gt;&gt;&gt; p[&#39;foo&#39;]</span>
<span class="sd">    &#39;this value WILL be stored&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># TODO: Consider moving to trans and making instances wrappable too</span>
        <span class="k">class</span> <span class="nc">NoOverWritesClass</span><span class="p">(</span><span class="n">OverWritesNotAllowedMixin</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="o">...</span>

        <span class="n">copy_attrs</span><span class="p">(</span>
            <span class="n">NoOverWritesClass</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">NoOverWritesClass</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">OverWritesNotAllowedError</span><span class="p">(</span>
                <span class="s2">&quot;key </span><span class="si">{}</span><span class="s2"> already exists and cannot be overwritten. &quot;</span>
                <span class="s2">&quot;If you really want to write to that key, delete it before writing&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">k</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Caching keys</span>

<span class="c1"># TODO: If a read-one-by-one (vs the current read all implementation) is necessary one day,</span>
<span class="c1">#   see https://github.com/zahlman/indexify/blob/master/src/indexify.py for ideas</span>
<span class="c1">#   but probably buffered (read by chunks) version of the later is better.</span>
<div class="viewcode-block" id="cached_keys"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.cached_keys">[docs]</a><span class="nd">@store_decorator</span>
<span class="k">def</span> <span class="nf">cached_keys</span><span class="p">(</span>
        <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">keys_cache</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">callable</span><span class="p">,</span> <span class="n">Collection</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">,</span>
        <span class="n">iter_to_container</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># deprecated: use keys_cache instead</span>
        <span class="n">cache_update_method</span><span class="o">=</span><span class="s2">&quot;update&quot;</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO: might be able to be deprecated since included in store_decorator</span>
        <span class="vm">__module__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO: might be able to be deprecated since included in store_decorator</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">callable</span><span class="p">,</span> <span class="n">KvReader</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Make a class that wraps input class&#39;s __iter__ becomes cached.</span>

<span class="sd">    Quite often we have a lot of keys, that we get from a remote data source, and don&#39;t want to have to ask for</span>
<span class="sd">    them again and again, having them be fetched, sent over the network, etc.</span>
<span class="sd">    So we need caching.</span>

<span class="sd">    But this caching is not the typical read caching, since it&#39;s __iter__ we want to cache, and that&#39;s a generator.</span>
<span class="sd">    So we&#39;ll implement a store class decorator specialized for this.</span>

<span class="sd">    The following decorator, when applied to a class (that has an __iter__), will perform the __iter__ code, consuming</span>
<span class="sd">    all items of the generator and storing them in _keys_cache, and then will yield from there every subsequent call.</span>

<span class="sd">    It is assumed, if you&#39;re using the cached_keys transformation, that you&#39;re dealing with static data</span>
<span class="sd">    (or data that can be considered static for the life of the store -- for example, when conducting analytics).</span>
<span class="sd">    If you ever need to refresh the cache during the life of the store, you can to delete _keys_cache like this:</span>
<span class="sd">    ```</span>
<span class="sd">    del your_store._keys_cache</span>
<span class="sd">    ```</span>
<span class="sd">    Once you do that, the next time you try to ask something about the contents of the store, it will actually do</span>
<span class="sd">    a live query again, as for the first time.</span>

<span class="sd">    Note: The default keys_cache is list though in many cases, you&#39;d probably should use set, or an explicitly</span>
<span class="sd">    computer set instead. The reason list is used as the default is because (1) we didn&#39;t want to assume that</span>
<span class="sd">    order did not matter (maybe it does to you) and (2) we didn&#39;t want to assume that your keys were hashable.</span>
<span class="sd">    That said, if you&#39;re keys are hashable, and order does not matter, use set. That&#39;ll give you two things:</span>
<span class="sd">    (a) your `key in store` checks will be faster (O(1) instead of O(n)) and (b) you&#39;ll enforce unicity of keys.</span>

<span class="sd">    Know also that if you precompute the keys you want to cache with a container that has an update</span>
<span class="sd">    method (by default `update`) your cache updates will be faster and if the container you use has</span>
<span class="sd">    a `remove` method, you&#39;ll be able to delete as well.</span>

<span class="sd">    Args:</span>
<span class="sd">        store: The store instance or class to wrap (must have an __iter__), or None if you want a decorator.</span>
<span class="sd">        keys_cache: An explicit collection of keys</span>
<span class="sd">        iter_to_container: The function that will be applied to existing __iter__() and assigned to cache.</span>
<span class="sd">            The default is list. Another useful one is the sorted function.</span>
<span class="sd">        cache_update_method: Name of the keys_cache update method to use, if it is an attribute of keys_cache.</span>
<span class="sd">            Note that this cache_update_method will be used only</span>
<span class="sd">                if keys_cache is an explicit iterable and has that attribute</span>
<span class="sd">                if keys_cache is a callable and has that attribute.</span>
<span class="sd">            The default None</span>
<span class="sd">        name: The name of the new class</span>

<span class="sd">    Returns:</span>
<span class="sd">        If store is:</span>
<span class="sd">            None: Will return a decorator that can be applied to a store</span>
<span class="sd">            a store class: Will return a wrapped class that caches it&#39;s keys</span>
<span class="sd">            a store instance: Will return a wrapped instance that caches it&#39;s keys</span>

<span class="sd">        The instances of such key-cached classes have some extra attributes:</span>
<span class="sd">            _explicit_keys: The actual cache. An iterable container</span>
<span class="sd">            update_keys_cache: Is called if a user uses the instance to mutate the store (i.e. write or delete).</span>

<span class="sd">    You have two ways of caching keys:</span>
<span class="sd">    - By providing the explicit list of keys you want cache (and use)</span>
<span class="sd">    - By providing a callable that will iterate through your store and collect an explicit list of keys</span>

<span class="sd">    Let&#39;s take a simple dict as our original store.</span>
<span class="sd">    &gt;&gt;&gt; source = dict(c=3, b=2, a=1)</span>

<span class="sd">    Specify an iterable, and it will be used as the cached keys</span>
<span class="sd">    &gt;&gt;&gt; cached = cached_keys(source, keys_cache=&#39;bc&#39;)</span>
<span class="sd">    &gt;&gt;&gt; list(cached.items())  # notice that the order you get things is also ruled by the cache</span>
<span class="sd">    [(&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>

<span class="sd">    Specify a callable, and it will apply it to the existing keys to make your cache</span>
<span class="sd">    &gt;&gt;&gt; list(cached_keys(source, keys_cache=sorted))</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>

<span class="sd">    You can use the callable keys_cache specification to filter as well!</span>
<span class="sd">    Oh, and let&#39;s demo the fact that if you don&#39;t specify the store, it will make a store decorator for you:</span>
<span class="sd">    &gt;&gt;&gt; cache_my_keys = cached_keys(keys_cache=lambda keys: list(filter(lambda k: k &gt;= &#39;b&#39;, keys)))</span>
<span class="sd">    &gt;&gt;&gt; d = cache_my_keys(source)  # used as to transform an instance</span>
<span class="sd">    &gt;&gt;&gt; list(d)</span>
<span class="sd">    [&#39;c&#39;, &#39;b&#39;]</span>

<span class="sd">    Let&#39;s use that same `cache_my_keys` to decorate a class instead:</span>
<span class="sd">    &gt;&gt;&gt; cached_dict = cache_my_keys(dict)</span>
<span class="sd">    &gt;&gt;&gt; d = cached_dict(c=3, b=2, a=1)</span>
<span class="sd">    &gt;&gt;&gt; list(d)</span>
<span class="sd">    [&#39;c&#39;, &#39;b&#39;]</span>

<span class="sd">    Note that there&#39;s still an underlying store (dict) that has the data:</span>
<span class="sd">    &gt;&gt;&gt; repr(d)  # repr isn&#39;t wrapped, so you can still see your underlying dict</span>
<span class="sd">    &quot;{&#39;c&#39;: 3, &#39;b&#39;: 2, &#39;a&#39;: 1}&quot;</span>

<span class="sd">    And yes, you can still add elements,</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;z&#39;] = 26</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())</span>
<span class="sd">    [(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26)]</span>

<span class="sd">    do bulk updates,</span>
<span class="sd">    &gt;&gt;&gt; d.update({&#39;more&#39;: &#39;of this&#39;}, more_of=&#39;that&#39;)</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())</span>
<span class="sd">    [(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more&#39;, &#39;of this&#39;), (&#39;more_of&#39;, &#39;that&#39;)]</span>

<span class="sd">    and delete...</span>
<span class="sd">    &gt;&gt;&gt; del d[&#39;more&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())</span>
<span class="sd">    [(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more_of&#39;, &#39;that&#39;)]</span>

<span class="sd">    But careful! Know what you&#39;re doing if you try to get creative. Have a look at this:</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;a&#39;] = 100  # add an &#39;a&#39; item</span>
<span class="sd">    &gt;&gt;&gt; d.update(and_more=&#39;of that&#39;)  # update to add yet another item</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())</span>
<span class="sd">    [(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more_of&#39;, &#39;that&#39;)]</span>

<span class="sd">    Indeed: No &#39;a&#39; or &#39;and_more&#39;.</span>

<span class="sd">    Now... they were indeed added. Or to be more precise, the value of the already existing a was changed,</span>
<span class="sd">    and a new (&#39;and_more&#39;, &#39;of that&#39;) item was indeed added in the underlying store:</span>
<span class="sd">    &gt;&gt;&gt; repr(d)</span>
<span class="sd">    &quot;{&#39;c&#39;: 3, &#39;b&#39;: 2, &#39;a&#39;: 100, &#39;z&#39;: 26, &#39;more_of&#39;: &#39;that&#39;, &#39;and_more&#39;: &#39;of that&#39;}&quot;</span>

<span class="sd">    But you&#39;re not seeing it.</span>

<span class="sd">    Why?</span>

<span class="sd">    Because you chose to use a callable keys_cache that doesn&#39;t have an &#39;update&#39; method.</span>
<span class="sd">    When your _keys_cache attribute (the iterable cache) is not updatable itself, the</span>
<span class="sd">    way updates work is that we iterate through the underlying store (where the updates actually took place),</span>
<span class="sd">    and apply the keys_cache (callable) to that iterable.</span>

<span class="sd">    So what happened here was that you have your new &#39;a&#39; and &#39;and_more&#39; items, but your cached version of the</span>
<span class="sd">    store doesn&#39;t see it because it&#39;s filtered out. On the other hand, check out what happens if you have</span>
<span class="sd">    an updateable cache.</span>

<span class="sd">    Using `set` instead of `list`, after the `filter`.</span>

<span class="sd">    &gt;&gt;&gt; cache_my_keys = cached_keys(keys_cache=set)</span>
<span class="sd">    &gt;&gt;&gt; d = cache_my_keys(source)  # used as to transform an instance</span>
<span class="sd">    &gt;&gt;&gt; sorted(d)  # using sorted because a set&#39;s order is not always the same</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;a&#39;] = 100</span>
<span class="sd">    &gt;&gt;&gt; d.update(and_more=&#39;of that&#39;)  # update to add yet another item</span>
<span class="sd">    &gt;&gt;&gt; sorted(d.items())</span>
<span class="sd">    [(&#39;a&#39;, 100), (&#39;and_more&#39;, &#39;of that&#39;), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>

<span class="sd">    This example was to illustrate a more subtle aspect of cached_keys. You would probably deal with</span>
<span class="sd">    the filter concern in a different way in this case. But the rope is there -- it&#39;s your choice on how</span>
<span class="sd">    to use it.</span>

<span class="sd">    And here&#39;s some more examples if that wasn&#39;t enough!</span>

<span class="sd">    &gt;&gt;&gt; # Lets cache the keys of a dict.</span>
<span class="sd">    &gt;&gt;&gt; cached_dict = cached_keys(dict)</span>
<span class="sd">    &gt;&gt;&gt; d = cached_dict(a=1, b=2, c=3)</span>
<span class="sd">    &gt;&gt;&gt; # And you get a store that behaves as expected (but more speed and RAM)</span>
<span class="sd">    &gt;&gt;&gt; list(d)</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())  # whether you iterate with .keys(), .values(), or .items()</span>
<span class="sd">    [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>

<span class="sd">    This is where the keys are stored:</span>
<span class="sd">    &gt;&gt;&gt; d._keys_cache</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>

<span class="sd">    &gt;&gt;&gt; # Let&#39;s demo the iter_to_container argument. The default is &quot;list&quot;, which will just consume the iter in order</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=list)</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;b&#39;: 3, &#39;a&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be in the order they were defined</span>
<span class="sd">    [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=sorted)</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;b&#39;: 3, &#39;a&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be sorted</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=lambda x: sorted(x, key=len))</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;bbb&#39;: 3, &#39;aa&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be sorted according to their length</span>
<span class="sd">    [&#39;c&#39;, &#39;aa&#39;, &#39;bbb&#39;]</span>

<span class="sd">    If you change the keys (adding new ones with __setitem__ or update, or removing with pop or popitem)</span>
<span class="sd">    then the cache is recomputed (the first time you use an operation that iterates over keys)</span>
<span class="sd">    &gt;&gt;&gt; d.update(d=4)  # let&#39;s add an element (try d[&#39;d&#39;] = 4 as well)</span>
<span class="sd">    &gt;&gt;&gt; list(d)</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;e&#39;] = 5</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())  # whether you iterate with .keys(), .values(), or .items()</span>
<span class="sd">    [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4), (&#39;e&#39;, 5)]</span>

<span class="sd">    &gt;&gt;&gt; @cached_keys</span>
<span class="sd">    ... class A:</span>
<span class="sd">    ...     def __iter__(self):</span>
<span class="sd">    ...         yield from [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; # Note, could have also used this form: AA = cached_keys(A)</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; list(a)</span>
<span class="sd">    [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; a._keys_cache = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]  # changing the cache, to prove that subsequent listing will read from there</span>
<span class="sd">    &gt;&gt;&gt; list(a)  # proof:</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt;</span>

<span class="sd">    &gt;&gt;&gt; # Let&#39;s demo the iter_to_container argument. The default is &quot;list&quot;, which will just consume the iter in order</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=list)</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;b&#39;: 3, &#39;a&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be in the order they were defined</span>
<span class="sd">    [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=sorted)</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;b&#39;: 3, &#39;a&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be sorted</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=lambda x: sorted(x, key=len))</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;bbb&#39;: 3, &#39;aa&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be sorted according to their length</span>
<span class="sd">    [&#39;c&#39;, &#39;aa&#39;, &#39;bbb&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">iter_to_container</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">iter_to_container</span><span class="p">)</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The argument name &#39;iter_to_container&#39; is being deprecated in favor of the more general &#39;keys_cache&#39;&quot;</span>
        <span class="p">)</span>
        <span class="c1"># assert keys_cache == iter_to_container</span>

    <span class="c1"># if store is None:</span>
    <span class="c1">#     return partial(</span>
    <span class="c1">#         cached_keys,</span>
    <span class="c1">#         keys_cache=keys_cache,</span>
    <span class="c1">#         cache_update_method=cache_update_method,</span>
    <span class="c1">#         name=name,</span>
    <span class="c1">#         __module__=__module__,</span>
    <span class="c1">#     )</span>
    <span class="c1"># elif not isinstance(store, type):  # then consider it to be an instance</span>
    <span class="c1">#     store_instance = store</span>
    <span class="c1">#     WrapperStore = cached_keys(</span>
    <span class="c1">#         Store,</span>
    <span class="c1">#         keys_cache=keys_cache,</span>
    <span class="c1">#         cache_update_method=cache_update_method,</span>
    <span class="c1">#         name=name,</span>
    <span class="c1">#         __module__=__module__,</span>
    <span class="c1">#     )</span>
    <span class="c1">#     return WrapperStore(store_instance)</span>
    <span class="c1"># else:</span>
    <span class="c1"># store_cls = store</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;store_cls must be a type, was a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">store</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">store</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># name = name or &#39;IterCached&#39; + get_class_name(store_cls)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">get_class_name</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
    <span class="vm">__module__</span> <span class="o">=</span> <span class="vm">__module__</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">cached_cls</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
        <span class="n">_keys_cache</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">cached_cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>

    <span class="c1"># cached_cls = type(name, (store_cls,), {&quot;_keys_cache&quot;: None})</span>

    <span class="c1"># The following class is not the class that will be returned, but the class from which we&#39;ll take the methods</span>
    <span class="c1">#   that will be copied in the class that will be returned.</span>
    <span class="nd">@_define_keys_values_and_items_according_to_iter</span>
    <span class="k">class</span> <span class="nc">CachedIterMethods</span><span class="p">:</span>
        <span class="n">_explicit_keys</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">_updatable_cache</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">_iter_to_container</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">keys_cache</span><span class="p">,</span> <span class="n">cache_update_method</span><span class="p">):</span>
            <span class="n">_updatable_cache</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">is_iterable</span><span class="p">(</span>
                <span class="n">keys_cache</span>
        <span class="p">):</span>  <span class="c1"># if keys_cache is iterable, it is the cache instance itself.</span>
            <span class="n">_keys_cache</span> <span class="o">=</span> <span class="n">keys_cache</span>
            <span class="n">_explicit_keys</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">keys_cache</span><span class="p">):</span>
            <span class="c1"># if keys_cache is not iterable, but callable, we&#39;ll use it to make the keys_cache from __iter__</span>
            <span class="n">_iter_to_container</span> <span class="o">=</span> <span class="n">keys_cache</span>

            <span class="nd">@lazyprop</span>
            <span class="k">def</span> <span class="nf">_keys_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># print(iter_to_container)</span>
                <span class="k">return</span> <span class="n">keys_cache</span><span class="p">(</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>
                <span class="p">)</span>  <span class="c1"># TODO: Should it be iter(super(...)?</span>

        <span class="c1"># if not callable(_explicit_keys):</span>

        <span class="c1"># If keys_cache_update is None (the default), the method &#39;update&#39; will be searched for as above,</span>
        <span class="c1">#   and if not found, will fall back to None.</span>
        <span class="c1"># if isinstance(keys_cache_update, str):</span>
        <span class="c1">#     if (_explicit_keys and hasattr(_explicit_keys, &#39;__class__&#39;)</span>
        <span class="c1">#             and hasattr(_explicit_keys.__class__, keys_cache_update)):</span>
        <span class="c1">#         keys_cache_update = getattr(_explicit_keys.__class__, keys_cache_update)</span>

        <span class="c1"># if (_explicit_keys and hasattr(_explicit_keys, &#39;__class__&#39;)</span>
        <span class="c1">#         and hasattr(_explicit_keys.__class__, &#39;update&#39;)):</span>
        <span class="c1">#     keys_cache_update = _explicit_keys.__class__.update</span>
        <span class="c1">#</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">_iter_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># for back-compatibility</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The new name for `_iter_cache` is `_keys_cache`. Start using that!&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>

        <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># if getattr(self, &#39;_keys_cache&#39;, None) is None:</span>
            <span class="c1">#     self._keys_cache = iter_to_container(super(cached_cls, self).__iter__())</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>

        <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>

        <span class="c1"># The write and update stuff ###################################################################</span>

        <span class="k">if</span> <span class="n">_updatable_cache</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">update_keys_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;updates the keys by calling the</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">update_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">,</span> <span class="n">cache_update_method</span>
                <span class="p">)</span>
                <span class="n">update_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>

            <span class="n">update_keys_cache</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Updates the _keys_cache by calling its </span><span class="si">{}</span><span class="s2"> method&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">update_keys_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Updates the _keys_cache by deleting the attribute</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>
                    <span class="c1"># print(&#39;deleted _keys_cache&#39;)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="c1"># self.store[k] = v</span>
            <span class="k">if</span> <span class="p">(</span>
                    <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span>
            <span class="p">):</span>  <span class="c1"># just to avoid deleting the cache if we already had the key</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_keys_cache</span><span class="p">((</span><span class="n">k</span><span class="p">,))</span>
                <span class="c1"># Note: different construction performances: (k,)-&gt;10ns, [k]-&gt;38ns, {k}-&gt;50ns</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
            <span class="c1"># print(other, kwds)</span>
            <span class="c1"># super(cached_cls, self).update(other, **kwds)</span>
            <span class="n">super_setitem</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="c1"># print(k, other[k])</span>
                <span class="n">super_setitem</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">other</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="c1"># self.store[k] = other[k]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_keys_cache</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># print(k, v)</span>
                <span class="n">super_setitem</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="c1"># self.store[k] = v</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_keys_cache</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>

        <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># And this is where we add all the needed methods (for example, no __setitem__ won&#39;t be added if the original</span>
    <span class="c1">#   class didn&#39;t have one in the first place.</span>
    <span class="n">special_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;update_keys_cache&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_keys_cache&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_explicit_keys&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_updatable_cache&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">special_attrs</span> <span class="o">|</span> <span class="p">(</span>
            <span class="n">AttrNames</span><span class="o">.</span><span class="n">KvPersister</span>
            <span class="o">&amp;</span> <span class="n">attrs_of</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="n">attrs_of</span><span class="p">(</span><span class="n">CachedIterMethods</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">CachedIterMethods</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

    <span class="k">if</span> <span class="vm">__module__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cached_cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="vm">__module__</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">):</span>
        <span class="n">cached_cls</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">return</span> <span class="n">cached_cls</span></div>


<span class="n">cache_iter</span> <span class="o">=</span> <span class="n">cached_keys</span>  <span class="c1"># TODO: Alias, partial it and make it more like the original, for back compatibility.</span>


<div class="viewcode-block" id="catch_and_cache_error_keys"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.catch_and_cache_error_keys">[docs]</a><span class="nd">@store_decorator</span>
<span class="k">def</span> <span class="nf">catch_and_cache_error_keys</span><span class="p">(</span>
        <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">errors_caught</span><span class="o">=</span><span class="ne">Exception</span><span class="p">,</span>
        <span class="n">error_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_cached_keys_after_completed_iter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Store that will cache keys as they&#39;re accessed, separating those that raised errors and those that didn&#39;t.</span>
<span class="sd">    Getting a key will still through an error, but the access attempts will be collected in an ._error_keys attribute.</span>
<span class="sd">    Successfful attemps will be stored in _keys_cache.</span>
<span class="sd">    Retrieval iteration (items() or values()) will on the other hand, skip the error (while still caching it).</span>
<span class="sd">    If the iteration completes (and use_cached_keys_after_completed_iter), the use_cached_keys flag is turned on,</span>
<span class="sd">    which will result in the store now getting it&#39;s keys from the _keys_cache.</span>

<span class="sd">    &gt;&gt;&gt; @catch_and_cache_error_keys(</span>
<span class="sd">    ...     error_callback=lambda store, key, err: print(f&quot;Error with {key} key: {err}&quot;))</span>
<span class="sd">    ... class Blacklist(dict):</span>
<span class="sd">    ...     _black_list = {&#39;black&#39;, &#39;list&#39;}</span>
<span class="sd">    ...</span>
<span class="sd">    ...     def __getitem__(self, k):</span>
<span class="sd">    ...         if k not in self._black_list:</span>
<span class="sd">    ...             return super().__getitem__(k)</span>
<span class="sd">    ...         else:</span>
<span class="sd">    ...             raise KeyError(f&quot;Nope, that&#39;s from the black list!&quot;)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s = Blacklist(black=7,  friday=20, frenzy=13)</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;black&#39;, &#39;friday&#39;, &#39;frenzy&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    Error with black key: &quot;Nope, that&#39;s from the black list!&quot;</span>
<span class="sd">    [(&#39;friday&#39;, 20), (&#39;frenzy&#39;, 13)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(s)  # sorting to get consistent output</span>
<span class="sd">    [&#39;frenzy&#39;, &#39;friday&#39;]</span>


<span class="sd">    See that? First we had three keys, then we iterated and got only 2 items (fortunately,</span>
<span class="sd">    we specified an ``error_callback`` so we ccould see that the iteration actually dropped a key).</span>
<span class="sd">    That&#39;s strange. And even stranger is the fact that when we list our keys again, we get only two.</span>

<span class="sd">    You don&#39;t like it? Neither do I. But</span>
<span class="sd">    - It&#39;s not a completely outrageous behavior -- if you&#39;re talking to live data, it</span>
<span class="sd">        often happens that you get more, or less, from one second to another.</span>
<span class="sd">    - This store isn&#39;t meant to be long living, but rather meant to solve the problem of skiping</span>
<span class="sd">        items that are problematic (for example, malformatted files), with a trace of</span>
<span class="sd">        what was skipped and what&#39;s valid (in case we need to iterate again and don&#39;t want to</span>
<span class="sd">        bear the hit of requesting values for keys we already know are problematic.</span>

<span class="sd">    Here&#39;s a little peep of what is happening under the hood.</span>
<span class="sd">    Meet ``_keys_cache`` and ``_error_keys`` sets (yes, unordered -- so know it) that are meant</span>
<span class="sd">    to acccumulate valid and problematic keys respectively.</span>

<span class="sd">    &gt;&gt;&gt; s = Blacklist(black=7,  friday=20, frenzy=13)</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;black&#39;, &#39;friday&#39;, &#39;frenzy&#39;]</span>
<span class="sd">    &gt;&gt;&gt; s._keys_cache, s._error_keys</span>
<span class="sd">    (set(), set())</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;friday&#39;]</span>
<span class="sd">    20</span>
<span class="sd">    &gt;&gt;&gt; s._keys_cache, s._error_keys</span>
<span class="sd">    ({&#39;friday&#39;}, set())</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;black&#39;]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    KeyError: &quot;Nope, that&#39;s from the black list!&quot;</span>
<span class="sd">    &gt;&gt;&gt; s._keys_cache, s._error_keys</span>
<span class="sd">    ({&#39;friday&#39;}, {&#39;black&#39;})</span>

<span class="sd">    But see that we still have the full list:</span>

<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;black&#39;, &#39;friday&#39;, &#39;frenzy&#39;]</span>

<span class="sd">    Meet ``use_cached_keys``: He&#39;s the culprit. It&#39;s a flag that indicates whether we should be</span>
<span class="sd">    using the cached keys or not. Obviously, it&#39;ll start off being ``False``:</span>

<span class="sd">    &gt;&gt;&gt; s.use_cached_keys</span>
<span class="sd">    False</span>

<span class="sd">    Now we could set it to ``True`` manually to change the mode.</span>
<span class="sd">    But know that this switch happens automatically (UNLESS you specify otherwise by saying:</span>
<span class="sd">    ``use_cached_keys_after_completed_iter=False``) when ever you got through a</span>
<span class="sd">    VALUE-PRODUCING iteration (i.e. entirely consuming `items()` or `values()`).</span>

<span class="sd">    &gt;&gt;&gt; sorted(s.values())  # sorting to get consistent output</span>
<span class="sd">    Error with black key: &quot;Nope, that&#39;s from the black list!&quot;</span>
<span class="sd">    [13, 20]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;store_cls must be a type, was a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">store</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">store</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># assert isinstance(store, Mapping), f&quot;store_cls must be a Mapping. Was not. mro is {store.mro()}: {store}&quot;</span>

    <span class="c1"># class cached_cls(store):</span>
    <span class="c1">#     _keys_cache = None</span>
    <span class="c1">#     _error_keys = None</span>

    <span class="c1"># The following class is not the class that will be returned, but the class from which we&#39;ll take the methods</span>
    <span class="c1">#   that will be copied in the class that will be returned.</span>
    <span class="c1"># @_define_keys_values_and_items_according_to_iter</span>
    <span class="k">class</span> <span class="nc">CachedKeyErrorsStore</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">store</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_error_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys_after_completed_iter</span> <span class="o">=</span> <span class="n">use_cached_keys_after_completed_iter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors_caught</span> <span class="o">=</span> <span class="n">errors_caught</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_callback</span> <span class="o">=</span> <span class="n">error_callback</span>

        <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">v</span>
                <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors_caught</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_error_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">raise</span>

        <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># if getattr(self, &#39;_keys_cache&#39;, None) is None:</span>
            <span class="c1">#     self._keys_cache = iter_to_container(super(cached_cls, self).__iter__())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

        <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors_caught</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">error_callback</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys_after_completed_iter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">CachedKeyErrorsStore</span></div>


<span class="k">def</span> <span class="nf">iterate_values_and_accumulate_non_error_keys</span><span class="p">(</span>
        <span class="n">store</span><span class="p">,</span>
        <span class="n">cache_keys_here</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
        <span class="n">errors_caught</span><span class="o">=</span><span class="ne">Exception</span><span class="p">,</span>
        <span class="n">error_callback</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">store</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">store</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">cache_keys_here</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">v</span>
        <span class="k">except</span> <span class="n">errors_caught</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">error_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">error_callback</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Filtering iteration</span>


<span class="k">def</span> <span class="nf">take_everything</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="c1"># TODO: Factor out the method injection pattern (e.g. __getitem__, __setitem__ and __delitem__ are nearly identical)</span>
<div class="viewcode-block" id="filt_iter"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.filt_iter">[docs]</a><span class="nd">@store_decorator</span>
<span class="k">def</span> <span class="nf">filt_iter</span><span class="p">(</span>
        <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
        <span class="n">filt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">]</span> <span class="o">=</span> <span class="n">take_everything</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="vm">__module__</span><span class="o">=</span><span class="kc">None</span>  <span class="c1"># TODO: might be able to be deprecated since included in store_decorator</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a wrapper that will transform a store (class or instance thereof) into a sub-store (i.e. subset of keys).</span>

<span class="sd">    Args:</span>
<span class="sd">        filt: A callable or iterable:</span>
<span class="sd">            callable: Boolean filter function. A func taking a key and and returns True iff the key should be included.</span>
<span class="sd">            iterable: The collection of keys you want to filter &quot;in&quot;</span>
<span class="sd">        name: The name to give the wrapped class</span>

<span class="sd">    Returns: A wrapper (that then needs to be applied to a store instance or class.</span>

<span class="sd">    &gt;&gt;&gt; filtered_dict = filt_iter(filt=lambda k: (len(k) % 2) == 1)(dict)  # keep only odd length keys</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s = filtered_dict({&#39;a&#39;: 1, &#39;bb&#39;: object, &#39;ccc&#39;: &#39;a string&#39;, &#39;dddd&#39;: [1, 2]})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;a&#39;, &#39;ccc&#39;]</span>
<span class="sd">    &gt;&gt;&gt; &#39;a&#39; in s  # True because odd (length) key</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; &#39;bb&#39; in s  # False because odd (length) key</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; assert s.get(&#39;bb&#39;, None) == None</span>
<span class="sd">    &gt;&gt;&gt; len(s)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; list(s.keys())</span>
<span class="sd">    [&#39;a&#39;, &#39;ccc&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.values())</span>
<span class="sd">    [1, &#39;a string&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    [(&#39;a&#39;, 1), (&#39;ccc&#39;, &#39;a string&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; s.get(&#39;a&#39;)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; assert s.get(&#39;bb&#39;) is None</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;x&#39;] = 10</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    [(&#39;a&#39;, 1), (&#39;ccc&#39;, &#39;a string&#39;), (&#39;x&#39;, 10)]</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     s[&#39;xx&#39;] = &#39;not an odd key&#39;</span>
<span class="sd">    ...     raise ValueError(&quot;This should have failed&quot;)</span>
<span class="sd">    ... except KeyError:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># if store is None:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">filt</span><span class="p">):</span>  <span class="c1"># if filt is not a callable...</span>
        <span class="c1"># ... assume it&#39;s the collection of keys you want and make a filter function to filter those &quot;in&quot;.</span>
        <span class="k">assert</span> <span class="nb">next</span><span class="p">(</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;filt should be a callable, or an iterable&quot;</span>
        <span class="n">keys_that_should_be_filtered_in</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys_that_should_be_filtered_in</span>

    <span class="vm">__module__</span> <span class="o">=</span> <span class="vm">__module__</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;Filtered&quot;</span> <span class="o">+</span> <span class="n">get_class_name</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
    <span class="n">wrapped_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">store</span><span class="p">,),</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="n">filt</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__iter__</span> <span class="o">=</span> <span class="fm">__iter__</span>

    <span class="n">_define_keys_values_and_items_according_to_iter</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">():</span>
            <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="fm">__len__</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__contains__</span> <span class="o">=</span> <span class="fm">__contains__</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">):</span>

        <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key not in store: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__getitem__</span> <span class="o">=</span> <span class="fm">__getitem__</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="s2">&quot;get&quot;</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">default</span>

        <span class="n">wrapped_cls</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">get</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="s2">&quot;__setitem__&quot;</span><span class="p">):</span>

        <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key not in store: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__setitem__</span> <span class="o">=</span> <span class="fm">__setitem__</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="s2">&quot;__delitem__&quot;</span><span class="p">):</span>

        <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key not in store: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__delitem__</span> <span class="o">=</span> <span class="fm">__delitem__</span>

    <span class="c1"># if __module__ is not None:</span>
    <span class="c1">#     wrapped_cls.__module__ = __module__</span>
    <span class="c1">#</span>
    <span class="c1"># if hasattr(collection_cls, &#39;__doc__&#39;):</span>
    <span class="c1">#     wrapped_cls.__doc__ = store.__doc__</span>

    <span class="k">return</span> <span class="n">wrapped_cls</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Wrapping keys and values</span>

<span class="n">self_names</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="s2">&quot;self&quot;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_define_keys_values_and_items_according_to_iter</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;keys&quot;</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>  <span class="c1"># TODO: Should it be iter(self)?</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;items&quot;</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">items</span>

    <span class="k">return</span> <span class="bp">cls</span>


<span class="c1"># TODO: would like to keep dict_keys methods (like __sub__, isdisjoint). How do I do so?</span>
<span class="k">class</span> <span class="nc">_DefineKeysValuesAndItemsAccordingToIter</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>  <span class="c1"># TODO: Should it be iter(self)?</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="kv_wrap_persister_cls"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.kv_wrap_persister_cls">[docs]</a><span class="k">def</span> <span class="nf">kv_wrap_persister_cls</span><span class="p">(</span><span class="n">persister_cls</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a class that wraps a persister into a py2store.base.Store,</span>

<span class="sd">    Args:</span>
<span class="sd">        persister_cls: The persister class to wrap</span>

<span class="sd">    Returns: A Store wrapping the persister (see py2store.base)</span>

<span class="sd">    &gt;&gt;&gt; A = kv_wrap_persister_cls(dict)</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;one&#39;] = 1</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;two&#39;] = 2</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;three&#39;] = 3</span>
<span class="sd">    &gt;&gt;&gt; list(a.items())</span>
<span class="sd">    [(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)]</span>
<span class="sd">    &gt;&gt;&gt; A  # looks like a dict, but is not:</span>
<span class="sd">    &lt;class &#39;abc.dictPWrapped&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; assert hasattr(a, &#39;_obj_of_data&#39;)  # for example, it has this magic method</span>
<span class="sd">    &gt;&gt;&gt; # If you overwrite the _obj_of_data method, you&#39;ll transform outcomming values with it.</span>
<span class="sd">    &gt;&gt;&gt; # For example, say the data you stored were minutes, but you want to get then in secs...</span>
<span class="sd">    &gt;&gt;&gt; a._obj_of_data = lambda data: data * 60</span>
<span class="sd">    &gt;&gt;&gt; list(a.items())</span>
<span class="sd">    [(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # And if you want to have class that has this weird &quot;store minutes, retrieve seconds&quot;, you can do this:</span>
<span class="sd">    &gt;&gt;&gt; class B(kv_wrap_persister_cls(dict)):</span>
<span class="sd">    ...     def _obj_of_data(self, data):</span>
<span class="sd">    ...         return data * 60</span>
<span class="sd">    &gt;&gt;&gt; b = B()</span>
<span class="sd">    &gt;&gt;&gt; b.update({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3})  # you can write several key-value pairs at once this way!</span>
<span class="sd">    &gt;&gt;&gt; list(b.items())</span>
<span class="sd">    [(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="sd">    &gt;&gt;&gt; # Warning! Advanced under-the-hood chat coming up.... Note this:</span>
<span class="sd">    &gt;&gt;&gt; print(b)</span>
<span class="sd">    {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}</span>
<span class="sd">    &gt;&gt;&gt; # What?!? Well, remember, printing an object calls the objects __str__, which usually calls __repr__</span>
<span class="sd">    &gt;&gt;&gt; # The wrapper doesn&#39;t wrap those methods, since they don&#39;t have consistent behaviors.</span>
<span class="sd">    &gt;&gt;&gt; # Here you&#39;re getting the __repr__ of the underlying dict store, without the key and value transforms.</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Say you wanted to transform the incoming minute-unit data, converting to secs BEFORE they were stored...</span>
<span class="sd">    &gt;&gt;&gt; class C(kv_wrap_persister_cls(dict)):</span>
<span class="sd">    ...     def _data_of_obj(self, obj):</span>
<span class="sd">    ...         return obj * 60</span>
<span class="sd">    &gt;&gt;&gt; c = C()</span>
<span class="sd">    &gt;&gt;&gt; c.update(one=1, two=2, three=3)  # yet another way you can write multiple key-vals at once</span>
<span class="sd">    &gt;&gt;&gt; list(c.items())</span>
<span class="sd">    [(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="sd">    &gt;&gt;&gt; print(c)  # but notice that unlike when we printed b, here the stored data is actually transformed!</span>
<span class="sd">    {&#39;one&#39;: 60, &#39;two&#39;: 120, &#39;three&#39;: 180}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Now, just to demonstrate key transformation, let&#39;s say that we need internal (stored) keys to be upper case,</span>
<span class="sd">    &gt;&gt;&gt; # but external (the keys you see when listed) ones to be lower case, for some reason...</span>
<span class="sd">    &gt;&gt;&gt; class D(kv_wrap_persister_cls(dict)):</span>
<span class="sd">    ...     _data_of_obj = staticmethod(lambda obj: obj * 60)  # to demonstrated another way of doing this</span>
<span class="sd">    ...     _key_of_id = lambda self, _id: _id.lower()  # note if you don&#39;t specify staticmethod, 1st arg must be self</span>
<span class="sd">    ...     def _id_of_key(self, k):  # a function definition like you&#39;re used to</span>
<span class="sd">    ...         return k.upper()</span>
<span class="sd">    &gt;&gt;&gt; d = D()</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;oNe&#39;] = 1</span>
<span class="sd">    &gt;&gt;&gt; d.update(TwO=2, tHrEE=3)</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())  # you see clean lower cased keys at the interface of the store</span>
<span class="sd">    [(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="sd">    &gt;&gt;&gt; # but internally, the keys are all upper case</span>
<span class="sd">    &gt;&gt;&gt; print(d)  # equivalent to print(d.store), so keys and values not wrapped (values were transformed before stored)</span>
<span class="sd">    {&#39;ONE&#39;: 60, &#39;TWO&#39;: 120, &#39;THREE&#39;: 180}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # On the other hand, careful, if you gave the data directly to D, you wouldn&#39;t get that.</span>
<span class="sd">    &gt;&gt;&gt; d = D({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3})</span>
<span class="sd">    &gt;&gt;&gt; print(d)</span>
<span class="sd">    {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}</span>
<span class="sd">    &gt;&gt;&gt; # Thus is because when you construct a D with the dict, it initializes the dicts data with it directly</span>
<span class="sd">    &gt;&gt;&gt; # before the key/val transformers are in place to do their jobs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="p">(</span><span class="n">persister_cls</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s2">&quot;PWrapped&quot;</span><span class="p">)</span>

    <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">Store</span><span class="p">,),</span> <span class="p">{})</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">persister_cls</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">persister_cls</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">persister_cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">persister_cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="fm">__init__</span>

    <span class="k">return</span> <span class="bp">cls</span></div>


<span class="k">def</span> <span class="nf">_wrap_outcoming</span><span class="p">(</span>
        <span class="n">store_cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">trans_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Output-transforming wrapping of the wrapped_method of store_cls.</span>
<span class="sd">    The transformation is given by trans_func, which could be a one (trans_func(x)</span>
<span class="sd">    or two (trans_func(self, x)) argument function.</span>

<span class="sd">    Args:</span>
<span class="sd">        store_cls: The class that will be transformed</span>
<span class="sd">        wrapped_method: The method (name) that will be transformed.</span>
<span class="sd">        trans_func: The transformation function.</span>
<span class="sd">        wrap_arg_idx: The index of the</span>

<span class="sd">    Returns: Nothing. It transforms the class in-place</span>

<span class="sd">    &gt;&gt;&gt; from py2store.trans import store_wrap</span>
<span class="sd">    &gt;&gt;&gt; S = store_wrap(dict)</span>
<span class="sd">    &gt;&gt;&gt; _wrap_outcoming(S, &#39;_key_of_id&#39;, lambda x: f&#39;wrapped_{x}&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s = S({&#39;a&#39;: 1, &#39;b&#39;: 2})</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;wrapped_a&#39;, &#39;wrapped_b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; _wrap_outcoming(S, &#39;_key_of_id&#39;, lambda self, x: f&#39;wrapped_{x}&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s = S({&#39;a&#39;: 1, &#39;b&#39;: 2}); assert list(s) == [&#39;wrapped_a&#39;, &#39;wrapped_b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, prefix=&#39;wrapped_&#39;):</span>
<span class="sd">    ...         self.prefix = prefix</span>
<span class="sd">    ...     def _key_of_id(self, x):</span>
<span class="sd">    ...         return self.prefix + x</span>
<span class="sd">    &gt;&gt;&gt; _wrap_outcoming(S, &#39;_key_of_id&#39;, A(prefix=&#39;wrapped_&#39;)._key_of_id)</span>
<span class="sd">    &gt;&gt;&gt; s = S({&#39;a&#39;: 1, &#39;b&#39;: 2}); assert list(s) == [&#39;wrapped_a&#39;, &#39;wrapped_b&#39;]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; S = store_wrap(dict)</span>
<span class="sd">    &gt;&gt;&gt; _wrap_outcoming(S, &#39;_obj_of_data&#39;, lambda x: x * 7)</span>
<span class="sd">    &gt;&gt;&gt; s = S({&#39;a&#39;: 1, &#39;b&#39;: 2})</span>
<span class="sd">    &gt;&gt;&gt; list(s.values())</span>
<span class="sd">    [7, 14]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">trans_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wrapped_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_has_unbound_self</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
            <span class="c1"># print(f&quot;00000: {store_cls}: {wrapped_method}, {trans_func}, {wrapped_func}, {wrap_arg_idx}&quot;)</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrapped_func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">new_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="c1"># # Long form (for explanation)</span>
                <span class="c1"># super_method = getattr(super(store_cls, self), wrapped_method)</span>
                <span class="c1"># output_of_super_method = super_method(x)</span>
                <span class="c1"># transformed_output_of_super_method = trans_func(output_of_super_method)</span>
                <span class="c1"># return transformed_output_of_super_method</span>
                <span class="k">return</span> <span class="n">trans_func</span><span class="p">(</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">wrapped_method</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(f&quot;11111: {store_cls}: {wrapped_method}, {trans_func}, {wrapped_func}, {wrap_arg_idx}&quot;)</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrapped_func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">new_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="c1"># # Long form (for explanation)</span>
                <span class="c1"># super_method = getattr(super(store_cls, self), wrapped_method)</span>
                <span class="c1"># output_of_super_method = super_method(x)</span>
                <span class="c1"># transformed_output_of_super_method = trans_func(self, output_of_super_method)</span>
                <span class="c1"># return transformed_output_of_super_method</span>
                <span class="k">return</span> <span class="n">trans_func</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">wrapped_method</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">,</span> <span class="n">new_method</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_wrap_ingoing</span><span class="p">(</span>
        <span class="n">store_cls</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">trans_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="n">trans_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wrapped_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_has_unbound_self</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrapped_func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">new_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">wrapped_method</span><span class="p">)(</span>
                    <span class="n">trans_func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrapped_func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">new_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">wrapped_method</span><span class="p">)(</span>
                    <span class="n">trans_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">,</span> <span class="n">new_method</span><span class="p">)</span>


<div class="viewcode-block" id="wrap_kvs"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.wrap_kvs">[docs]</a><span class="k">def</span> <span class="nf">wrap_kvs</span><span class="p">(</span>
        <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">key_of_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">id_of_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">obj_of_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_of_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">preset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">postget</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="vm">__module__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">outcoming_key_methods</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">outcoming_value_methods</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">ingoing_key_methods</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">ingoing_value_methods</span><span class="o">=</span><span class="p">(),</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Make a Store that is wrapped with the given key/val transformers.</span>

<span class="sd">    Naming convention:</span>
<span class="sd">        Morphemes:</span>
<span class="sd">            key: outer key</span>
<span class="sd">            _id: inner key</span>
<span class="sd">            obj: outer value</span>
<span class="sd">            data: inner value</span>
<span class="sd">        Grammar:</span>
<span class="sd">            Y_of_X: means that you get a Y output when giving an X input. Also known as X_to_Y.</span>


<span class="sd">    Args:</span>
<span class="sd">        store: Store class or instance</span>
<span class="sd">        name: Name to give the wrapper class</span>
<span class="sd">        key_of_id: The outcoming key transformation function.</span>
<span class="sd">            Forms are `k = key_of_id(_id)` or `k = key_of_id(self, _id)`</span>
<span class="sd">        id_of_key: The ingoing key transformation function.</span>
<span class="sd">            Forms are `_id = id_of_key(k)` or `_id = id_of_key(self, k)`</span>
<span class="sd">        obj_of_data: The outcoming val transformation function.</span>
<span class="sd">            Forms are `obj = obj_of_data(data)` or `obj = obj_of_data(self, data)`</span>
<span class="sd">        data_of_obj: The ingoing val transformation function.</span>
<span class="sd">            Forms are `data = data_of_obj(obj)` or `data = data_of_obj(self, obj)`</span>
<span class="sd">        preset: A function that is called before doing a `__setitem__`.</span>
<span class="sd">            The function is called with both `k` and `v` as inputs, and should output a transformed value.</span>
<span class="sd">            The intent use is to do ingoing value transformations conditioned on the key.</span>
<span class="sd">            For example, you may want to serialize an object depending on if you&#39;re writing to a</span>
<span class="sd">             &#39;.csv&#39;, or &#39;.json&#39;, or &#39;.pickle&#39; file.</span>
<span class="sd">            Forms are `preset(k, obj)` or `preset(self, k, obj)`</span>
<span class="sd">        postget: A function that is called after the value `v` for a key `k` is be `__getitem__`.</span>
<span class="sd">            The function is called with both `k` and `v` as inputs, and should output a transformed value.</span>
<span class="sd">            The intent use is to do outcoming value transformations conditioned on the key.</span>
<span class="sd">            We already have `obj_of_data` for outcoming value trans, but cannot condition it&#39;s behavior on k.</span>
<span class="sd">            For example, you may want to deserialize the bytes of a &#39;.csv&#39;, or &#39;.json&#39;, or &#39;.pickle&#39; in different ways.</span>
<span class="sd">            Forms are `obj = postget(k, data)` or `obj = postget(self, k, data)`</span>

<span class="sd">    Returns:</span>

<span class="sd">    &gt;&gt;&gt; def key_of_id(_id):</span>
<span class="sd">    ...     return _id.upper()</span>
<span class="sd">    &gt;&gt;&gt; def id_of_key(k):</span>
<span class="sd">    ...     return k.lower()</span>
<span class="sd">    &gt;&gt;&gt; def obj_of_data(data):</span>
<span class="sd">    ...     return data - 100</span>
<span class="sd">    &gt;&gt;&gt; def data_of_obj(obj):</span>
<span class="sd">    ...     return obj + 100</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = wrap_kvs(dict, &#39;A&#39;,</span>
<span class="sd">    ...             key_of_id=key_of_id, id_of_key=id_of_key, obj_of_data=obj_of_data, data_of_obj=data_of_obj)</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;KEY&#39;] = 1</span>
<span class="sd">    &gt;&gt;&gt; a  # repr is just the base class (dict) repr, so shows &quot;inside&quot; the store (lower case keys and +100)</span>
<span class="sd">    {&#39;key&#39;: 101}</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;key&#39;] = 2</span>
<span class="sd">    &gt;&gt;&gt; print(a)  # repr is just the base class (dict) repr, so shows &quot;inside&quot; the store (lower case keys and +100)</span>
<span class="sd">    {&#39;key&#39;: 102}</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;kEy&#39;] = 3</span>
<span class="sd">    &gt;&gt;&gt; a  # repr is just the base class (dict) repr, so shows &quot;inside&quot; the store (lower case keys and +100)</span>
<span class="sd">    {&#39;key&#39;: 103}</span>
<span class="sd">    &gt;&gt;&gt; list(a)  # but from the point of view of the interface the keys are all upper case</span>
<span class="sd">    [&#39;KEY&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(a.items())  # and the values are those we put there.</span>
<span class="sd">    [(&#39;KEY&#39;, 3)]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # And now this: Showing how to condition the value transform (like obj_of_data), but conditioned on key.</span>
<span class="sd">    &gt;&gt;&gt; B = wrap_kvs(dict, &#39;B&#39;, postget=lambda k, v: f&#39;upper {v}&#39; if k[0].isupper() else f&#39;lower {v}&#39;)</span>
<span class="sd">    &gt;&gt;&gt; b = B()</span>
<span class="sd">    &gt;&gt;&gt; b[&#39;BIG&#39;] = &#39;letters&#39;</span>
<span class="sd">    &gt;&gt;&gt; b[&#39;small&#39;] = &#39;text&#39;</span>
<span class="sd">    &gt;&gt;&gt; list(b.items())</span>
<span class="sd">    [(&#39;BIG&#39;, &#39;upper letters&#39;), (&#39;small&#39;, &#39;lower text&#39;)]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Let&#39;s try preset and postget. We&#39;ll wrap a dict and write the same list of lists object to</span>
<span class="sd">    &gt;&gt;&gt; # keys ending with .csv, .json, and .pkl, specifying the obvious extension-dependent</span>
<span class="sd">    &gt;&gt;&gt; # serialization/deserialization we want to associate with it.</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # First, some very simple csv transformation functions</span>
<span class="sd">    &gt;&gt;&gt; to_csv = lambda LoL: &#39;\\n&#39;.join(map(&#39;,&#39;.join, map(lambda L: (x for x in L), LoL)))</span>
<span class="sd">    &gt;&gt;&gt; from_csv = lambda csv: list(map(lambda x: x.split(&#39;,&#39;), csv.split(&#39;\\n&#39;)))</span>
<span class="sd">    &gt;&gt;&gt; LoL = [[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],[&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; assert from_csv(to_csv(LoL)) == LoL</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; import json, pickle</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def preset(k, v):</span>
<span class="sd">    ...     if k.endswith(&#39;.csv&#39;):</span>
<span class="sd">    ...         return to_csv(v)</span>
<span class="sd">    ...     elif k.endswith(&#39;.json&#39;):</span>
<span class="sd">    ...         return json.dumps(v)</span>
<span class="sd">    ...     elif k.endswith(&#39;.pkl&#39;):</span>
<span class="sd">    ...         return pickle.dumps(v)</span>
<span class="sd">    ...     else:</span>
<span class="sd">    ...         return v  # as is</span>
<span class="sd">    ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def postget(k, v):</span>
<span class="sd">    ...     if k.endswith(&#39;.csv&#39;):</span>
<span class="sd">    ...         return from_csv(v)</span>
<span class="sd">    ...     elif k.endswith(&#39;.json&#39;):</span>
<span class="sd">    ...         return json.loads(v)</span>
<span class="sd">    ...     elif k.endswith(&#39;.pkl&#39;):</span>
<span class="sd">    ...         return pickle.loads(v)</span>
<span class="sd">    ...     else:</span>
<span class="sd">    ...         return v  # as is</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; mydict = wrap_kvs(dict, preset=preset, postget=postget)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; obj = [[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],[&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; d = mydict()</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;foo.csv&#39;] = obj  # store the object as csv</span>
<span class="sd">    &gt;&gt;&gt; d  # &quot;printing&quot; a dict by-passes the transformations, so we see the data in the &quot;raw&quot; format it is stored in.</span>
<span class="sd">    {&#39;foo.csv&#39;: &#39;a,b,c\\nd,e,f&#39;}</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;foo.csv&#39;]  # but if we actually ask for the data, it deserializes to our original object</span>
<span class="sd">    [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;bar.json&#39;] = obj  # store the object as json</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;foo.csv&#39;: &#39;a,b,c\\nd,e,f&#39;, &#39;bar.json&#39;: &#39;[[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]]&#39;}</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;bar.json&#39;]</span>
<span class="sd">    [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;bar.json&#39;] = {&#39;a&#39;: 1, &#39;b&#39;: [1, 2], &#39;c&#39;: &#39;normal json&#39;}  # let&#39;s write a normal json instead.</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;foo.csv&#39;: &#39;a,b,c\\nd,e,f&#39;, &#39;bar.json&#39;: &#39;{&quot;a&quot;: 1, &quot;b&quot;: [1, 2], &quot;c&quot;: &quot;normal json&quot;}&#39;}</span>
<span class="sd">    &gt;&gt;&gt; del d[&#39;foo.csv&#39;]</span>
<span class="sd">    &gt;&gt;&gt; del d[&#39;bar.json&#39;]</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;foo.pkl&#39;] = obj  # &#39;save&#39; obj as pickle</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;foo.pkl&#39;]</span>
<span class="sd">    [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]]</span>

<span class="sd">    # TODO: Add tests for outcoming_key_methods etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_but_first_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="n">key_of_id</span><span class="o">=</span><span class="n">key_of_id</span><span class="p">,</span>
        <span class="n">id_of_key</span><span class="o">=</span><span class="n">id_of_key</span><span class="p">,</span>
        <span class="n">obj_of_data</span><span class="o">=</span><span class="n">obj_of_data</span><span class="p">,</span>
        <span class="n">data_of_obj</span><span class="o">=</span><span class="n">data_of_obj</span><span class="p">,</span>
        <span class="n">preset</span><span class="o">=</span><span class="n">preset</span><span class="p">,</span>
        <span class="n">postget</span><span class="o">=</span><span class="n">postget</span><span class="p">,</span>
        <span class="vm">__module__</span><span class="o">=</span><span class="vm">__module__</span><span class="p">,</span>
        <span class="n">outcoming_key_methods</span><span class="o">=</span><span class="n">outcoming_key_methods</span><span class="p">,</span>
        <span class="n">outcoming_value_methods</span><span class="o">=</span><span class="n">outcoming_value_methods</span><span class="p">,</span>
        <span class="n">ingoing_key_methods</span><span class="o">=</span><span class="n">ingoing_key_methods</span><span class="p">,</span>
        <span class="n">ingoing_value_methods</span><span class="o">=</span><span class="n">ingoing_value_methods</span><span class="p">,</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">wrap_kvs</span><span class="p">,</span> <span class="o">**</span><span class="n">all_but_first_kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>  <span class="c1"># then consider it to be an instance</span>
        <span class="n">store_instance</span> <span class="o">=</span> <span class="n">store</span>
        <span class="n">WrapperStore</span> <span class="o">=</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">Store</span><span class="p">,</span> <span class="o">**</span><span class="n">all_but_first_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">WrapperStore</span><span class="p">(</span><span class="n">store_instance</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># it&#39;s a class we&#39;re wrapping</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">store</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s2">&quot;Wrapped&quot;</span>

        <span class="c1"># TODO: This is not the best way to handle this. Investigate another way. ######################</span>
        <span class="n">global_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">globals</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">global_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;That name is already in use&quot;</span><span class="p">)</span>
        <span class="c1"># TODO: ########################################################################################</span>

        <span class="n">store_cls</span> <span class="o">=</span> <span class="n">kv_wrap_persister_cls</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># experiment</span>
        <span class="n">store_cls</span><span class="o">.</span><span class="n">_cls_trans</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">cls_trans</span><span class="p">(</span><span class="n">store_cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;_key_of_id&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">ensure_set</span><span class="p">(</span><span class="n">outcoming_key_methods</span><span class="p">):</span>
                <span class="n">_wrap_outcoming</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">key_of_id</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;_obj_of_data&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">ensure_set</span><span class="p">(</span>
                    <span class="n">outcoming_value_methods</span>
            <span class="p">):</span>
                <span class="n">_wrap_outcoming</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">obj_of_data</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;_id_of_key&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">ensure_set</span><span class="p">(</span><span class="n">ingoing_key_methods</span><span class="p">):</span>
                <span class="n">_wrap_ingoing</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">id_of_key</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;_data_of_obj&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">ensure_set</span><span class="p">(</span>
                    <span class="n">ingoing_value_methods</span>
            <span class="p">):</span>
                <span class="n">_wrap_ingoing</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">data_of_obj</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">postget</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num_of_args</span><span class="p">(</span><span class="n">postget</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;A postget function needs to have (key, value) or (self, key, value) arguments&quot;</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">_has_unbound_self</span><span class="p">(</span><span class="n">postget</span><span class="p">):</span>

                    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">postget</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">postget</span><span class="p">(</span>
                            <span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="p">)</span>

                <span class="n">store_cls</span><span class="o">.</span><span class="fm">__getitem__</span> <span class="o">=</span> <span class="fm">__getitem__</span>

            <span class="k">if</span> <span class="n">preset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num_of_args</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;A preset function needs to have (key, value) or (self, key, value) arguments&quot;</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">_has_unbound_self</span><span class="p">(</span><span class="n">preset</span><span class="p">):</span>

                    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">preset</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span>
                            <span class="n">k</span><span class="p">,</span> <span class="n">preset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                        <span class="p">)</span>

                <span class="n">store_cls</span><span class="o">.</span><span class="fm">__setitem__</span> <span class="o">=</span> <span class="fm">__setitem__</span>

            <span class="k">if</span> <span class="vm">__module__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">store_cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="vm">__module__</span>

            <span class="c1"># add an attribute containing the cls_trans.</span>
            <span class="c1"># This is is both for debugging and introspection use,</span>
            <span class="c1"># as well as if we need to pass on the transformation in a recursive situation</span>
            <span class="n">store_cls</span><span class="o">.</span><span class="n">_cls_trans</span> <span class="o">=</span> <span class="n">cls_trans</span>

            <span class="k">return</span> <span class="n">store_cls</span>

        <span class="k">return</span> <span class="n">cls_trans</span><span class="p">(</span><span class="n">store_cls</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_kv_wrap_outcoming_keys</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform &#39;out-coming&#39; keys, that is, the keys you see when you ask for them,</span>
<span class="sd">    say, through __iter__(), keys(), or first element of the items() pairs.</span>

<span class="sd">    Use this when you wouldn&#39;t use the keys in their original format,</span>
<span class="sd">    or when you want to extract information from it.</span>

<span class="sd">    Warning: If you haven&#39;t also wrapped incoming keys with a corresponding inverse transformation,</span>
<span class="sd">    you won&#39;t be able to use the outcoming keys to fetch data.</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; S = kv_wrap.outcoming_keys(lambda x: x[5:])(UserDict)</span>
<span class="sd">    &gt;&gt;&gt; s = S({&#39;root/foo&#39;: 10, &#39;root/bar&#39;: &#39;xo&#39;})</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;foo&#39;, &#39;bar&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.keys())</span>
<span class="sd">    [&#39;foo&#39;, &#39;bar&#39;]</span>

<span class="sd">    # TODO: Asymmetric key trans breaks getting items (therefore items()). Resolve (remove items() for asym keys?)</span>
<span class="sd">    # &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    # [(&#39;foo&#39;, 10), (&#39;bar&#39;, &#39;xo&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">name</span>
                <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span>
                <span class="o">+</span> <span class="s2">&quot;_kr&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key_of_id</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_kv_wrap_ingoing_keys</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform &#39;in-going&#39; keys, that is, the keys you see when you ask for them,</span>
<span class="sd">    say, through __iter__(), keys(), or first element of the items() pairs.</span>

<span class="sd">    Use this when your context holds objects themselves holding key information, but you don&#39;t want to</span>
<span class="sd">    (because you shouldn&#39;t) &#39;manually&#39; extract that information and construct the key manually every time you need</span>
<span class="sd">    to write something or fetch some existing data.</span>

<span class="sd">    Warning: If you haven&#39;t also wrapped outcoming keys with a corresponding inverse transformation,</span>
<span class="sd">    you won&#39;t be able to use the incoming keys to fetch data.</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; S = kv_wrap.ingoing_keys(lambda x: &#39;root/&#39; + x)(UserDict)</span>
<span class="sd">    &gt;&gt;&gt; s = S()</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;foo&#39;] = 10</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;bar&#39;] = &#39;xo&#39;</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;root/foo&#39;, &#39;root/bar&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.keys())</span>
<span class="sd">    [&#39;root/foo&#39;, &#39;root/bar&#39;]</span>

<span class="sd">    # TODO: Asymmetric key trans breaks getting items (therefore items()). Resolve (remove items() for asym keys?)</span>
<span class="sd">    # &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    # [(&#39;root/foo&#39;, 10), (&#39;root/bar&#39;, &#39;xo&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">name</span>
                <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span>
                <span class="o">+</span> <span class="s2">&quot;_kw&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">id_of_key</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_kv_wrap_outcoming_vals</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform &#39;out-coming&#39; values, that is, the values you see when you ask for them,</span>
<span class="sd">    say, through the values() or the second element of items() pairs.</span>
<span class="sd">    This can be seen as adding a de-serialization layer: trans_func being the de-serialization function.</span>

<span class="sd">    For example, say your store gives you values of the bytes type, but you want to use text, or gives you text,</span>
<span class="sd">    but you want it to be interpreted as a JSON formatted text and get a dict instead. Both of these are</span>
<span class="sd">    de-serialization layers, or out-coming value transformations.</span>

<span class="sd">    Warning: If it matters, make sure you also wrapped with a corresponding inverse serialization.</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; S = kv_wrap.outcoming_vals(lambda x: x * 2)(UserDict)</span>
<span class="sd">    &gt;&gt;&gt; s = S(foo=10, bar=&#39;xo&#39;)</span>
<span class="sd">    &gt;&gt;&gt; list(s.values())</span>
<span class="sd">    [20, &#39;xoxo&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    [(&#39;foo&#39;, 20), (&#39;bar&#39;, &#39;xoxo&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">name</span>
                <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span>
                <span class="o">+</span> <span class="s2">&quot;_vr&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj_of_data</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_kv_wrap_ingoing_vals</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform &#39;in-going&#39; values, that is, the values at the level of the store&#39;s interface are transformed</span>
<span class="sd">    to a different value before writing to the wrapped store.</span>
<span class="sd">    This can be seen as adding a serialization layer: trans_func being the serialization function.</span>

<span class="sd">    For example, say you have a list of audio samples, and you want to save these in a WAV format.</span>

<span class="sd">    Warning: If it matters, make sure you also wrapped with a corresponding inverse de-serialization.</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; S = kv_wrap.ingoing_vals(lambda x: x * 2)(UserDict)</span>
<span class="sd">    &gt;&gt;&gt; s = S()</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;foo&#39;] = 10</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;bar&#39;] = &#39;xo&#39;</span>
<span class="sd">    &gt;&gt;&gt; list(s.values())</span>
<span class="sd">    [20, &#39;xoxo&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    [(&#39;foo&#39;, 20), (&#39;bar&#39;, &#39;xoxo&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">name</span>
                <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span>
                <span class="o">+</span> <span class="s2">&quot;_vw&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data_of_obj</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_ingoing_vals_wrt_to_keys</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">name</span>
                <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span>
                <span class="o">+</span> <span class="s2">&quot;_vwk&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_outcoming_vals_wrt_to_keys</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">name</span>
                <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span>
                <span class="o">+</span> <span class="s2">&quot;_vrk&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">postget</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<div class="viewcode-block" id="mk_trans_obj"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.mk_trans_obj">[docs]</a><span class="k">def</span> <span class="nf">mk_trans_obj</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convenience method to quickly make a trans_obj (just an object holding some trans functions&quot;&quot;&quot;</span>
    <span class="c1"># TODO: Could make this more flexible (assuming here only staticmethods) and validate inputs...</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span>
        <span class="s2">&quot;TransObj&quot;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="p">)()</span></div>


<div class="viewcode-block" id="kv_wrap"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.kv_wrap">[docs]</a><span class="k">def</span> <span class="nf">kv_wrap</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    kv_wrap: A function that makes a wrapper (a decorator) that will get the wrappers from methods of the input object.</span>

<span class="sd">    kv_wrap also has attributes:</span>
<span class="sd">        outcoming_keys, ingoing_keys, outcoming_vals, ingoing_vals, and val_reads_wrt_to_keys</span>
<span class="sd">    which will only add a single specific wrapper (specified as a function), when that&#39;s what you need.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">key_of_id</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_key_of_id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">id_of_key</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_id_of_key&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">obj_of_data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_obj_of_data&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">data_of_obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_data_of_obj&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">preset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_preset&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">postget</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_postget&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">name</span>
                <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span>
                <span class="o">+</span> <span class="s2">&quot;_kr&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span>
            <span class="n">o</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">key_of_id</span><span class="o">=</span><span class="n">key_of_id</span><span class="p">,</span>
            <span class="n">id_of_key</span><span class="o">=</span><span class="n">id_of_key</span><span class="p">,</span>
            <span class="n">obj_of_data</span><span class="o">=</span><span class="n">obj_of_data</span><span class="p">,</span>
            <span class="n">data_of_obj</span><span class="o">=</span><span class="n">data_of_obj</span><span class="p">,</span>
            <span class="n">preset</span><span class="o">=</span><span class="n">preset</span><span class="p">,</span>
            <span class="n">postget</span><span class="o">=</span><span class="n">postget</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>


<span class="n">kv_wrap</span><span class="o">.</span><span class="n">mk_trans_obj</span> <span class="o">=</span> <span class="n">mk_trans_obj</span>  <span class="c1"># to have a trans_obj maker handy</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">outcoming_keys</span> <span class="o">=</span> <span class="n">_kv_wrap_outcoming_keys</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">ingoing_keys</span> <span class="o">=</span> <span class="n">_kv_wrap_ingoing_keys</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">outcoming_vals</span> <span class="o">=</span> <span class="n">_kv_wrap_outcoming_vals</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">ingoing_vals</span> <span class="o">=</span> <span class="n">_kv_wrap_ingoing_vals</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">ingoing_vals_wrt_to_keys</span> <span class="o">=</span> <span class="n">_ingoing_vals_wrt_to_keys</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">outcoming_vals_wrt_to_keys</span> <span class="o">=</span> <span class="n">_outcoming_vals_wrt_to_keys</span>


<div class="viewcode-block" id="mk_wrapper"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.mk_wrapper">[docs]</a><span class="k">def</span> <span class="nf">mk_wrapper</span><span class="p">(</span><span class="n">wrap_cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    You have a wrapper class and you want to make a wrapper out of it,</span>
<span class="sd">    that is, a decorator factory with which you can make wrappers, like this:</span>
<span class="sd">    ```</span>
<span class="sd">    wrapper = mk_wrapper(wrap_cls)</span>
<span class="sd">    ```</span>
<span class="sd">    that you can then use to transform stores like thiis:</span>
<span class="sd">    ```</span>
<span class="sd">    MyStore = wrapper(**wrapper_kwargs)(StoreYouWantToTransform)</span>
<span class="sd">    ```</span>

<span class="sd">    :param wrap_cls:</span>
<span class="sd">    :return:</span>

<span class="sd">    &gt;&gt;&gt; class RelPath:</span>
<span class="sd">    ...     def __init__(self, root):</span>
<span class="sd">    ...         self.root = root</span>
<span class="sd">    ...         self._root_length = len(root)</span>
<span class="sd">    ...     def _key_of_id(self, _id):</span>
<span class="sd">    ...         return _id[self._root_length:]</span>
<span class="sd">    ...     def _id_of_key(self, k):</span>
<span class="sd">    ...         return self.root + k</span>
<span class="sd">    &gt;&gt;&gt; relpath_wrap = mk_wrapper(RelPath)</span>
<span class="sd">    &gt;&gt;&gt; RelDict = relpath_wrap(root=&#39;foo/&#39;)(dict)</span>
<span class="sd">    &gt;&gt;&gt; s = RelDict()</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;bar&#39;] = 42</span>
<span class="sd">    &gt;&gt;&gt; assert list(s) == [&#39;bar&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;bar&#39;] == 42</span>
<span class="sd">    &gt;&gt;&gt; assert str(s) == &quot;{&#39;foo/bar&#39;: 42}&quot;  # reveals that actually, behind the scenes, there&#39;s a &quot;foo/&quot; prefix</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrap_cls</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">kv_wrap</span><span class="p">(</span><span class="n">wrap_cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>


<div class="viewcode-block" id="add_wrapper_method"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.add_wrapper_method">[docs]</a><span class="k">def</span> <span class="nf">add_wrapper_method</span><span class="p">(</span><span class="n">wrap_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">method_name</span><span class="o">=</span><span class="s2">&quot;wrapper&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator that adds a wrapper method (itself a decorator) to a wrapping class</span>
<span class="sd">    Clear?</span>
<span class="sd">    See `mk_wrapper` function and doctest example if not.</span>

<span class="sd">    What `add_wrapper_method` does is just to add a `&quot;wrapper&quot;` method</span>
<span class="sd">    (or another name if you ask for it) to `wrap_cls`, so that you can use that</span>
<span class="sd">    class for it&#39;s purpose of transforming stores more conveniently.</span>

<span class="sd">    :param wrap_cls: The wrapper class (the definitioin of the transformation.</span>
<span class="sd">        If None, the functiion will make a decorator to decorate wrap_cls later</span>
<span class="sd">    :param method_name: The method name you want to use (default is &#39;wrapper&#39;)</span>

<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @add_wrapper_method</span>
<span class="sd">    ... class RelPath:</span>
<span class="sd">    ...     def __init__(self, root):</span>
<span class="sd">    ...         self.root = root</span>
<span class="sd">    ...         self._root_length = len(root)</span>
<span class="sd">    ...     def _key_of_id(self, _id):</span>
<span class="sd">    ...         return _id[self._root_length:]</span>
<span class="sd">    ...     def _id_of_key(self, k):</span>
<span class="sd">    ...         return self.root + k</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; RelDict = RelPath.wrapper(root=&#39;foo/&#39;)(dict)</span>
<span class="sd">    &gt;&gt;&gt; s = RelDict()</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;bar&#39;] = 42</span>
<span class="sd">    &gt;&gt;&gt; assert list(s) == [&#39;bar&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;bar&#39;] == 42</span>
<span class="sd">    &gt;&gt;&gt; assert str(s) == &quot;{&#39;foo/bar&#39;: 42}&quot;  # reveals that actually, behind the scenes, there&#39;s a &quot;foo/&quot; prefix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">wrap_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">add_wrapper_method</span><span class="p">,</span> <span class="n">method_name</span><span class="o">=</span><span class="n">method_name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">wrap_cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">mk_wrapper</span><span class="p">(</span><span class="n">wrap_cls</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">wrap_cls</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Aliasing</span>

<span class="n">_method_name_for</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;write&quot;</span><span class="p">:</span> <span class="s2">&quot;__setitem__&quot;</span><span class="p">,</span>
    <span class="s2">&quot;read&quot;</span><span class="p">:</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">,</span>
    <span class="s2">&quot;delete&quot;</span><span class="p">:</span> <span class="s2">&quot;__delitem__&quot;</span><span class="p">,</span>
    <span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">,</span>
    <span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="s2">&quot;__len__&quot;</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="add_path_get"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.add_path_get">[docs]</a><span class="k">def</span> <span class="nf">add_path_get</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path_type</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make nested stores accessible through key paths.</span>

<span class="sd">    Say you have some nested stores.</span>
<span class="sd">    You know... like a `ZipFileReader` store whose values are `ZipReader`s,</span>
<span class="sd">    whose values are bytes of the zipped files (and you can go on... whose (json) values are...).</span>

<span class="sd">    Well, you can access any node of this nested tree of stores like this:</span>
<span class="sd">    ```</span>
<span class="sd">        MyStore[key_1][key_2][key_3]</span>
<span class="sd">    ```</span>
<span class="sd">    And that&#39;s fine. But maybe you&#39;d like to do it this way instead:</span>
<span class="sd">    ```</span>
<span class="sd">        MyStore[key_1, key_2, key_3]</span>
<span class="sd">    ```</span>
<span class="sd">    Or like this:</span>

<span class="sd">        MyStore[&#39;key_1/key_2/key_3&#39;]</span>
<span class="sd">    Or this:</span>

<span class="sd">        MyStore[&#39;key_1.key_2.key_3&#39;]</span>
<span class="sd">    You get the point. This is what `add_path_get` is meant for.</span>

<span class="sd">    Args:</span>
<span class="sd">        store: The store (class or instance) you&#39;re wrapping.</span>
<span class="sd">            If not specified, the function will return a decorator.</span>
<span class="sd">        name: The name to give the class (not applicable to instance wrapping)</span>
<span class="sd">        path_type: The type that paths are expressed as. Needs to be an Iterable type. By default, a tuple.</span>
<span class="sd">            This is used to decide whether the key should be taken as a &quot;normal&quot; key of the store,</span>
<span class="sd">            or should be used to iterate through, recursively getting values.</span>

<span class="sd">    Returns: A wrapped store (class or instance), or a store wrapping decorator (if store is not specified)</span>

<span class="sd">    See Also: `py2store.key_mappers.paths.PathGetMixin`, `py2store.key_mappers.paths.KeyPath`</span>

<span class="sd">    &gt;&gt;&gt; # wrapping an instance</span>
<span class="sd">    &gt;&gt;&gt; s = add_path_get({&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 42}}})</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;]</span>
<span class="sd">    {&#39;b&#39;: {&#39;c&#39;: 42}}</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">    {&#39;c&#39;: 42}</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    42</span>
<span class="sd">    &gt;&gt;&gt; # wrapping a class</span>
<span class="sd">    &gt;&gt;&gt; S = add_path_get(dict)</span>
<span class="sd">    &gt;&gt;&gt; s = S(a={&#39;b&#39;: {&#39;c&#39;: 42}})</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;] == {&#39;b&#39;: {&#39;c&#39;: 42}}; assert s[&#39;a&#39;, &#39;b&#39;] == {&#39;c&#39;: 42}; assert s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] == 42</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # using add_path_get as a decorator</span>
<span class="sd">    &gt;&gt;&gt; @add_path_get</span>
<span class="sd">    ... class S(dict):</span>
<span class="sd">    ...    pass</span>
<span class="sd">    &gt;&gt;&gt; s = S(a={&#39;b&#39;: {&#39;c&#39;: 42}})</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;] == {&#39;b&#39;: {&#39;c&#39;: 42}};</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;, &#39;b&#39;] == s[&#39;a&#39;][&#39;b&#39;];</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] == s[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # a different kind of path?</span>
<span class="sd">    &gt;&gt;&gt; # You can choose a different path_type, but sometimes (say both keys and key paths are strings)</span>
<span class="sd">    &gt;&gt;&gt; # you need to involve more tools. Like py2store.key_mappers.paths.KeyPath...</span>
<span class="sd">    &gt;&gt;&gt; from py2store.key_mappers.paths import KeyPath</span>
<span class="sd">    &gt;&gt;&gt; from py2store import kv_wrap</span>
<span class="sd">    &gt;&gt;&gt; SS = kv_wrap(KeyPath(path_sep=&#39;.&#39;))(S)</span>
<span class="sd">    &gt;&gt;&gt; s = SS({&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 42}}})</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;] == {&#39;b&#39;: {&#39;c&#39;: 42}}; assert s[&#39;a.b&#39;] == s[&#39;a&#39;][&#39;b&#39;]; assert s[&#39;a.b.c&#39;] == s[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">add_path_get</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">path_type</span><span class="o">=</span><span class="n">path_type</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>  <span class="c1"># then consider it to be an instance</span>
        <span class="n">store_instance</span> <span class="o">=</span> <span class="n">store</span>
        <span class="n">WrapperStore</span> <span class="o">=</span> <span class="n">add_path_get</span><span class="p">(</span><span class="n">Store</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">path_type</span><span class="o">=</span><span class="n">path_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">WrapperStore</span><span class="p">(</span><span class="n">store_instance</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># it&#39;s a class we&#39;re wrapping</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">store</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s2">&quot;WithPathGet&quot;</span>

        <span class="c1"># TODO: This is not the best way to handle this. Investigate another way. ######################</span>
        <span class="n">global_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">globals</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">global_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;That name is already in use&quot;</span><span class="p">)</span>
        <span class="c1"># TODO: ########################################################################################</span>

        <span class="n">store_cls</span> <span class="o">=</span> <span class="n">kv_wrap_persister_cls</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">store_cls</span><span class="o">.</span><span class="n">_path_type</span> <span class="o">=</span> <span class="n">path_type</span>

        <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">store</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">store</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="n">store_cls</span><span class="o">.</span><span class="fm">__getitem__</span> <span class="o">=</span> <span class="fm">__getitem__</span>

        <span class="k">return</span> <span class="n">store_cls</span></div>


<span class="k">def</span> <span class="nf">_insert_alias</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">method_name</span><span class="p">))</span>


<div class="viewcode-block" id="insert_aliases"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.insert_aliases">[docs]</a><span class="k">def</span> <span class="nf">insert_aliases</span><span class="p">(</span>
        <span class="n">store</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Insert method aliases of CRUD operations of a store (class or instance).</span>
<span class="sd">    If store is a class, you&#39;ll get a copy of the class with those methods added.</span>
<span class="sd">    If store is an instance, the methods will be added in place (no copy will be made).</span>

<span class="sd">    Note: If an operation (write, read, delete, list, count) is not specified, no alias will be created for</span>
<span class="sd">    that operation.</span>

<span class="sd">    IMPORTANT NOTE: The signatures of the methods the aliases will point to will not change.</span>
<span class="sd">    We say this because, you can call the write method &quot;dump&quot;, but you&#39;ll have to use it as</span>
<span class="sd">    `store.dump(key, val)`, not `store.dump(val, key)`, which is the signature you&#39;re probably used to</span>
<span class="sd">    (it&#39;s the one used by json.dump or pickle.dump for example). If you want that familiar interface,</span>
<span class="sd">    using the insert_load_dump_aliases function.</span>

<span class="sd">    Args:</span>
<span class="sd">        store: The store to extend with aliases.</span>
<span class="sd">        write: Desired method name for __setitem__</span>
<span class="sd">        read: Desired method name for __getitem__</span>
<span class="sd">        delete: Desired method name for __delitem__</span>
<span class="sd">        list: Desired method name for __iter__</span>
<span class="sd">        count: Desired method name for __len__</span>

<span class="sd">    Returns: A store with the desired aliases.</span>

<span class="sd">    &gt;&gt;&gt; # Example of extending a class</span>
<span class="sd">    &gt;&gt;&gt; mydict = insert_aliases(dict, write=&#39;dump&#39;, read=&#39;load&#39;, delete=&#39;rm&#39;, list=&#39;peek&#39;, count=&#39;size&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s = mydict(true=&#39;love&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s.dump(&#39;friends&#39;, &#39;forever&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;true&#39;: &#39;love&#39;, &#39;friends&#39;: &#39;forever&#39;}</span>
<span class="sd">    &gt;&gt;&gt; s.load(&#39;true&#39;)</span>
<span class="sd">    &#39;love&#39;</span>
<span class="sd">    &gt;&gt;&gt; list(s.peek())</span>
<span class="sd">    [&#39;true&#39;, &#39;friends&#39;]</span>
<span class="sd">    &gt;&gt;&gt; s.size()</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; s.rm(&#39;true&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;friends&#39;: &#39;forever&#39;}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Example of extending an instance</span>
<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; s = UserDict(true=&#39;love&#39;)  # make (and instance) of a UserDict (can&#39;t modify a dict instance)</span>
<span class="sd">    &gt;&gt;&gt; # make aliases of note that you don&#39;t need</span>
<span class="sd">    &gt;&gt;&gt; s = insert_aliases(s, write=&#39;put&#39;, read=&#39;retrieve&#39;, count=&#39;num_of_items&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s.put(&#39;friends&#39;, &#39;forever&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;true&#39;: &#39;love&#39;, &#39;friends&#39;: &#39;forever&#39;}</span>
<span class="sd">    &gt;&gt;&gt; s.retrieve(&#39;true&#39;)</span>
<span class="sd">    &#39;love&#39;</span>
<span class="sd">    &gt;&gt;&gt; s.num_of_items()</span>
<span class="sd">    2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">store</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">store</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span> <span class="p">(</span><span class="n">store</span><span class="p">,),</span> <span class="p">{})</span>
    <span class="k">for</span> <span class="n">alias</span><span class="p">,</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="n">_method_name_for</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">_insert_alias</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">alias</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">store</span></div>


<div class="viewcode-block" id="insert_load_dump_aliases"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.insert_load_dump_aliases">[docs]</a><span class="k">def</span> <span class="nf">insert_load_dump_aliases</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Insert load and dump methods, with familiar dump(obj, location) signature.</span>

<span class="sd">    Args:</span>
<span class="sd">        store: The store to extend with aliases.</span>
<span class="sd">        delete: Desired method name for __delitem__</span>
<span class="sd">        list: Desired method name for __iter__</span>
<span class="sd">        count: Desired method name for __len__</span>

<span class="sd">    Returns: A store with the desired aliases.</span>

<span class="sd">    &gt;&gt;&gt; mydict = insert_load_dump_aliases(dict)</span>
<span class="sd">    &gt;&gt;&gt; s = mydict()</span>
<span class="sd">    &gt;&gt;&gt; s.dump(obj=&#39;love&#39;, key=&#39;true&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;true&#39;: &#39;love&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">store</span> <span class="o">=</span> <span class="n">insert_aliases</span><span class="p">(</span>
        <span class="n">store</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="s2">&quot;load&quot;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="n">delete</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">store</span><span class="o">.</span><span class="n">dump</span> <span class="o">=</span> <span class="n">dump</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">store</span><span class="o">.</span><span class="n">dump</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">dump</span><span class="p">,</span> <span class="n">store</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">store</span></div>


<span class="c1">########## To be deprecated ############################################################################################</span>

<span class="c1"># TODO: Factor out the method injection pattern (e.g. __getitem__, __setitem__ and __delitem__ are nearly identical)</span>

<div class="viewcode-block" id="filtered_iter"><a class="viewcode-back" href="../../test.html#py2store.examples.kv_walking.filtered_iter">[docs]</a><span class="k">def</span> <span class="nf">filtered_iter</span><span class="p">(</span>
        <span class="n">filt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">],</span> <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="vm">__module__</span><span class="o">=</span><span class="kc">None</span>  <span class="c1"># TODO: might be able to be deprecated since included in store_decorator</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a wrapper that will transform a store (class or instance thereof) into a sub-store (i.e. subset of keys).</span>

<span class="sd">    Args:</span>
<span class="sd">        filt: A callable or iterable:</span>
<span class="sd">            callable: Boolean filter function. A func taking a key and and returns True iff the key should be included.</span>
<span class="sd">            iterable: The collection of keys you want to filter &quot;in&quot;</span>
<span class="sd">        name: The name to give the wrapped class</span>

<span class="sd">    Returns: A wrapper (that then needs to be applied to a store instance or class.</span>

<span class="sd">    &gt;&gt;&gt; filtered_dict = filtered_iter(filt=lambda k: (len(k) % 2) == 1)(dict)  # keep only odd length keys</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s = filtered_dict({&#39;a&#39;: 1, &#39;bb&#39;: object, &#39;ccc&#39;: &#39;a string&#39;, &#39;dddd&#39;: [1, 2]})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;a&#39;, &#39;ccc&#39;]</span>
<span class="sd">    &gt;&gt;&gt; &#39;a&#39; in s  # True because odd (length) key</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; &#39;bb&#39; in s  # False because odd (length) key</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; assert s.get(&#39;bb&#39;, None) == None</span>
<span class="sd">    &gt;&gt;&gt; len(s)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; list(s.keys())</span>
<span class="sd">    [&#39;a&#39;, &#39;ccc&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.values())</span>
<span class="sd">    [1, &#39;a string&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    [(&#39;a&#39;, 1), (&#39;ccc&#39;, &#39;a string&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; s.get(&#39;a&#39;)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; assert s.get(&#39;bb&#39;) is None</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;x&#39;] = 10</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    [(&#39;a&#39;, 1), (&#39;ccc&#39;, &#39;a string&#39;), (&#39;x&#39;, 10)]</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     s[&#39;xx&#39;] = &#39;not an odd key&#39;</span>
<span class="sd">    ...     raise ValueError(&quot;This should have failed&quot;)</span>
<span class="sd">    ... except KeyError:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;filtered_iter is on it&#39;s way to be deprecated. Use filt_iter instead.</span>
<span class="s2">     To do so, replace:</span>
<span class="s2">        - imports of filtered_iter by filt_iter</span>
<span class="s2">        - non-keyword arguments by explicitly using arg names, for instance:</span>
<span class="s2">            ```filtered_iter(lambda x: True) -&gt; filt_iter(filt=lambda x: True)```</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">filt</span><span class="p">):</span>  <span class="c1"># if filt is not a callable...</span>
            <span class="c1"># ... assume it&#39;s the collection of keys you want and make a filter function to filter those &quot;in&quot;.</span>
            <span class="k">assert</span> <span class="nb">next</span><span class="p">(</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
            <span class="p">),</span> <span class="s2">&quot;filt should be a callable, or an iterable&quot;</span>
            <span class="n">keys_that_should_be_filtered_in</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys_that_should_be_filtered_in</span>

        <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="vm">__module__</span><span class="o">=</span><span class="vm">__module__</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">store</span><span class="p">,</span> <span class="nb">type</span>
            <span class="p">):</span>  <span class="c1"># then consider it to be an instance</span>
                <span class="n">store_instance</span> <span class="o">=</span> <span class="n">store</span>
                <span class="n">WrapperStore</span> <span class="o">=</span> <span class="n">filtered_iter</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="vm">__module__</span><span class="o">=</span><span class="vm">__module__</span><span class="p">)(</span><span class="n">Store</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">WrapperStore</span><span class="p">(</span><span class="n">store_instance</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># it&#39;s a class we&#39;re wrapping</span>
                <span class="n">collection_cls</span> <span class="o">=</span> <span class="n">store</span>
                <span class="vm">__module__</span> <span class="o">=</span> <span class="vm">__module__</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">collection_cls</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;Filtered&quot;</span> <span class="o">+</span> <span class="n">get_class_name</span><span class="p">(</span><span class="n">collection_cls</span><span class="p">)</span>
                <span class="n">wrapped_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">collection_cls</span><span class="p">,),</span> <span class="p">{})</span>

                <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">yield from</span> <span class="nb">filter</span><span class="p">(</span>
                        <span class="n">filt</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>
                    <span class="p">)</span>

                <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__iter__</span> <span class="o">=</span> <span class="fm">__iter__</span>

                <span class="n">_define_keys_values_and_items_according_to_iter</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">)</span>

                <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">():</span>
                        <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">return</span> <span class="n">c</span>

                <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="fm">__len__</span>

                <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>

                <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__contains__</span> <span class="o">=</span> <span class="fm">__contains__</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">):</span>

                    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key not in store: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__getitem__</span> <span class="o">=</span> <span class="fm">__getitem__</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="s2">&quot;get&quot;</span><span class="p">):</span>

                    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">default</span>

                    <span class="n">wrapped_cls</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">get</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="s2">&quot;__setitem__&quot;</span><span class="p">):</span>

                    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key not in store: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__setitem__</span> <span class="o">=</span> <span class="fm">__setitem__</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="s2">&quot;__delitem__&quot;</span><span class="p">):</span>

                    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapped_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key not in store: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">wrapped_cls</span><span class="o">.</span><span class="fm">__delitem__</span> <span class="o">=</span> <span class="fm">__delitem__</span>

                <span class="k">if</span> <span class="vm">__module__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">wrapped_cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="vm">__module__</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">collection_cls</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">):</span>
                    <span class="n">wrapped_cls</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">collection_cls</span><span class="o">.</span><span class="vm">__doc__</span>

                <span class="k">return</span> <span class="n">wrapped_cls</span>

        <span class="k">return</span> <span class="n">wrap</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filtered_iter</span><span class="p">(</span>
            <span class="n">filt</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="vm">__module__</span><span class="o">=</span><span class="vm">__module__</span>
        <span class="p">)(</span><span class="n">store</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">py2store</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../test.html">py2store.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.misc">py2store.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.mixins">py2store.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.test.util">py2store.test.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-test-quick">py2store.test.quick</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.test">py2store.test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-test-simple">py2store.test.simple</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-test-scrap">py2store.test.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.util">py2store.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-ext-docx">py2store.ext.docx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.ext.gitlab">py2store.ext.gitlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-ext-hdf">py2store.ext.hdf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.ext">py2store.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-ext-matlab">py2store.ext.matlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.ext.kaggle">py2store.ext.kaggle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-ext-module-imports">py2store.ext.module_imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.ext.audio">py2store.ext.audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-ext-github">py2store.ext.github</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.ext.dataframes">py2store.ext.dataframes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.access">py2store.access</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.__init__">py2store.__init__</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores.s3_store">py2store.stores.s3_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores.delegation_stores">py2store.stores.delegation_stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores.sql_w_sqlalchemy">py2store.stores.sql_w_sqlalchemy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-stores-arangodb-store">py2store.stores.arangodb_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-stores-dropbox-store">py2store.stores.dropbox_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores.local_store">py2store.stores.local_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores">py2store.stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-stores-couchdb-store">py2store.stores.couchdb_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores.mongo_store">py2store.stores.mongo_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.core">py2store.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.uri_utils">py2store.utils.uri_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.explicit">py2store.utils.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.timeseries_caching">py2store.utils.timeseries_caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-utils-attr-dict-py-attr-dict">py2store.utils.attr_dict.py.attr_dict</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-utils-attr-dict-py">py2store.utils.attr_dict.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.cumul_aggreg_write">py2store.utils.cumul_aggreg_write</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils">py2store.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.cache_descriptors">py2store.utils.cache_descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.appendable">py2store.utils.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.affine_conversion">py2store.utils.affine_conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.signatures">py2store.utils.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.sliceable">py2store.utils.sliceable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.mappify">py2store.utils.mappify</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.glom">py2store.utils.glom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-sql-w-odbc">py2store.persisters.sql_w_odbc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.dynamodb_w_boto3">py2store.persisters.dynamodb_w_boto3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-couchdb-w-couchdb">py2store.persisters.couchdb_w_couchdb</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.ftp_persister">py2store.persisters.ftp_persister</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.dropbox_w_urllib">py2store.persisters.dropbox_w_urllib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters._google_drive_in_progress">py2store.persisters._google_drive_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-dropbox-w-dropbox">py2store.persisters.dropbox_w_dropbox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-redis-w-redis">py2store.persisters.redis_w_redis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.sql_w_sqlalchemy">py2store.persisters.sql_w_sqlalchemy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.new_s3">py2store.persisters.new_s3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters">py2store.persisters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.dropbox_w_requests">py2store.persisters.dropbox_w_requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.w_aiofile">py2store.persisters.w_aiofile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.local_files">py2store.persisters.local_files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-arangodb-w-pyarango">py2store.persisters.arangodb_w_pyarango</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters._cassandra_in_progress">py2store.persisters._cassandra_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters._couchdb_in_progress">py2store.persisters._couchdb_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.s3_w_boto3">py2store.persisters.s3_w_boto3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-postgres-w-psycopg2-in-progress">py2store.persisters._postgres_w_psycopg2_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-ssh-persister">py2store.persisters.ssh_persister</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.mongo_w_pymongo">py2store.persisters.mongo_w_pymongo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-googledrive-w-pydrive">py2store.persisters.googledrive_w_pydrive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.sources">py2store.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.dig">py2store.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers.pickled">py2store.serializers.pickled</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers.jsonization">py2store.serializers.jsonization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers">py2store.serializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers.sequential">py2store.serializers.sequential</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers.regular_panel_data">py2store.serializers.regular_panel_data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers.audio">py2store.serializers.audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.caching">py2store.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.scrap">py2store.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.scrap.new_gen_local">py2store.scrap.new_gen_local</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.examples.write_caches">py2store.examples.write_caches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.examples">py2store.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.examples.python_code_stats">py2store.examples.python_code_stats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.examples.kv_walking">py2store.examples.kv_walking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.my">py2store.my</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.my.grabbers">py2store.my.grabbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.trans">py2store.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.key_mappers.str_utils">py2store.key_mappers.str_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.key_mappers.tuples">py2store.key_mappers.tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.key_mappers.paths">py2store.key_mappers.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.key_mappers.naming">py2store.key_mappers.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.key_mappers">py2store.key_mappers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.errors">py2store.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.slib.s_configparser">py2store.slib.s_configparser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.slib">py2store.slib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.slib.s_zipfile">py2store.slib.s_zipfile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.base">py2store.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-selectors-mg-selectors">py2store.selectors.mg_selectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-selectors-mongoquery">py2store.selectors.mongoquery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-selectors">py2store.selectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.parse_format">py2store.parse_format</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../py2store.html">py2store</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>