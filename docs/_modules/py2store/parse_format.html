
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>py2store.parse_format &#8212; py2store 0.0.7 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for py2store.parse_format</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Modified from https://github.com/r1chardj0n3s/parse</span>

<span class="sd">Parse strings using a specification based on the Python format() syntax.</span>

<span class="sd">   ``parse()`` is the opposite of ``format()``</span>


<span class="sd">From there it&#39;s a simple thing to parse a string:</span>

<span class="sd">&gt;&gt;&gt; parse(&quot;It&#39;s {}, I love it!&quot;, &quot;It&#39;s spam, I love it!&quot;)</span>
<span class="sd">&lt;Result (&#39;spam&#39;,) {}&gt;</span>
<span class="sd">&gt;&gt;&gt; _[0]</span>
<span class="sd">&#39;spam&#39;</span>

<span class="sd">Or to search a string for some pattern:</span>

<span class="sd">&gt;&gt;&gt; search(&#39;Age: {:d}\n&#39;, &#39;Name: Rufus\nAge: 42\nColor: red\n&#39;)</span>
<span class="sd">&lt;Result (42,) {}&gt;</span>

<span class="sd">Or find all the occurrences of some pattern in a string:</span>

<span class="sd">&gt;&gt;&gt; &#39;&#39;.join(r.fixed[0] for r in findall(&quot;&gt;{}&lt;&quot;, &quot;&lt;p&gt;the &lt;b&gt;bold&lt;/b&gt; text&lt;/p&gt;&quot;))</span>
<span class="sd">&#39;the bold text&#39;</span>

<span class="sd">If you&#39;re going to use the same pattern to match lots of strings you can</span>
<span class="sd">compile it once:</span>

<span class="sd">&gt;&gt;&gt; p = compile(&quot;It&#39;s {}, I love it!&quot;)</span>
<span class="sd">&gt;&gt;&gt; print(p)</span>
<span class="sd">&lt;Parser &quot;It&#39;s {}, I love it!&quot;&gt;</span>
<span class="sd">&gt;&gt;&gt; p.parse(&quot;It&#39;s spam, I love it!&quot;)</span>
<span class="sd">&lt;Result (&#39;spam&#39;,) {}&gt;</span>

<span class="sd">(&quot;compile&quot; is not exported for ``import *`` usage as it would override the</span>
<span class="sd">built-in ``compile()`` function)</span>

<span class="sd">The default behaviour is to match strings case insensitively. You may match with</span>
<span class="sd">case by specifying `case_sensitive=True`:</span>

<span class="sd">&gt;&gt;&gt; parse(&#39;SPAM&#39;, &#39;spam&#39;, case_sensitive=True) is None</span>
<span class="sd">True</span>


<span class="sd">Format Syntax</span>
<span class="sd">-------------</span>

<span class="sd">A basic version of the `Format String Syntax`_ is supported with anonymous</span>
<span class="sd">(fixed-position), named and formatted fields::</span>

<span class="sd">   {[field name]:[format spec]}</span>

<span class="sd">Field names must be a valid Python identifiers, including dotted names;</span>
<span class="sd">element indexes imply dictionaries (see below for example).</span>

<span class="sd">Numbered fields are also not supported: the result of parsing will include</span>
<span class="sd">the parsed fields in the order they are parsed.</span>

<span class="sd">The conversion of fields to types other than strings is done based on the</span>
<span class="sd">type in the format specification, which mirrors the ``format()`` behaviour.</span>
<span class="sd">There are no &quot;!&quot; field conversions like ``format()`` has.</span>

<span class="sd">Some simple parse() format string examples:</span>

<span class="sd">&gt;&gt;&gt; parse(&quot;Bring me a {}&quot;, &quot;Bring me a shrubbery&quot;)</span>
<span class="sd">&lt;Result (&#39;shrubbery&#39;,) {}&gt;</span>
<span class="sd">&gt;&gt;&gt; r = parse(&quot;The {} who say {}&quot;, &quot;The knights who say Ni!&quot;)</span>
<span class="sd">&gt;&gt;&gt; print(r)</span>
<span class="sd">&lt;Result (&#39;knights&#39;, &#39;Ni!&#39;) {}&gt;</span>
<span class="sd">&gt;&gt;&gt; print(r.fixed)</span>
<span class="sd">(&#39;knights&#39;, &#39;Ni!&#39;)</span>
<span class="sd">&gt;&gt;&gt; r = parse(&quot;Bring out the holy {item}&quot;, &quot;Bring out the holy hand grenade&quot;)</span>
<span class="sd">&gt;&gt;&gt; print(r)</span>
<span class="sd">&lt;Result () {&#39;item&#39;: &#39;hand grenade&#39;}&gt;</span>
<span class="sd">&gt;&gt;&gt; print(r.named)</span>
<span class="sd">{&#39;item&#39;: &#39;hand grenade&#39;}</span>
<span class="sd">&gt;&gt;&gt; print(r[&#39;item&#39;])</span>
<span class="sd">hand grenade</span>

<span class="sd">Dotted names and indexes are possible though the application must make</span>
<span class="sd">additional sense of the result:</span>

<span class="sd">&gt;&gt;&gt; r = parse(&quot;Mmm, {food.type}, I love it!&quot;, &quot;Mmm, spam, I love it!&quot;)</span>
<span class="sd">&gt;&gt;&gt; print(r)</span>
<span class="sd">&lt;Result () {&#39;food.type&#39;: &#39;spam&#39;}&gt;</span>
<span class="sd">&gt;&gt;&gt; print(r.named)</span>
<span class="sd">{&#39;food.type&#39;: &#39;spam&#39;}</span>
<span class="sd">&gt;&gt;&gt; print(r[&#39;food.type&#39;])</span>
<span class="sd">spam</span>
<span class="sd">&gt;&gt;&gt; r = parse(&quot;My quest is {quest[name]}&quot;, &quot;My quest is to seek the holy grail!&quot;)</span>
<span class="sd">&gt;&gt;&gt; print(r)</span>
<span class="sd">&lt;Result () {&#39;quest&#39;: {&#39;name&#39;: &#39;to seek the holy grail!&#39;}}&gt;</span>
<span class="sd">&gt;&gt;&gt; print(r[&#39;quest&#39;])</span>
<span class="sd">{&#39;name&#39;: &#39;to seek the holy grail!&#39;}</span>
<span class="sd">&gt;&gt;&gt; print(r[&#39;quest&#39;][&#39;name&#39;])</span>
<span class="sd">to seek the holy grail!</span>

<span class="sd">If the text you&#39;re matching has braces in it you can match those by including</span>
<span class="sd">a double-brace ``{{`` or ``}}`` in your format string, just like format() does.</span>


<span class="sd">Format Specification</span>
<span class="sd">--------------------</span>

<span class="sd">Most often a straight format-less ``{}`` will suffice where a more complex</span>
<span class="sd">format specification might have been used.</span>

<span class="sd">Most of `format()`&#39;s `Format Specification Mini-Language`_ is supported:</span>

<span class="sd">   [[fill]align][0][width][.precision][type]</span>

<span class="sd">The differences between `parse()` and `format()` are:</span>

<span class="sd">- The align operators will cause spaces (or specified fill character) to be</span>
<span class="sd">  stripped from the parsed value. The width is not enforced; it just indicates</span>
<span class="sd">  there may be whitespace or &quot;0&quot;s to strip.</span>
<span class="sd">- Numeric parsing will automatically handle a &quot;0b&quot;, &quot;0o&quot; or &quot;0x&quot; prefix.</span>
<span class="sd">  That is, the &quot;#&quot; format character is handled automatically by d, b, o</span>
<span class="sd">  and x formats. For &quot;d&quot; any will be accepted, but for the others the correct</span>
<span class="sd">  prefix must be present if at all.</span>
<span class="sd">- Numeric sign is handled automatically.</span>
<span class="sd">- The thousands separator is handled automatically if the &quot;n&quot; type is used.</span>
<span class="sd">- The types supported are a slightly different mix to the format() types.  Some</span>
<span class="sd">  format() types come directly over: &quot;d&quot;, &quot;n&quot;, &quot;%&quot;, &quot;f&quot;, &quot;e&quot;, &quot;b&quot;, &quot;o&quot; and &quot;x&quot;.</span>
<span class="sd">  In addition some regular expression character group types &quot;D&quot;, &quot;w&quot;, &quot;W&quot;, &quot;s&quot;</span>
<span class="sd">  and &quot;S&quot; are also available.</span>
<span class="sd">- The &quot;e&quot; and &quot;g&quot; types are case-insensitive so there is not need for</span>
<span class="sd">  the &quot;E&quot; or &quot;G&quot; types.</span>

<span class="sd">===== =========================================== ========</span>
<span class="sd">Type  Characters Matched                          Output</span>
<span class="sd">===== =========================================== ========</span>
<span class="sd"> w    Letters and underscore                      str</span>
<span class="sd"> W    Non-letter and underscore                   str</span>
<span class="sd"> s    Whitespace                                  str</span>
<span class="sd"> S    Non-whitespace                              str</span>
<span class="sd"> d    Digits (effectively integer numbers)        int</span>
<span class="sd"> D    Non-digit                                   str</span>
<span class="sd"> n    Numbers with thousands separators (, or .)  int</span>
<span class="sd"> %    Percentage (converted to value/100.0)       float</span>
<span class="sd"> f    Fixed-point numbers                         float</span>
<span class="sd"> F    Decimal numbers                             Decimal</span>
<span class="sd"> e    Floating-point numbers with exponent        float</span>
<span class="sd">      e.g. 1.1e-10, NAN (all case insensitive)</span>
<span class="sd"> g    General number format (either d, f or e)    float</span>
<span class="sd"> b    Binary numbers                              int</span>
<span class="sd"> o    Octal numbers                               int</span>
<span class="sd"> x    Hexadecimal numbers (lower and upper case)  int</span>
<span class="sd"> ti   ISO 8601 format date/time                   datetime</span>
<span class="sd">      e.g. 1972-01-20T10:21:36Z (&quot;T&quot; and &quot;Z&quot;</span>
<span class="sd">      optional)</span>
<span class="sd"> te   RFC2822 e-mail format date/time             datetime</span>
<span class="sd">      e.g. Mon, 20 Jan 1972 10:21:36 +1000</span>
<span class="sd"> tg   Global (day/month) format date/time         datetime</span>
<span class="sd">      e.g. 20/1/1972 10:21:36 AM +1:00</span>
<span class="sd"> ta   US (month/day) format date/time             datetime</span>
<span class="sd">      e.g. 1/20/1972 10:21:36 PM +10:30</span>
<span class="sd"> tc   ctime() format date/time                    datetime</span>
<span class="sd">      e.g. Sun Sep 16 01:03:52 1973</span>
<span class="sd"> th   HTTP log format date/time                   datetime</span>
<span class="sd">      e.g. 21/Nov/2011:00:07:11 +0000</span>
<span class="sd"> ts   Linux system log format date/time           datetime</span>
<span class="sd">      e.g. Nov  9 03:37:44</span>
<span class="sd"> tt   Time                                        time</span>
<span class="sd">      e.g. 10:21:36 PM -5:30</span>
<span class="sd">===== =========================================== ========</span>

<span class="sd">Some examples of typed parsing with ``None`` returned if the typing</span>
<span class="sd">does not match:</span>

<span class="sd">&gt;&gt;&gt; parse(&#39;Our {:d} {:w} are...&#39;, &#39;Our 3 weapons are...&#39;)</span>
<span class="sd">&lt;Result (3, &#39;weapons&#39;) {}&gt;</span>
<span class="sd">&gt;&gt;&gt; parse(&#39;Our {:d} {:w} are...&#39;, &#39;Our three weapons are...&#39;)</span>
<span class="sd">&gt;&gt;&gt; parse(&#39;Meet at {:tg}&#39;, &#39;Meet at 1/2/2011 11:00 PM&#39;)</span>
<span class="sd">&lt;Result (datetime.datetime(2011, 2, 1, 23, 0),) {}&gt;</span>

<span class="sd">And messing about with alignment:</span>

<span class="sd">&gt;&gt;&gt; parse(&#39;with {:&gt;} herring&#39;, &#39;with     a herring&#39;)</span>
<span class="sd">&lt;Result (&#39;a&#39;,) {}&gt;</span>
<span class="sd">&gt;&gt;&gt; parse(&#39;spam {:^} spam&#39;, &#39;spam    lovely     spam&#39;)</span>
<span class="sd">&lt;Result (&#39;lovely&#39;,) {}&gt;</span>

<span class="sd">Note that the &quot;center&quot; alignment does not test to make sure the value is</span>
<span class="sd">centered - it just strips leading and trailing whitespace.</span>

<span class="sd">Width and precision may be used to restrict the size of matched text</span>
<span class="sd">from the input. Width specifies a minimum size and precision specifies</span>
<span class="sd">a maximum. For example:</span>

<span class="sd">&gt;&gt;&gt; parse(&#39;{:.2}{:.2}&#39;, &#39;look&#39;)           # specifying precision</span>
<span class="sd">&lt;Result (&#39;lo&#39;, &#39;ok&#39;) {}&gt;</span>
<span class="sd">&gt;&gt;&gt; parse(&#39;{:4}{:4}&#39;, &#39;look at that&#39;)     # specifying width</span>
<span class="sd">&lt;Result (&#39;look&#39;, &#39;at that&#39;) {}&gt;</span>
<span class="sd">&gt;&gt;&gt; parse(&#39;{:4}{:.4}&#39;, &#39;look at that&#39;)    # specifying both</span>
<span class="sd">&lt;Result (&#39;look at &#39;, &#39;that&#39;) {}&gt;</span>
<span class="sd">&gt;&gt;&gt; parse(&#39;{:2d}{:2d}&#39;, &#39;0440&#39;)           # parsing two contiguous numbers</span>
<span class="sd">&lt;Result (4, 40) {}&gt;</span>

<span class="sd">Some notes for the date and time types:</span>

<span class="sd">- the presence of the time part is optional (including ISO 8601, starting</span>
<span class="sd">  at the &quot;T&quot;). A full datetime object will always be returned; the time</span>
<span class="sd">  will be set to 00:00:00. You may also specify a time without seconds.</span>
<span class="sd">- when a seconds amount is present in the input fractions will be parsed</span>
<span class="sd">  to give microseconds.</span>
<span class="sd">- except in ISO 8601 the day and month digits may be 0-padded.</span>
<span class="sd">- the date separator for the tg and ta formats may be &quot;-&quot; or &quot;/&quot;.</span>
<span class="sd">- named months (abbreviations or full names) may be used in the ta and tg</span>
<span class="sd">  formats in place of numeric months.</span>
<span class="sd">- as per RFC 2822 the e-mail format may omit the day (and comma), and the</span>
<span class="sd">  seconds but nothing else.</span>
<span class="sd">- hours greater than 12 will be happily accepted.</span>
<span class="sd">- the AM/PM are optional, and if PM is found then 12 hours will be added</span>
<span class="sd">  to the datetime object&#39;s hours amount - even if the hour is greater</span>
<span class="sd">  than 12 (for consistency.)</span>
<span class="sd">- in ISO 8601 the &quot;Z&quot; (UTC) timezone part may be a numeric offset</span>
<span class="sd">- timezones are specified as &quot;+HH:MM&quot; or &quot;-HH:MM&quot;. The hour may be one or two</span>
<span class="sd">  digits (0-padded is OK.) Also, the &quot;:&quot; is optional.</span>
<span class="sd">- the timezone is optional in all except the e-mail format (it defaults to</span>
<span class="sd">  UTC.)</span>
<span class="sd">- named timezones are not handled yet.</span>

<span class="sd">Note: attempting to match too many datetime fields in a single parse() will</span>
<span class="sd">currently result in a resource allocation issue. A TooManyFields exception</span>
<span class="sd">will be raised in this instance. The current limit is about 15. It is hoped</span>
<span class="sd">that this limit will be removed one day.</span>

<span class="sd">.. _`Format String Syntax`:</span>
<span class="sd">  http://docs.python.org/library/string.html#format-string-syntax</span>
<span class="sd">.. _`Format Specification Mini-Language`:</span>
<span class="sd">  http://docs.python.org/library/string.html#format-specification-mini-language</span>


<span class="sd">Result and Match Objects</span>
<span class="sd">------------------------</span>

<span class="sd">The result of a ``parse()`` and ``search()`` operation is either ``None`` (no match), a</span>
<span class="sd">``Result`` instance or a ``Match`` instance if ``evaluate_result`` is False.</span>

<span class="sd">The ``Result`` instance has three attributes:</span>

<span class="sd">fixed</span>
<span class="sd">   A tuple of the fixed-position, anonymous fields extracted from the input.</span>
<span class="sd">named</span>
<span class="sd">   A dictionary of the named fields extracted from the input.</span>
<span class="sd">spans</span>
<span class="sd">   A dictionary mapping the names and fixed position indices matched to a</span>
<span class="sd">   2-tuple slice range of where the match occurred in the input.</span>
<span class="sd">   The span does not include any stripped padding (alignment or width).</span>

<span class="sd">The ``Match`` instance has one method:</span>

<span class="sd">evaluate_result()</span>
<span class="sd">   Generates and returns a ``Result`` instance for this ``Match`` object.</span>



<span class="sd">Custom Type Conversions</span>
<span class="sd">-----------------------</span>

<span class="sd">If you wish to have matched fields automatically converted to your own type you</span>
<span class="sd">may pass in a dictionary of type conversion information to ``parse()`` and</span>
<span class="sd">``compile()``.</span>

<span class="sd">The converter will be passed the field string matched. Whatever it returns</span>
<span class="sd">will be substituted in the ``Result`` instance for that field.</span>

<span class="sd">Your custom type conversions may override the builtin types if you supply one</span>
<span class="sd">with the same identifier.</span>

<span class="sd">&gt;&gt;&gt; def shouty(string):</span>
<span class="sd">...    return string.upper()</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; parse(&#39;{:shouty} world&#39;, &#39;hello world&#39;, dict(shouty=shouty))</span>
<span class="sd">&lt;Result (&#39;HELLO&#39;,) {}&gt;</span>

<span class="sd">If the type converter has the optional ``pattern`` attribute, it is used as</span>
<span class="sd">regular expression for better pattern matching (instead of the default one).</span>

<span class="sd">&gt;&gt;&gt; def parse_number(text):</span>
<span class="sd">...    return int(text)</span>
<span class="sd">&gt;&gt;&gt; parse_number.pattern = r&#39;\d+&#39;</span>
<span class="sd">&gt;&gt;&gt; parse(&#39;Answer: {number:Number}&#39;, &#39;Answer: 42&#39;, dict(Number=parse_number))</span>
<span class="sd">&lt;Result () {&#39;number&#39;: 42}&gt;</span>
<span class="sd">&gt;&gt;&gt; _ = parse(&#39;Answer: {:Number}&#39;, &#39;Answer: Alice&#39;, dict(Number=parse_number))</span>
<span class="sd">&gt;&gt;&gt; assert _ is None, &quot;MISMATCH&quot;</span>

<span class="sd">You can also use the ``with_pattern(pattern)`` decorator to add this</span>
<span class="sd">information to a type converter function:</span>

<span class="sd">&gt;&gt;&gt; @with_pattern(r&#39;\d+&#39;)</span>
<span class="sd">... def parse_number(text):</span>
<span class="sd">...    return int(text)</span>
<span class="sd">&gt;&gt;&gt; parse(&#39;Answer: {number:Number}&#39;, &#39;Answer: 42&#39;, dict(Number=parse_number))</span>
<span class="sd">&lt;Result () {&#39;number&#39;: 42}&gt;</span>

<span class="sd">A more complete example of a custom type might be:</span>

<span class="sd">&gt;&gt;&gt; yesno_mapping = {</span>
<span class="sd">...     &quot;yes&quot;:  True,   &quot;no&quot;:    False,</span>
<span class="sd">...     &quot;on&quot;:   True,   &quot;off&quot;:   False,</span>
<span class="sd">...     &quot;true&quot;: True,   &quot;false&quot;: False,</span>
<span class="sd">... }</span>
<span class="sd">&gt;&gt;&gt; @with_pattern(r&quot;|&quot;.join(yesno_mapping))</span>
<span class="sd">... def parse_yesno(text):</span>
<span class="sd">...     return yesno_mapping[text.lower()]</span>


<span class="sd">If the type converter ``pattern`` uses regex-grouping (with parenthesis),</span>
<span class="sd">you should indicate this by using the optional ``regex_group_count`` parameter</span>
<span class="sd">in the ``with_pattern()`` decorator:</span>

<span class="sd">&gt;&gt;&gt; @with_pattern(r&#39;((\d+))&#39;, regex_group_count=2)</span>
<span class="sd">... def parse_number2(text):</span>
<span class="sd">...    return int(text)</span>
<span class="sd">&gt;&gt;&gt; parse(&#39;Answer: {:Number2} {:Number2}&#39;, &#39;Answer: 42 43&#39;, dict(Number2=parse_number2))</span>
<span class="sd">&lt;Result (42, 43) {}&gt;</span>

<span class="sd">Otherwise, this may cause parsing problems with unnamed/fixed parameters.</span>


<span class="sd">Potential Gotchas</span>
<span class="sd">-----------------</span>

<span class="sd">`parse()` will always match the shortest text necessary (from left to right)</span>
<span class="sd">to fulfil the parse pattern, so for example:</span>

<span class="sd">&gt;&gt;&gt; pattern = &#39;{dir1}/{dir2}&#39;</span>
<span class="sd">&gt;&gt;&gt; data = &#39;root/parent/subdir&#39;</span>
<span class="sd">&gt;&gt;&gt; sorted(parse(pattern, data).named.items())</span>
<span class="sd">[(&#39;dir1&#39;, &#39;root&#39;), (&#39;dir2&#39;, &#39;parent/subdir&#39;)]</span>

<span class="sd">So, even though `{&#39;dir1&#39;: &#39;root/parent&#39;, &#39;dir2&#39;: &#39;subdir&#39;}` would also fit</span>
<span class="sd">the pattern, the actual match represents the shortest successful match for</span>
<span class="sd">`dir1`.</span>

<span class="sd">----</span>

<span class="sd">**Version history (in brief)**:</span>

<span class="sd">- 1.9.0 We now honor precision and width specifiers when parsing numbers</span>
<span class="sd">  and strings, allowing parsing of concatenated elements of fixed width</span>
<span class="sd">  (thanks Julia Signell)</span>
<span class="sd">- 1.8.4 Add LICENSE file at request of packagers.</span>
<span class="sd">  Correct handling of AM/PM to follow most common interpretation.</span>
<span class="sd">  Correct parsing of hexadecimal that looks like a binary prefix.</span>
<span class="sd">  Add ability to parse case sensitively.</span>
<span class="sd">  Add parsing of numbers to Decimal with &quot;F&quot; (thanks John Vandenberg)</span>
<span class="sd">- 1.8.3 Add regex_group_count to with_pattern() decorator to support</span>
<span class="sd">  user-defined types that contain brackets/parenthesis (thanks Jens Engel)</span>
<span class="sd">- 1.8.2 add documentation for including braces in format string</span>
<span class="sd">- 1.8.1 ensure bare hexadecimal digits are not matched</span>
<span class="sd">- 1.8.0 support manual control over result evaluation (thanks Timo Furrer)</span>
<span class="sd">- 1.7.0 parse dict fields (thanks Mark Visser) and adapted to allow</span>
<span class="sd">  more than 100 re groups in Python 3.5+ (thanks David King)</span>
<span class="sd">- 1.6.6 parse Linux system log dates (thanks Alex Cowan)</span>
<span class="sd">- 1.6.5 handle precision in float format (thanks Levi Kilcher)</span>
<span class="sd">- 1.6.4 handle pipe &quot;|&quot; characters in parse string (thanks Martijn Pieters)</span>
<span class="sd">- 1.6.3 handle repeated instances of named fields, fix bug in PM time</span>
<span class="sd">  overflow</span>
<span class="sd">- 1.6.2 fix logging to use local, not root logger (thanks Necku)</span>
<span class="sd">- 1.6.1 be more flexible regarding matched ISO datetimes and timezones in</span>
<span class="sd">  general, fix bug in timezones without &quot;:&quot; and improve docs</span>
<span class="sd">- 1.6.0 add support for optional ``pattern`` attribute in user-defined types</span>
<span class="sd">  (thanks Jens Engel)</span>
<span class="sd">- 1.5.3 fix handling of question marks</span>
<span class="sd">- 1.5.2 fix type conversion error with dotted names (thanks Sebastian Thiel)</span>
<span class="sd">- 1.5.1 implement handling of named datetime fields</span>
<span class="sd">- 1.5 add handling of dotted field names (thanks Sebastian Thiel)</span>
<span class="sd">- 1.4.1 fix parsing of &quot;0&quot; in int conversion (thanks James Rowe)</span>
<span class="sd">- 1.4 add __getitem__ convenience access on Result.</span>
<span class="sd">- 1.3.3 fix Python 2.5 setup.py issue.</span>
<span class="sd">- 1.3.2 fix Python 3.2 setup.py issue.</span>
<span class="sd">- 1.3.1 fix a couple of Python 3.2 compatibility issues.</span>
<span class="sd">- 1.3 added search() and findall(); removed compile() from ``import *``</span>
<span class="sd">  export as it overwrites builtin.</span>
<span class="sd">- 1.2 added ability for custom and override type conversions to be</span>
<span class="sd">  provided; some cleanup</span>
<span class="sd">- 1.1.9 to keep things simpler number sign is handled automatically;</span>
<span class="sd">  significant robustification in the face of edge-case input.</span>
<span class="sd">- 1.1.8 allow &quot;d&quot; fields to have number base &quot;0x&quot; etc. prefixes;</span>
<span class="sd">  fix up some field type interactions after stress-testing the parser;</span>
<span class="sd">  implement &quot;%&quot; type.</span>
<span class="sd">- 1.1.7 Python 3 compatibility tweaks (2.5 to 2.7 and 3.2 are supported).</span>
<span class="sd">- 1.1.6 add &quot;e&quot; and &quot;g&quot; field types; removed redundant &quot;h&quot; and &quot;X&quot;;</span>
<span class="sd">  removed need for explicit &quot;#&quot;.</span>
<span class="sd">- 1.1.5 accept textual dates in more places; Result now holds match span</span>
<span class="sd">  positions.</span>
<span class="sd">- 1.1.4 fixes to some int type conversion; implemented &quot;=&quot; alignment; added</span>
<span class="sd">  date/time parsing with a variety of formats handled.</span>
<span class="sd">- 1.1.3 type conversion is automatic based on specified field types. Also added</span>
<span class="sd">  &quot;f&quot; and &quot;n&quot; types.</span>
<span class="sd">- 1.1.2 refactored, added compile() and limited ``from parse import *``</span>
<span class="sd">- 1.1.1 documentation improvements</span>
<span class="sd">- 1.1.0 implemented more of the `Format Specification Mini-Language`_</span>
<span class="sd">  and removed the restriction on mixing fixed-position and named fields</span>
<span class="sd">- 1.0.0 initial release</span>

<span class="sd">This code is copyright 2012-2017 Richard Jones &lt;richard@python.org&gt;</span>
<span class="sd">See the end of the source file for the license of use.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;1.9.0&quot;</span>

<span class="c1"># yes, I now have two problems</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">tzinfo</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="s2">&quot;parse search findall with_pattern&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="with_pattern"><a class="viewcode-back" href="../../test.html#py2store.parse_format.with_pattern">[docs]</a><span class="k">def</span> <span class="nf">with_pattern</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">regex_group_count</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Attach a regular expression pattern matcher to a custom type converter</span>
<span class="sd">    function.</span>

<span class="sd">    This annotates the type converter with the :attr:`pattern` attribute.</span>

<span class="sd">    EXAMPLE:</span>
<span class="sd">        &gt;&gt;&gt; @with_pattern(r&quot;\d+&quot;)</span>
<span class="sd">        ... def parse_number(text):</span>
<span class="sd">        ...     return int(text)</span>

<span class="sd">    is equivalent to:</span>

<span class="sd">        &gt;&gt;&gt; def parse_number(text):</span>
<span class="sd">        ...     return int(text)</span>
<span class="sd">        &gt;&gt;&gt; parse_number.pattern = r&quot;\d+&quot;</span>

<span class="sd">    :param pattern: regular expression pattern (as text)</span>
<span class="sd">    :param regex_group_count: Indicates how many regex-groups are in pattern.</span>
<span class="sd">    :return: wrapped function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">func</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="n">func</span><span class="o">.</span><span class="n">regex_group_count</span> <span class="o">=</span> <span class="n">regex_group_count</span>
        <span class="k">return</span> <span class="n">func</span>

    <span class="k">return</span> <span class="n">decorator</span></div>


<span class="k">def</span> <span class="nf">int_convert</span><span class="p">(</span><span class="n">base</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a string to an integer.</span>

<span class="sd">    The string may start with a sign.</span>

<span class="sd">    It may be of a base other than 10.</span>

<span class="sd">    If may start with a base indicator, 0#nnnn, which we assume should</span>
<span class="sd">    override the specified base.</span>

<span class="sd">    It may also have other non-numeric characters that we can ignore.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHARS</span> <span class="o">=</span> <span class="s2">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;bB&quot;</span><span class="p">:</span>
                <span class="n">base</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;oO&quot;</span><span class="p">:</span>
                <span class="n">base</span> <span class="o">=</span> <span class="mi">8</span>
            <span class="k">elif</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;xX&quot;</span><span class="p">:</span>
                <span class="n">base</span> <span class="o">=</span> <span class="mi">16</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># just go with the base specifed</span>
                <span class="k">pass</span>

        <span class="n">chars</span> <span class="o">=</span> <span class="n">CHARS</span><span class="p">[:</span><span class="n">base</span><span class="p">]</span>
        <span class="n">string</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;[^</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">chars</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">f</span>


<span class="k">def</span> <span class="nf">percentage</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">string</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">100.0</span>


<span class="k">class</span> <span class="nc">FixedTzOffset</span><span class="p">(</span><span class="n">tzinfo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fixed offset in minutes east from UTC.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ZERO</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">utcoffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>

    <span class="k">def</span> <span class="nf">tzname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="nf">dst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZERO</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_offset</span>


<span class="n">MONTHS_MAP</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">Jan</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">January</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Feb</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">February</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">Mar</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">March</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">Apr</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">April</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">May</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">Jun</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">June</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">Jul</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
    <span class="n">July</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
    <span class="n">Aug</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">August</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">Sep</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
    <span class="n">September</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
    <span class="n">Oct</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">October</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">Nov</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>
    <span class="n">November</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>
    <span class="n">Dec</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
    <span class="n">December</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">DAYS_PAT</span> <span class="o">=</span> <span class="s2">&quot;(Mon|Tue|Wed|Thu|Fri|Sat|Sun)&quot;</span>
<span class="n">MONTHS_PAT</span> <span class="o">=</span> <span class="s2">&quot;(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)&quot;</span>
<span class="n">ALL_MONTHS_PAT</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">MONTHS_MAP</span><span class="p">)</span>
<span class="n">TIME_PAT</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(\d{1,2}:\d{1,2}(:\d{1,2}(\.\d+)?)?)&quot;</span>
<span class="n">AM_PAT</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(\s+[AP]M)&quot;</span>
<span class="n">TZ_PAT</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(\s+[-+]\d\d?:?\d\d)&quot;</span>


<span class="k">def</span> <span class="nf">date_convert</span><span class="p">(</span>
        <span class="n">string</span><span class="p">,</span>
        <span class="n">match</span><span class="p">,</span>
        <span class="n">ymd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mdy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dmy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">d_m_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">hms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">am</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert the incoming string containing some date / time info into a</span>
<span class="sd">    datetime instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
    <span class="n">time_only</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">mm</span> <span class="ow">and</span> <span class="n">dd</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span><span class="o">.</span><span class="n">year</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">mm</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">ymd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[-/\s]&quot;</span><span class="p">,</span> <span class="n">groups</span><span class="p">[</span><span class="n">ymd</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">mdy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[-/\s]&quot;</span><span class="p">,</span> <span class="n">groups</span><span class="p">[</span><span class="n">mdy</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">dmy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[-/\s]&quot;</span><span class="p">,</span> <span class="n">groups</span><span class="p">[</span><span class="n">dmy</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">d_m_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">d_m_y</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">time_only</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">M</span> <span class="o">=</span> <span class="n">S</span> <span class="o">=</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">hms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">groups</span><span class="p">[</span><span class="n">hms</span><span class="p">]:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">hms</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">H</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                <span class="n">S</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">am</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">am</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">am</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">am</span><span class="p">:</span>
            <span class="n">am</span> <span class="o">=</span> <span class="n">am</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">am</span> <span class="o">==</span> <span class="s2">&quot;AM&quot;</span> <span class="ow">and</span> <span class="n">H</span> <span class="o">==</span> <span class="mi">12</span><span class="p">:</span>
            <span class="c1"># correction for &quot;12&quot; hour functioning as &quot;0&quot; hour: 12:15 AM = 00:15 by 24 hr clock</span>
            <span class="n">H</span> <span class="o">-=</span> <span class="mi">12</span>
        <span class="k">elif</span> <span class="n">am</span> <span class="o">==</span> <span class="s2">&quot;PM&quot;</span> <span class="ow">and</span> <span class="n">H</span> <span class="o">==</span> <span class="mi">12</span><span class="p">:</span>
            <span class="c1"># no correction needed: 12PM is midday, 12:00 by 24 hour clock</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">am</span> <span class="o">==</span> <span class="s2">&quot;PM&quot;</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">+=</span> <span class="mi">12</span>

    <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">tz</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">tz</span> <span class="o">==</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">FixedTzOffset</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;UTC&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">tz</span><span class="p">:</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tz</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
            <span class="c1"># TODO use the awesome python TZ module?</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="n">tz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;:&quot;</span> <span class="ow">in</span> <span class="n">tz</span><span class="p">:</span>
                <span class="n">tzh</span><span class="p">,</span> <span class="n">tzm</span> <span class="o">=</span> <span class="n">tz</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># &#39;snnn&#39;</span>
                <span class="n">tzh</span><span class="p">,</span> <span class="n">tzm</span> <span class="o">=</span> <span class="n">tz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tz</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tzh</span><span class="p">,</span> <span class="n">tzm</span> <span class="o">=</span> <span class="n">tz</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">tz</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tzm</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">tzh</span><span class="p">)</span> <span class="o">*</span> <span class="mi">60</span>
            <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">FixedTzOffset</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">time_only</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">MONTHS_MAP</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d</span>


<span class="k">class</span> <span class="nc">TooManyFields</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">RepeatedNameError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c1"># note: {} are handled separately</span>
<span class="c1"># note: I don&#39;t use r&#39;&#39; here because Sublime Text 2 syntax highlight has a fit</span>
<span class="n">REGEX_SAFETY</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;([?</span><span class="se">\\\\</span><span class="s2">.[\]()*+\^$!\|])&quot;</span><span class="p">)</span>

<span class="c1"># allowed field types</span>
<span class="n">ALLOWED_TYPES</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s2">&quot;nbox</span><span class="si">%f</span><span class="s2">FegwWdDsS&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;t&quot;</span> <span class="o">+</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="s2">&quot;ieahgcts&quot;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">extract_format</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">extra_types</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pull apart the format [[fill]align][0][width][.precision][type]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fill</span> <span class="o">=</span> <span class="n">align</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;&lt;&gt;=^&quot;</span><span class="p">:</span>
        <span class="n">align</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">format</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;&lt;&gt;=^&quot;</span><span class="p">:</span>
        <span class="n">fill</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">align</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

    <span class="n">zero</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="ow">and</span> <span class="nb">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">width</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">while</span> <span class="nb">format</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">break</span>
        <span class="n">width</span> <span class="o">+=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">if</span> <span class="nb">format</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
        <span class="c1"># Precision isn&#39;t needed but we need to capture it so that</span>
        <span class="c1"># the ValueError isn&#39;t raised.</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># drop the &#39;.&#39;</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">while</span> <span class="nb">format</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="k">break</span>
            <span class="n">precision</span> <span class="o">+=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># the rest is the type, if present</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="nb">format</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="ow">and</span> <span class="nb">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ALLOWED_TYPES</span> <span class="ow">and</span> <span class="nb">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">extra_types</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;format spec </span><span class="si">%r</span><span class="s2"> not recognised&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">locals</span><span class="p">()</span>


<span class="n">PARSE_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;({{|}}|{\w*(?:(?:\.\w+)|(?:\[[^\]]+\]))*(?::[^}]+)?})&quot;&quot;&quot;</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">Parser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Encapsulate a format string that may be used to parse other strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">extra_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">case_sensitive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># a mapping of a name as in {hello.world} to a regex-group compatible</span>
        <span class="c1"># name, like hello__world Its used to prevent the transformation of</span>
        <span class="c1"># name-to-group and group to name to fail subtly, such as in:</span>
        <span class="c1"># hello_.world-&gt; hello___world-&gt;hello._world</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_to_name_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># also store the original field name to group name mapping to allow</span>
        <span class="c1"># multiple instances of a name in the format string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name_to_group_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># and to sanity check the repeated instances store away the first</span>
        <span class="c1"># field type specification for the named field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name_types</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_format</span> <span class="o">=</span> <span class="nb">format</span>
        <span class="k">if</span> <span class="n">extra_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extra_types</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extra_types</span> <span class="o">=</span> <span class="n">extra_types</span>
        <span class="k">if</span> <span class="n">case_sensitive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_re_flags</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_re_flags</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_named_fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_expression</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__search_re</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__match_re</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;format </span><span class="si">%r</span><span class="s2"> -&gt; </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expression</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_format</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_format</span><span class="p">[:</span><span class="mi">17</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;...&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_search_re</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__search_re</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__search_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_expression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_flags</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="c1"># access error through sys to keep py3k and backward compat</span>
                <span class="n">e</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;this version only supports 100 named groups&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">TooManyFields</span><span class="p">(</span>
                        <span class="s2">&quot;sorry, you are attempting to parse &quot;</span>
                        <span class="s2">&quot;too many complex fields&quot;</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__search_re</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_match_re</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__match_re</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="s2">&quot;^</span><span class="si">%s</span><span class="s2">$&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expression</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__match_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_flags</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="c1"># access error through sys to keep py3k and backward compat</span>
                <span class="n">e</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;this version only supports 100 named groups&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">TooManyFields</span><span class="p">(</span>
                        <span class="s2">&quot;sorry, you are attempting to parse &quot;</span>
                        <span class="s2">&quot;too many complex fields&quot;</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="n">re</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Group names (e.g. (?P&lt;name&gt;) can &quot;</span>
                    <span class="s2">&quot;cause failure, as they are not escaped properly: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span>
                    <span class="o">%</span> <span class="n">expression</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__match_re</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">evaluate_result</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Match my format to the string exactly.</span>

<span class="sd">        Return a Result or Match instance or None if there&#39;s no match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">evaluate_result</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_result</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">endpos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">evaluate_result</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Search the string for my format.</span>

<span class="sd">        Optionally start the search at &quot;pos&quot; character index and limit the</span>
<span class="sd">        search to a maximum index of endpos - equivalent to</span>
<span class="sd">        search(string[:endpos]).</span>

<span class="sd">        If the ``evaluate_result`` argument is set to ``False`` a</span>
<span class="sd">        Match instance is returned instead of the actual Result instance.</span>

<span class="sd">        Return either a Result instance or None if there&#39;s no match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">endpos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endpos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">endpos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">evaluate_result</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_result</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">findall</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">string</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">endpos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">extra_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">evaluate_result</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Search &quot;string&quot; for all occurrences of &quot;format&quot;.</span>

<span class="sd">        Optionally start the search at &quot;pos&quot; character index and limit the</span>
<span class="sd">        search to a maximum index of endpos - equivalent to</span>
<span class="sd">        search(string[:endpos]).</span>

<span class="sd">        Returns an iterator that holds Result or Match instances for each format match</span>
<span class="sd">        found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">endpos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endpos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ResultIterator</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">endpos</span><span class="p">,</span> <span class="n">evaluate_result</span><span class="o">=</span><span class="n">evaluate_result</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand_named_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_fields</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">named_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># split &#39;aaa[bbb][ccc]...&#39; into &#39;aaa&#39; and &#39;[bbb][ccc]...&#39;</span>
            <span class="n">basename</span><span class="p">,</span> <span class="n">subkeys</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;([^\[]+)(.*)&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>

            <span class="c1"># create nested dictionaries {&#39;aaa&#39;: {&#39;bbb&#39;: {&#39;ccc&#39;: ...}}}</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">result</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">basename</span>

            <span class="k">if</span> <span class="n">subkeys</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">subkey</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\[[^\]]+\]&quot;</span><span class="p">,</span> <span class="n">subkeys</span><span class="p">):</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">{})</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">subkey</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># assign the value to the last key</span>
            <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">evaluate_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a Result instance for the given regex match object&quot;&quot;&quot;</span>
        <span class="c1"># ok, figure the fixed fields we&#39;ve pulled out and type convert them</span>
        <span class="n">fixed_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">:</span>
                <span class="n">fixed_fields</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">n</span><span class="p">](</span><span class="n">fixed_fields</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">fixed_fields</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fixed_fields</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_fields</span><span class="p">)</span>

        <span class="c1"># grab the named fields, converting where requested</span>
        <span class="n">groupdict</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
        <span class="n">named_fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">name_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_named_fields</span><span class="p">:</span>
            <span class="n">korig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_to_name_map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">name_map</span><span class="p">[</span><span class="n">korig</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">groupdict</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">groupdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="n">named_fields</span><span class="p">[</span><span class="n">korig</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># now figure the match spans</span>
        <span class="n">spans</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="n">name_map</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">named_fields</span><span class="p">)</span>
        <span class="n">spans</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_fields</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># and that&#39;s our result</span>
        <span class="k">return</span> <span class="n">Result</span><span class="p">(</span>
            <span class="n">fixed_fields</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_named_fields</span><span class="p">(</span><span class="n">named_fields</span><span class="p">),</span> <span class="n">spans</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_regex_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># turn my _format attribute into the _expression attribute</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">PARSE_RE</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_format</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">part</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">part</span> <span class="o">==</span> <span class="s2">&quot;{{&quot;</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\{&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">part</span> <span class="o">==</span> <span class="s2">&quot;}}&quot;</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\}&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;{&quot;</span><span class="p">:</span>
                <span class="c1"># this will be a braces-delimited field to handle</span>
                <span class="n">e</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle_field</span><span class="p">(</span><span class="n">part</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># just some text to match</span>
                <span class="n">e</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">REGEX_SAFETY</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_regex_replace</span><span class="p">,</span> <span class="n">part</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_group_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1"># return a version of field which can be used as capture group, even</span>
        <span class="c1"># though it might contain &#39;.&#39;</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>

        <span class="c1"># make sure we don&#39;t collide (&quot;a.b&quot; colliding with &quot;a_b&quot;)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_to_name_map</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;_&quot;</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;duplicated group name </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">field</span><span class="p">,))</span>

        <span class="c1"># save off the mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_to_name_map</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name_to_group_map</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
        <span class="k">return</span> <span class="n">group</span>

    <span class="k">def</span> <span class="nf">_handle_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1"># first: lose the braces</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># now figure whether this is an anonymous or named field, and whether</span>
        <span class="c1"># there&#39;s any format specification</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">and</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;:&quot;</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
                <span class="n">name</span><span class="p">,</span> <span class="nb">format</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_to_group_map</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">format</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">RepeatedNameError</span><span class="p">(</span>
                        <span class="s1">&#39;field type </span><span class="si">%r</span><span class="s1"> for field &quot;</span><span class="si">%s</span><span class="s1">&quot; &#39;</span>
                        <span class="s2">&quot;does not match previous seen type </span><span class="si">%r</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_types</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                    <span class="p">)</span>
                <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_to_group_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="c1"># match previously-seen value</span>
                <span class="k">return</span> <span class="s2">&quot;(?P=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">group</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_group_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_name_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">format</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_named_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="c1"># this will become a group, which must not contain dots</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="s2">&quot;(?P&lt;</span><span class="si">%s</span><span class="s2">&gt;</span><span class="si">%%</span><span class="s2">s)&quot;</span> <span class="o">%</span> <span class="n">group</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span><span class="p">)</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)&quot;</span>
            <span class="k">if</span> <span class="s2">&quot;:&quot;</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
                <span class="nb">format</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span>

        <span class="c1"># simplest case: no type specifier ({} or {name})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">format</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">wrap</span> <span class="o">%</span> <span class="s2">&quot;.+?&quot;</span>

        <span class="c1"># decode the format specification</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="n">extract_format</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_types</span><span class="p">)</span>

        <span class="c1"># figure type conversions, if any</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
        <span class="n">is_numeric</span> <span class="o">=</span> <span class="nb">type</span> <span class="ow">and</span> <span class="nb">type</span> <span class="ow">in</span> <span class="s2">&quot;n</span><span class="si">%f</span><span class="s2">egdobh&quot;</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_types</span><span class="p">:</span>
            <span class="n">type_converter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_types</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">type_converter</span><span class="p">,</span> <span class="s2">&quot;pattern&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;.+?&quot;</span><span class="p">)</span>
            <span class="n">regex_group_count</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">type_converter</span><span class="p">,</span> <span class="s2">&quot;regex_group_count&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">regex_group_count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">regex_group_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="n">regex_group_count</span>

            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">type_converter</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;\d{1,3}([,.]\d</span><span class="si">{3}</span><span class="s2">)*&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">int_convert</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;(0[bB])?[01]+&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">int_convert</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;o&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;(0[oO])?[0-7]+&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">int_convert</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;(0[xX])?[0-9a-fA-F]+&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">int_convert</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;%&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\d+(\.\d+)?%&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">percentage</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\d+\.\d+&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\d+\.\d+&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\d+\.\d+[eE][-+]?\d+|nan|NAN|[-+]?inf|[-+]?INF&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\d+(\.\d+)?([eE][-+]?\d+)?|nan|NAN|[-+]?inf|[-+]?INF&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">format</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">):</span>
                <span class="n">width</span> <span class="o">=</span> <span class="s2">&quot;{1,</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="nb">format</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">d</span><span class="si">{w}</span><span class="s2">|0[xX][0-9a-fA-F]</span><span class="si">{w}</span><span class="s2">|0[bB][01]</span><span class="si">{w}</span><span class="s2">|0[oO][0-7]</span><span class="si">{w}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">w</span><span class="o">=</span><span class="n">width</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">int_convert</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;ti&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">r</span><span class="s2">&quot;(\d</span><span class="si">{4}</span><span class="s2">-\d\d-\d\d)((\s+|T)</span><span class="si">%s</span><span class="s2">)?(Z|\s*[-+]\d\d:?\d\d)?&quot;</span>
                    <span class="o">%</span> <span class="n">TIME_PAT</span>
            <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">date_convert</span><span class="p">,</span> <span class="n">ymd</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hms</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">7</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">7</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;tg&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(\d{1,2}[-/](\d{1,2}|</span><span class="si">%s</span><span class="s2">)[-/]\d</span><span class="si">{4}</span><span class="s2">)(\s+</span><span class="si">%s</span><span class="s2">)?</span><span class="si">%s</span><span class="s2">?</span><span class="si">%s</span><span class="s2">?&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">ALL_MONTHS_PAT</span><span class="p">,</span>
                <span class="n">TIME_PAT</span><span class="p">,</span>
                <span class="n">AM_PAT</span><span class="p">,</span>
                <span class="n">TZ_PAT</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">date_convert</span><span class="p">,</span> <span class="n">dmy</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hms</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">am</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">9</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">9</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;ta&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;((\d{1,2}|</span><span class="si">%s</span><span class="s2">)[-/]\d{1,2}[-/]\d</span><span class="si">{4}</span><span class="s2">)(\s+</span><span class="si">%s</span><span class="s2">)?</span><span class="si">%s</span><span class="s2">?</span><span class="si">%s</span><span class="s2">?&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">ALL_MONTHS_PAT</span><span class="p">,</span>
                <span class="n">TIME_PAT</span><span class="p">,</span>
                <span class="n">AM_PAT</span><span class="p">,</span>
                <span class="n">TZ_PAT</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">date_convert</span><span class="p">,</span> <span class="n">mdy</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hms</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">am</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">9</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">9</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;te&quot;</span><span class="p">:</span>
            <span class="c1"># this will allow microseconds through if they&#39;re present, but meh</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">,\s+)?(\d{1,2}\s+</span><span class="si">%s</span><span class="s2">\s+\d</span><span class="si">{4}</span><span class="s2">)\s+</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">DAYS_PAT</span><span class="p">,</span>
                <span class="n">MONTHS_PAT</span><span class="p">,</span>
                <span class="n">TIME_PAT</span><span class="p">,</span>
                <span class="n">TZ_PAT</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">date_convert</span><span class="p">,</span> <span class="n">dmy</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">hms</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">8</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">8</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;th&quot;</span><span class="p">:</span>
            <span class="c1"># slight flexibility here from the stock Apache format</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(\d{1,2}[-/]</span><span class="si">%s</span><span class="s2">[-/]\d</span><span class="si">{4}</span><span class="s2">):</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">MONTHS_PAT</span><span class="p">,</span>
                <span class="n">TIME_PAT</span><span class="p">,</span>
                <span class="n">TZ_PAT</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">date_convert</span><span class="p">,</span> <span class="n">dmy</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hms</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">6</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">6</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;tc&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)\s+</span><span class="si">%s</span><span class="s2">\s+(\d{1,2})\s+</span><span class="si">%s</span><span class="s2">\s+(\d</span><span class="si">{4}</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">DAYS_PAT</span><span class="p">,</span>
                <span class="n">MONTHS_PAT</span><span class="p">,</span>
                <span class="n">TIME_PAT</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">date_convert</span><span class="p">,</span> <span class="n">d_m_y</span><span class="o">=</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">hms</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">5</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">8</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;tt&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">?</span><span class="si">%s</span><span class="s2">?</span><span class="si">%s</span><span class="s2">?&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">TIME_PAT</span><span class="p">,</span> <span class="n">AM_PAT</span><span class="p">,</span> <span class="n">TZ_PAT</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">date_convert</span><span class="p">,</span> <span class="n">hms</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">am</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">5</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">5</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;ts&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(\s+)(\d+)(\s+)(\d{1,2}:\d{1,2}:\d{1,2})?&quot;</span> <span class="o">%</span> <span class="n">MONTHS_PAT</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_conversions</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">date_convert</span><span class="p">,</span> <span class="n">mm</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dd</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">hms</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="mi">5</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">5</span>

        <span class="k">elif</span> <span class="nb">type</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\</span><span class="si">%s</span><span class="s2">+&quot;</span> <span class="o">%</span> <span class="nb">type</span>
        <span class="k">elif</span> <span class="nb">format</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;precision&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">format</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;.{</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">}?&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">format</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">],</span> <span class="nb">format</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;.{1,</span><span class="si">%s</span><span class="s2">}?&quot;</span> <span class="o">%</span> <span class="nb">format</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">format</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;.{</span><span class="si">%s</span><span class="s2">,}?&quot;</span> <span class="o">%</span> <span class="nb">format</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;.+?&quot;</span>

        <span class="n">align</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="s2">&quot;align&quot;</span><span class="p">]</span>
        <span class="n">fill</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="s2">&quot;fill&quot;</span><span class="p">]</span>

        <span class="c1"># handle some numeric-specific things like fill and sign</span>
        <span class="k">if</span> <span class="n">is_numeric</span><span class="p">:</span>
            <span class="c1"># prefix with something (align &quot;=&quot; trumps zero)</span>
            <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s2">&quot;=&quot;</span><span class="p">:</span>
                <span class="c1"># special case - align &quot;=&quot; acts like the zero above but with</span>
                <span class="c1"># configurable fill defaulting to &quot;0&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">fill</span><span class="p">:</span>
                    <span class="n">fill</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">*&quot;</span> <span class="o">%</span> <span class="n">fill</span> <span class="o">+</span> <span class="n">s</span>

            <span class="c1"># allow numbers to be prefixed with a sign</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[-+ ]?&quot;</span> <span class="o">+</span> <span class="n">s</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fill</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>

        <span class="c1"># Place into a group now - this captures the value we want to keep.</span>
        <span class="c1"># Everything else from now is just padding to be stripped off</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">wrap</span> <span class="o">%</span> <span class="n">s</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">format</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]:</span>
            <span class="c1"># all we really care about is that if the format originally</span>
            <span class="c1"># specified a width then there will probably be padding - without</span>
            <span class="c1"># an explicit alignment that&#39;ll mean right alignment with spaces</span>
            <span class="c1"># padding</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">align</span><span class="p">:</span>
                <span class="n">align</span> <span class="o">=</span> <span class="s2">&quot;&gt;&quot;</span>

        <span class="k">if</span> <span class="n">fill</span> <span class="ow">in</span> <span class="s2">&quot;.\+?*[]()</span><span class="si">{}</span><span class="s2">^$&quot;</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">fill</span>

        <span class="c1"># align &quot;=&quot; has been handled</span>
        <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">*&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fill</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">*</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fill</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s2">&quot;^&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">*</span><span class="si">%s%s</span><span class="s2">*&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fill</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fill</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span>


<span class="k">class</span> <span class="nc">Result</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The result of a parse() or search().</span>

<span class="sd">    Fixed results may be looked up using result[index]. Named results may be</span>
<span class="sd">    looked up using result[&#39;name&#39;].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed</span><span class="p">,</span> <span class="n">named</span><span class="p">,</span> <span class="n">spans</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="n">fixed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">named</span> <span class="o">=</span> <span class="n">named</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spans</span> <span class="o">=</span> <span class="n">spans</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">named</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">named</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Match</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The result of a parse() or search() if no results are generated.</span>

<span class="sd">    This class is only used to expose internal used regex match objects</span>
<span class="sd">    to the user and use them for external Parser.evaluate_result calls.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">parser</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">match</span>

    <span class="k">def</span> <span class="nf">evaluate_result</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate results for this Match&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">evaluate_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ResultIterator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The result of a findall() operation.</span>

<span class="sd">    Each element is a Result instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">endpos</span><span class="p">,</span> <span class="n">evaluate_result</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">parser</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpos</span> <span class="o">=</span> <span class="n">endpos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_result</span> <span class="o">=</span> <span class="n">evaluate_result</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">_search_re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_result</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">evaluate_result</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="c1"># pre-py3k compat</span>
    <span class="nb">next</span> <span class="o">=</span> <span class="fm">__next__</span>


<div class="viewcode-block" id="parse"><a class="viewcode-back" href="../../test.html#py2store.parse_format.parse">[docs]</a><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span>
        <span class="nb">format</span><span class="p">,</span>
        <span class="n">string</span><span class="p">,</span>
        <span class="n">extra_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">evaluate_result</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">case_sensitive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Using &quot;format&quot; attempt to pull values from &quot;string&quot;.</span>

<span class="sd">    The format must match the string contents exactly. If the value</span>
<span class="sd">    you&#39;re looking for is instead just a part of the string use</span>
<span class="sd">    search().</span>

<span class="sd">    If ``evaluate_result`` is True the return value will be an Result instance with two attributes:</span>

<span class="sd">     .fixed - tuple of fixed-position values from the string</span>
<span class="sd">     .named - dict of named values from the string</span>

<span class="sd">    If ``evaluate_result`` is False the return value will be a Match instance with one method:</span>

<span class="sd">     .evaluate_result() - This will return a Result instance like you would get</span>
<span class="sd">                          with ``evaluate_result`` set to True</span>

<span class="sd">    The default behaviour is to match strings case insensitively. You may match with</span>
<span class="sd">    case by specifying case_sensitive=True.</span>

<span class="sd">    If the format is invalid a ValueError will be raised.</span>

<span class="sd">    See the module documentation for the use of &quot;extra_types&quot;.</span>

<span class="sd">    In the case there is no match parse() will return None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">extra_types</span><span class="o">=</span><span class="n">extra_types</span><span class="p">,</span> <span class="n">case_sensitive</span><span class="o">=</span><span class="n">case_sensitive</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">evaluate_result</span><span class="o">=</span><span class="n">evaluate_result</span><span class="p">)</span></div>


<div class="viewcode-block" id="search"><a class="viewcode-back" href="../../test.html#py2store.parse_format.search">[docs]</a><span class="k">def</span> <span class="nf">search</span><span class="p">(</span>
        <span class="nb">format</span><span class="p">,</span>
        <span class="n">string</span><span class="p">,</span>
        <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">endpos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">evaluate_result</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">case_sensitive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search &quot;string&quot; for the first occurrence of &quot;format&quot;.</span>

<span class="sd">    The format may occur anywhere within the string. If</span>
<span class="sd">    instead you wish for the format to exactly match the string</span>
<span class="sd">    use parse().</span>

<span class="sd">    Optionally start the search at &quot;pos&quot; character index and limit the search</span>
<span class="sd">    to a maximum index of endpos - equivalent to search(string[:endpos]).</span>

<span class="sd">    If ``evaluate_result`` is True the return value will be an Result instance with two attributes:</span>

<span class="sd">     .fixed - tuple of fixed-position values from the string</span>
<span class="sd">     .named - dict of named values from the string</span>

<span class="sd">    If ``evaluate_result`` is False the return value will be a Match instance with one method:</span>

<span class="sd">     .evaluate_result() - This will return a Result instance like you would get</span>
<span class="sd">                          with ``evaluate_result`` set to True</span>

<span class="sd">    The default behaviour is to match strings case insensitively. You may match with</span>
<span class="sd">    case by specifying case_sensitive=True.</span>

<span class="sd">    If the format is invalid a ValueError will be raised.</span>

<span class="sd">    See the module documentation for the use of &quot;extra_types&quot;.</span>

<span class="sd">    In the case there is no match parse() will return None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">extra_types</span><span class="o">=</span><span class="n">extra_types</span><span class="p">,</span> <span class="n">case_sensitive</span><span class="o">=</span><span class="n">case_sensitive</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">endpos</span><span class="p">,</span> <span class="n">evaluate_result</span><span class="o">=</span><span class="n">evaluate_result</span><span class="p">)</span></div>


<div class="viewcode-block" id="findall"><a class="viewcode-back" href="../../test.html#py2store.parse_format.findall">[docs]</a><span class="k">def</span> <span class="nf">findall</span><span class="p">(</span>
        <span class="nb">format</span><span class="p">,</span>
        <span class="n">string</span><span class="p">,</span>
        <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">endpos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">evaluate_result</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">case_sensitive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search &quot;string&quot; for all occurrences of &quot;format&quot;.</span>

<span class="sd">    You will be returned an iterator that holds Result instances</span>
<span class="sd">    for each format match found.</span>

<span class="sd">    Optionally start the search at &quot;pos&quot; character index and limit the search</span>
<span class="sd">    to a maximum index of endpos - equivalent to search(string[:endpos]).</span>

<span class="sd">    If ``evaluate_result`` is True each returned Result instance has two attributes:</span>

<span class="sd">     .fixed - tuple of fixed-position values from the string</span>
<span class="sd">     .named - dict of named values from the string</span>

<span class="sd">    If ``evaluate_result`` is False each returned value is a Match instance with one method:</span>

<span class="sd">     .evaluate_result() - This will return a Result instance like you would get</span>
<span class="sd">                          with ``evaluate_result`` set to True</span>

<span class="sd">    The default behaviour is to match strings case insensitively. You may match with</span>
<span class="sd">    case by specifying case_sensitive=True.</span>

<span class="sd">    If the format is invalid a ValueError will be raised.</span>

<span class="sd">    See the module documentation for the use of &quot;extra_types&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">extra_types</span><span class="o">=</span><span class="n">extra_types</span><span class="p">,</span> <span class="n">case_sensitive</span><span class="o">=</span><span class="n">case_sensitive</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Parser</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">extra_types</span><span class="o">=</span><span class="n">extra_types</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span>
        <span class="n">string</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">endpos</span><span class="p">,</span> <span class="n">evaluate_result</span><span class="o">=</span><span class="n">evaluate_result</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">extra_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">case_sensitive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a Parser instance to parse &quot;format&quot;.</span>

<span class="sd">    The resultant Parser has a method .parse(string) which</span>
<span class="sd">    behaves in the same manner as parse(format, string).</span>

<span class="sd">    The default behaviour is to match strings case insensitively. You may match with</span>
<span class="sd">    case by specifying case_sensitive=True.</span>

<span class="sd">    Use this function if you intend to parse many strings</span>
<span class="sd">    with the same format.</span>

<span class="sd">    See the module documentation for the use of &quot;extra_types&quot;.</span>

<span class="sd">    Returns a Parser instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Parser</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">extra_types</span><span class="o">=</span><span class="n">extra_types</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">match_re_for_fstring</span><span class="p">(</span><span class="n">fstring</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">compile</span><span class="p">(</span><span class="n">fstring</span><span class="p">)</span><span class="o">.</span><span class="n">_match_re</span>


<span class="k">def</span> <span class="nf">search_re_for_fstring</span><span class="p">(</span><span class="n">fstring</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">compile</span><span class="p">(</span><span class="n">fstring</span><span class="p">)</span><span class="o">.</span><span class="n">_search_re</span>

<span class="c1"># Modified from https://github.com/r1chardj0n3s/parse</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2012-2013 Richard Jones &lt;richard@python.org&gt;</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1"># in the Software without restriction, including without limitation the rights</span>
<span class="c1"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1"># furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1">#  The above copyright notice and this permission notice shall be included in</span>
<span class="c1">#  all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="c1"># SOFTWARE.</span>

<span class="c1"># vim: set filetype=python ts=4 sw=4 et si tw=75</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">py2store</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../test.html">py2store.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.misc">py2store.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.mixins">py2store.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.test.util">py2store.test.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-test-quick">py2store.test.quick</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.test">py2store.test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-test-simple">py2store.test.simple</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-test-scrap">py2store.test.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.util">py2store.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-ext-docx">py2store.ext.docx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.ext.gitlab">py2store.ext.gitlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-ext-hdf">py2store.ext.hdf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.ext">py2store.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-ext-matlab">py2store.ext.matlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.ext.kaggle">py2store.ext.kaggle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-ext-module-imports">py2store.ext.module_imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.ext.audio">py2store.ext.audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-ext-github">py2store.ext.github</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.ext.dataframes">py2store.ext.dataframes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.access">py2store.access</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.__init__">py2store.__init__</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores.s3_store">py2store.stores.s3_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores.delegation_stores">py2store.stores.delegation_stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores.sql_w_sqlalchemy">py2store.stores.sql_w_sqlalchemy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-stores-arangodb-store">py2store.stores.arangodb_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-stores-dropbox-store">py2store.stores.dropbox_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores.local_store">py2store.stores.local_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores">py2store.stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-stores-couchdb-store">py2store.stores.couchdb_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.stores.mongo_store">py2store.stores.mongo_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.core">py2store.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.uri_utils">py2store.utils.uri_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.explicit">py2store.utils.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.timeseries_caching">py2store.utils.timeseries_caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-utils-attr-dict-py-attr-dict">py2store.utils.attr_dict.py.attr_dict</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-utils-attr-dict-py">py2store.utils.attr_dict.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.cumul_aggreg_write">py2store.utils.cumul_aggreg_write</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils">py2store.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.cache_descriptors">py2store.utils.cache_descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.appendable">py2store.utils.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.affine_conversion">py2store.utils.affine_conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.signatures">py2store.utils.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.sliceable">py2store.utils.sliceable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.mappify">py2store.utils.mappify</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.utils.glom">py2store.utils.glom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-sql-w-odbc">py2store.persisters.sql_w_odbc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.dynamodb_w_boto3">py2store.persisters.dynamodb_w_boto3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-couchdb-w-couchdb">py2store.persisters.couchdb_w_couchdb</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.ftp_persister">py2store.persisters.ftp_persister</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.dropbox_w_urllib">py2store.persisters.dropbox_w_urllib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters._google_drive_in_progress">py2store.persisters._google_drive_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-dropbox-w-dropbox">py2store.persisters.dropbox_w_dropbox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-redis-w-redis">py2store.persisters.redis_w_redis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.sql_w_sqlalchemy">py2store.persisters.sql_w_sqlalchemy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.new_s3">py2store.persisters.new_s3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters">py2store.persisters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.dropbox_w_requests">py2store.persisters.dropbox_w_requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.w_aiofile">py2store.persisters.w_aiofile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.local_files">py2store.persisters.local_files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-arangodb-w-pyarango">py2store.persisters.arangodb_w_pyarango</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters._cassandra_in_progress">py2store.persisters._cassandra_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters._couchdb_in_progress">py2store.persisters._couchdb_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.s3_w_boto3">py2store.persisters.s3_w_boto3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-postgres-w-psycopg2-in-progress">py2store.persisters._postgres_w_psycopg2_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-ssh-persister">py2store.persisters.ssh_persister</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.persisters.mongo_w_pymongo">py2store.persisters.mongo_w_pymongo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-persisters-googledrive-w-pydrive">py2store.persisters.googledrive_w_pydrive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.sources">py2store.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.dig">py2store.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers.pickled">py2store.serializers.pickled</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers.jsonization">py2store.serializers.jsonization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers">py2store.serializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers.sequential">py2store.serializers.sequential</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers.regular_panel_data">py2store.serializers.regular_panel_data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.serializers.audio">py2store.serializers.audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.caching">py2store.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.scrap">py2store.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.scrap.new_gen_local">py2store.scrap.new_gen_local</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.examples.write_caches">py2store.examples.write_caches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.examples">py2store.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.examples.python_code_stats">py2store.examples.python_code_stats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.examples.kv_walking">py2store.examples.kv_walking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.my">py2store.my</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.my.grabbers">py2store.my.grabbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.trans">py2store.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.key_mappers.str_utils">py2store.key_mappers.str_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.key_mappers.tuples">py2store.key_mappers.tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.key_mappers.paths">py2store.key_mappers.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.key_mappers.naming">py2store.key_mappers.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.key_mappers">py2store.key_mappers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.errors">py2store.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.slib.s_configparser">py2store.slib.s_configparser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.slib">py2store.slib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.slib.s_zipfile">py2store.slib.s_zipfile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.base">py2store.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-selectors-mg-selectors">py2store.selectors.mg_selectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-selectors-mongoquery">py2store.selectors.mongoquery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#py2store-selectors">py2store.selectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test.html#module-py2store.parse_format">py2store.parse_format</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../py2store.html">py2store</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>