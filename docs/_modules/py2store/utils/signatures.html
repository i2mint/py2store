
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>py2store.utils.signatures &#8212; py2store 0.0.7 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for py2store.utils.signatures</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Mapping</span> <span class="k">as</span> <span class="n">MappingType</span>

<span class="n">_empty</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">_empty</span>

<span class="n">_ParameterKind</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;param_kind&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">))</span>
<span class="n">ParamsType</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Parameter</span><span class="p">]</span>
<span class="n">ParamsAble</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParamsType</span><span class="p">,</span> <span class="n">MappingType</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">],</span> <span class="n">Callable</span><span class="p">]</span>
<span class="n">SignatureAble</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Signature</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">ParamsType</span><span class="p">,</span> <span class="n">MappingType</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]]</span>
<span class="n">HasParams</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Parameter</span><span class="p">],</span> <span class="n">MappingType</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">],</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span>

<span class="c1"># short hands for Parameter kinds</span>
<span class="n">PK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
<span class="n">VP</span><span class="p">,</span> <span class="n">VK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>
<span class="n">PO</span><span class="p">,</span> <span class="n">KO</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
<span class="n">var_param_kinds</span> <span class="o">=</span> <span class="p">{</span><span class="n">VP</span><span class="p">,</span> <span class="n">VK</span><span class="p">}</span>
<span class="n">var_param_types</span> <span class="o">=</span> <span class="n">var_param_kinds</span>  <span class="c1"># Deprecate: for back-compatibility. Delete in 2021</span>


<span class="c1"># TODO: Couldn&#39;t make this work. See https://www.python.org/dev/peps/pep-0562/</span>
<span class="c1"># deprecated_names = {&#39;assure_callable&#39;, &#39;assure_signature&#39;, &#39;assure_params&#39;}</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def __getattr__(name):</span>
<span class="c1">#     print(name)</span>
<span class="c1">#     if name in deprecated_names:</span>
<span class="c1">#         from warnings import warn</span>
<span class="c1">#         warn(f&quot;{name} is deprecated (see code for new name -- look for aliases)&quot;, DeprecationWarning)</span>
<span class="c1">#     raise AttributeError(f&quot;module {__name__} has no attribute {name}&quot;)</span>


<span class="k">def</span> <span class="nf">ensure_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">SignatureAble</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Empty function made just to carry a signature&quot;&quot;&quot;</span>

        <span class="n">f</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">ensure_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span>


<span class="n">assure_callable</span> <span class="o">=</span> <span class="n">ensure_callable</span>  <span class="c1"># alias for backcompatibility</span>


<span class="k">def</span> <span class="nf">ensure_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">SignatureAble</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make that object into a Signature: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="p">())</span>
    <span class="c1"># if you get this far...</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make that object into a Signature: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="n">assure_signature</span> <span class="o">=</span> <span class="n">ensure_signature</span>  <span class="c1"># alias for backcompatibility</span>


<span class="k">def</span> <span class="nf">ensure_param</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Parameter</span><span class="p">(</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">dflt_and_annotation</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;annotation&#39;</span><span class="p">],</span> <span class="n">r</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">PK</span><span class="p">,</span> <span class="o">**</span><span class="n">dflt_and_annotation</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2"> into a Parameter object&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="ensure_params"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.ensure_params">[docs]</a><span class="k">def</span> <span class="nf">ensure_params</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">ParamsAble</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get an interable of Parameter instances from an object.</span>

<span class="sd">    :param obj:</span>
<span class="sd">    :return:</span>

<span class="sd">    From a callable:</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1): ...</span>
<span class="sd">    &gt;&gt;&gt; ensure_params(f)</span>
<span class="sd">    [&lt;Parameter &quot;w&quot;&gt;, &lt;Parameter &quot;x: float = 1&quot;&gt;, &lt;Parameter &quot;y=1&quot;&gt;, &lt;Parameter &quot;z: int = 1&quot;&gt;]</span>

<span class="sd">    From an iterable of strings, dicts, or tuples</span>

<span class="sd">    &gt;&gt;&gt; ensure_params([&#39;xyz&#39;,</span>
<span class="sd">    ...     (&#39;b&#39;, Parameter.empty, int), # if you want an annotation without a default use Parameter.empty</span>
<span class="sd">    ...     (&#39;c&#39;, 2),  # if you just want a default, make it the second element of your tuple</span>
<span class="sd">    ...     dict(name=&#39;d&#39;, kind=Parameter.VAR_KEYWORD)])  # all kinds are by default PK: Use dict to specify otherwise.</span>
<span class="sd">    [&lt;Parameter &quot;xyz&quot;&gt;, &lt;Parameter &quot;b: int&quot;&gt;, &lt;Parameter &quot;c=2&quot;&gt;, &lt;Parameter &quot;**d&quot;&gt;]</span>


<span class="sd">    If no input is given, an empty list is returned.</span>

<span class="sd">    &gt;&gt;&gt; ensure_params()  # equivalent to ensure_params(None)</span>
<span class="sd">    []</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">ensure_param</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">([</span><span class="n">obj</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Signature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="c1"># if function didn&#39;t return at this point, it didn&#39;t find a match, so raise</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make that object into an iterable of inspect.Parameter objects: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<span class="n">assure_params</span> <span class="o">=</span> <span class="n">ensure_params</span>  <span class="c1"># alias for backcompatibility</span>


<div class="viewcode-block" id="MissingArgValFor"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.MissingArgValFor">[docs]</a><span class="k">class</span> <span class="nc">MissingArgValFor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A simple class to wrap an argument name, indicating that it was missing somewhere.</span>
<span class="sd">    &gt;&gt;&gt; MissingArgValFor(&#39;argname&#39;)</span>
<span class="sd">    MissingArgValFor(&quot;argname&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">argname</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argname</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argname</span> <span class="o">=</span> <span class="n">argname</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;MissingArgValFor(&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">argname</span><span class="si">}</span><span class="s1">&quot;)&#39;</span></div>


<span class="c1"># TODO: Look into the handling of the Parameter.VAR_KEYWORD kind in params</span>
<div class="viewcode-block" id="extract_arguments"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.extract_arguments">[docs]</a><span class="k">def</span> <span class="nf">extract_arguments</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">,</span>
                      <span class="o">*</span><span class="p">,</span>
                      <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;return&#39;</span><span class="p">,</span>
                      <span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">assert_no_missing_position_only_args</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span>
                      <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract arguments needed to satisfy the params of a callable, dealing with the dirty details.</span>

<span class="sd">    Returns an (param_args, param_kwargs, remaining_kwargs) tuple where</span>
<span class="sd">    - param_args are the values of kwargs that are PO (POSITION_ONLY) as defined by params,</span>
<span class="sd">    - param_kwargs are those names that are both in params and not in param_args, and</span>
<span class="sd">    - remaining_kwargs are the remaining.</span>

<span class="sd">    Intended usage: When you need to call a function `func` that has some position-only arguments,</span>
<span class="sd">    but you have a kwargs dict of arguments in your hand. You can&#39;t just to `func(**kwargs)`.</span>
<span class="sd">    But you can (now) do</span>
<span class="sd">    ```</span>
<span class="sd">    args, kwargs, remaining = extract_arguments(kwargs, func)  # extract from kwargs what you need for func</span>
<span class="sd">    # ... check if remaing is empty (or not, depending on your paranoia), and then call the func:</span>
<span class="sd">    func(*args, **kwargs)</span>
<span class="sd">    ```</span>
<span class="sd">    (And if you doing that a lot: Do put it in a decorator!)</span>

<span class="sd">    See Also: extract_arguments.without_remainding</span>

<span class="sd">    The most frequent case you&#39;ll encounter is when there&#39;s no POSITION_ONLY args, your param_args will be empty</span>
<span class="sd">    and you param_kwargs will contain all the arguments that match params, in the order of these params.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, d=0): ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;)</span>
<span class="sd">    ((), {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    But sometimes you do have POSITION_ONLY arguments.</span>
<span class="sd">    What extract_arguments will do for you is return the value of these as the first element of</span>
<span class="sd">    the triple.</span>
<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0): ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;)</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    Note above how we get `(1, 2, 3)`, the order defined by the func&#39;s signature,</span>
<span class="sd">    instead of `(2, 1, 3)`, the order defined by the kwargs.</span>
<span class="sd">    So it&#39;s the params (e.g. function signature) that determine the order, not kwargs.</span>
<span class="sd">    When using to call a function, this is especially crucial if we use POSITION_ONLY arguments.</span>

<span class="sd">    See also that the third output, the remaining_kwargs, as `{&#39;extra&#39;: &#39;stuff&#39;}` since</span>
<span class="sd">    it was not in the params of the function.</span>
<span class="sd">    Even if you include a VAR_KEYWORD kind of argument in the function, it won&#39;t change</span>
<span class="sd">    this behavior.</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0, **kws): ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;)</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    This is because we don&#39;t want to assume that all the kwargs can actually be</span>
<span class="sd">    included in a call to the function behind the params.</span>
<span class="sd">    Instead, the user can chose whether to include the remainder by doing a:</span>
<span class="sd">    ```</span>
<span class="sd">    param_kwargs.update(remaining_kwargs)</span>
<span class="sd">    ```</span>
<span class="sd">    et voil√†.</span>

<span class="sd">    That said, we do understand that it may be a common pattern, so we&#39;ll do that extra step for you</span>
<span class="sd">    if you specify `include_all_when_var_keywords_in_params=True`.</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0, **kws): ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;,</span>
<span class="sd">    ...                     include_all_when_var_keywords_in_params=True)</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;}, {})</span>

<span class="sd">    If you&#39;re expecting no remainder you might want to just get the args and kwargs (not this third</span>
<span class="sd">    expected-to-be-empty remainder). You have two ways to do that, specifying:</span>
<span class="sd">        `what_to_do_with_remainding=&#39;ignore&#39;`, which will just return the (args, kwargs) pair</span>
<span class="sd">        `what_to_do_with_remainding=&#39;assert_empty&#39;`, which will do the same, but first assert the remainder is empty</span>
<span class="sd">    We suggest to use `functools.partial` to configure the `argument_argument` you need.</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; arg_extractor = partial(extract_arguments,</span>
<span class="sd">    ...     what_to_do_with_remainding=&#39;assert_empty&#39;,</span>
<span class="sd">    ...     include_all_when_var_keywords_in_params=True)</span>
<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0, **kws): ...</span>
<span class="sd">    &gt;&gt;&gt; arg_extractor(f, b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;)</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    And what happens if the kwargs doesn&#39;t contain all the POSITION_ONLY arguments?</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0): ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, d=&#39;is a kw arg&#39;, e=&#39;is not an arg at all&#39;)</span>
<span class="sd">    ((MissingArgValFor(&quot;a&quot;), 2, MissingArgValFor(&quot;c&quot;)), {&#39;d&#39;: &#39;is a kw arg&#39;}, {&#39;e&#39;: &#39;is not an arg at all&#39;})</span>

<span class="sd">    A few more examples...</span>

<span class="sd">    Let&#39;s call `extract_arguments` with params being not a function,</span>
<span class="sd">    but, a Signature instance, a mapping whose values are Parameter instances,</span>
<span class="sd">    or an iterable of Parameter instances...</span>

<span class="sd">    &gt;&gt;&gt; def func(a, b,  /, c=None, *, d=0, **kws): ...</span>
<span class="sd">    &gt;&gt;&gt; sig = Signature.from_callable(func)</span>
<span class="sd">    &gt;&gt;&gt; param_map = sig.parameters</span>
<span class="sd">    &gt;&gt;&gt; param_iterable = param_map.values()</span>
<span class="sd">    &gt;&gt;&gt; kwargs = dict(b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert extract_arguments(sig, **kwargs) == extract_arguments(func, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; assert extract_arguments(param_map, **kwargs) == extract_arguments(func, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; assert extract_arguments(param_iterable, **kwargs) == extract_arguments(func, **kwargs)</span>

<span class="sd">    Edge case:</span>
<span class="sd">    No params specified? No problem. You&#39;ll just get empty args and kwargs. Everything in the remainder</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(params=(), b=2, a=1, c=3, d=0)</span>
<span class="sd">    ((), {}, {&#39;b&#39;: 2, &#39;a&#39;: 1, &#39;c&#39;: 3, &#39;d&#39;: 0})</span>

<span class="sd">    :param params: Specifies what PO arguments should be extracted.</span>
<span class="sd">        Could be a callable, Signature, iterable of Parameters...</span>
<span class="sd">    :param what_to_do_with_remainding:</span>
<span class="sd">        &#39;return&#39; (default): function will return `param_args`, `param_kwargs`, `remaining_kwargs`</span>
<span class="sd">        &#39;ignore&#39;: function will return `param_args`, `param_kwargs`</span>
<span class="sd">        &#39;assert_empty&#39;: function will assert that `remaining_kwargs` is empty and then return `param_args`, `param_kwargs`</span>
<span class="sd">    :param include_all_when_var_keywords_in_params=False,</span>
<span class="sd">    :param assert_no_missing_position_only_args=False,</span>
<span class="sd">    :param kwargs: The kwargs to extract the args from</span>
<span class="sd">    :return: A (param_args, param_kwargs, remaining_kwargs) tuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">what_to_do_with_remainding</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_empty&#39;</span><span class="p">}</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include_all_when_var_keywords_in_params</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assert_no_missing_position_only_args</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(),</span> <span class="p">{},</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="n">params_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">names_for_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">]</span>
    <span class="n">param_kwargs_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">params_names</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">names_for_args</span><span class="p">)]</span>
    <span class="n">remaining_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params_names</span><span class="p">]</span>

    <span class="n">param_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">MissingArgValFor</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">names_for_args</span><span class="p">)</span>
    <span class="n">param_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">param_kwargs_names</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
    <span class="n">remaining_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">remaining_names</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">include_all_when_var_keywords_in_params</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">next</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">param_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">remaining_kwargs</span><span class="p">)</span>
            <span class="n">remaining_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">assert_no_missing_position_only_args</span><span class="p">:</span>
        <span class="n">missing_argnames</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">argname</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">param_args</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MissingArgValFor</span><span class="p">))</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">missing_argnames</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;There were some missing positional only argnames: </span><span class="si">{</span><span class="n">missing_argnames</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="n">what_to_do_with_remainding</span> <span class="o">==</span> <span class="s1">&#39;return&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">param_args</span><span class="p">,</span> <span class="n">param_kwargs</span><span class="p">,</span> <span class="n">remaining_kwargs</span>
    <span class="k">elif</span> <span class="n">what_to_do_with_remainding</span> <span class="o">==</span> <span class="s1">&#39;ignore&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">param_args</span><span class="p">,</span> <span class="n">param_kwargs</span>
    <span class="k">elif</span> <span class="n">what_to_do_with_remainding</span> <span class="o">==</span> <span class="s1">&#39;assert_empty&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining_kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;remaining_kwargs not empty: remaining_kwargs=</span><span class="si">{</span><span class="n">remaining_kwargs</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">param_args</span><span class="p">,</span> <span class="n">param_kwargs</span></div>


<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="n">extract_arguments_ignoring_remainder</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">extract_arguments</span><span class="p">,</span>
                                               <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="n">extract_arguments_asserting_no_remainder</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">extract_arguments</span><span class="p">,</span>
                                                   <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;assert_empty&#39;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>


<div class="viewcode-block" id="Command"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Command">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Command</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A dataclass that holds a `(caller, args, kwargs)` triple and allows one to execute `caller(*args, **kwargs)`</span>

<span class="sd">    :param caller: A callable that will be called with (*args, **kwargs) argument</span>
<span class="sd">    :param args: A tuple</span>
<span class="sd">    :param kwargs:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">caller</span><span class="p">:</span> <span class="n">callable</span>
    <span class="n">args</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">caller</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="extract_commands"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.extract_commands">[docs]</a><span class="k">def</span> <span class="nf">extract_commands</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                     <span class="n">mk_command</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">Command</span><span class="p">,</span>
                     <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param funcs:</span>
<span class="sd">    :param mk_command:</span>
<span class="sd">    :param kwargs:</span>
<span class="sd">    :return:</span>

<span class="sd">    &gt;&gt;&gt; def add(a, b: float = 0.0) -&gt; float:</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; def mult(x: float, y=1):</span>
<span class="sd">    ...     return x * y</span>
<span class="sd">    &gt;&gt;&gt; def formula1(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">    ...     return ((w + x) * y) ** z</span>
<span class="sd">    &gt;&gt;&gt; commands = extract_commands((add, mult, formula1), a=1, b=2, c=3, d=4, e=5, w=6, x=7)</span>
<span class="sd">    &gt;&gt;&gt; for command in commands:</span>
<span class="sd">    ...     print(f&quot;Calling {command.caller.__name__} with args={command.args} and kwargs={command.kwargs}&quot;)</span>
<span class="sd">    ...     print(command())</span>
<span class="sd">    ...</span>
<span class="sd">    Calling add with args=() and kwargs={&#39;a&#39;: 1, &#39;b&#39;: 2}</span>
<span class="sd">    3</span>
<span class="sd">    Calling mult with args=() and kwargs={&#39;x&#39;: 7}</span>
<span class="sd">    7</span>
<span class="sd">    Calling formula1 with args=(6,) and kwargs={&#39;x&#39;: 7}</span>
<span class="sd">    13</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">extract</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">extract_arguments</span><span class="p">,</span>
                      <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="n">what_to_do_with_remainding</span><span class="p">,</span>
                      <span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">assert_no_missing_position_only_args</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">funcs</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
        <span class="n">func_args</span><span class="p">,</span> <span class="n">func_kwargs</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">mk_command</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func_args</span><span class="p">,</span> <span class="n">func_kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="commands_dict"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.commands_dict">[docs]</a><span class="k">def</span> <span class="nf">commands_dict</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                  <span class="n">mk_command</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">Command</span><span class="p">,</span>
                  <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param funcs:</span>
<span class="sd">    :param mk_command:</span>
<span class="sd">    :param kwargs:</span>
<span class="sd">    :return:</span>

<span class="sd">    &gt;&gt;&gt; def add(a, b: float = 0.0) -&gt; float:</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; def mult(x: float, y=1):</span>
<span class="sd">    ...     return x * y</span>
<span class="sd">    &gt;&gt;&gt; def formula1(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">    ...     return ((w + x) * y) ** z</span>
<span class="sd">    &gt;&gt;&gt; d = commands_dict((add, mult, formula1), a=1, b=2, c=3, d=4, e=5, w=6, x=7)</span>
<span class="sd">    &gt;&gt;&gt; d[add]()</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; d[mult]()</span>
<span class="sd">    7</span>
<span class="sd">    &gt;&gt;&gt; d[formula1]()</span>
<span class="sd">    13</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">funcs</span><span class="p">]</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">extract_commands</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="n">what_to_do_with_remainding</span><span class="p">,</span>
                          <span class="n">mk_command</span><span class="o">=</span><span class="n">mk_command</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">it</span><span class="p">))</span></div>


<div class="viewcode-block" id="Param"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Param">[docs]</a><span class="k">class</span> <span class="nc">Param</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="c1"># aliases</span>
    <span class="n">PK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
    <span class="n">OP</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span>
    <span class="n">OK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
    <span class="n">VP</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span>
    <span class="n">VK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">param_has_default_or_is_var_kind</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="o">!=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">var_param_kinds</span>


<span class="n">WRAPPER_UPDATES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__dict__&#39;</span><span class="p">,)</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>


<span class="c1"># TODO: See other signature operating functions below in this module:</span>
<span class="c1">#   Do we need them now that we have Sig?</span>
<span class="c1">#   Do we want to keep them and have Sig use them?</span>
<div class="viewcode-block" id="Sig"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig">[docs]</a><span class="k">class</span> <span class="nc">Sig</span><span class="p">(</span><span class="n">Signature</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A subclass of inspect.Signature that has some extra api sugar, such as a dict-like interface, merging, ...</span>

<span class="sd">    You can construct a `Sig` object from a callable,</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1): ...</span>
<span class="sd">    &gt;&gt;&gt; Sig(f)</span>
<span class="sd">    &lt;Sig (w, /, x: float = 1, y=1, *, z: int = 1)&gt;</span>

<span class="sd">    but also from any &quot;ParamsAble&quot; object. Such as...</span>
<span class="sd">    an iterable of Parameter instances, strings, tuples, or dicts:</span>

<span class="sd">    &gt;&gt;&gt; Sig([&#39;a&#39;, (&#39;b&#39;, Parameter.empty, int), (&#39;c&#39;, 2), (&#39;d&#39;, 1.0, float),</span>
<span class="sd">    ...                dict(name=&#39;special&#39;, kind=Parameter.KEYWORD_ONLY, default=0)])</span>
<span class="sd">    &lt;Sig (a, b: int, c=2, d: float = 1.0, *, special=0)&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; Sig([&#39;a&#39;, &#39;b&#39;, dict(name=&#39;args&#39;, kind=Parameter.VAR_POSITIONAL),</span>
<span class="sd">    ...                dict(name=&#39;kwargs&#39;, kind=Parameter.VAR_KEYWORD)]</span>
<span class="sd">    ... )</span>
<span class="sd">    &lt;Sig (a, b, *args, **kwargs)&gt;</span>

<span class="sd">    The parameters of a signature are like a matrix whose rows are the parameters,</span>
<span class="sd">    and the 4 columns are their properties: name, kind, default, and annotation</span>
<span class="sd">    (the two laste ones being optional).</span>
<span class="sd">    You get a row view when doing `Sig(...).parameters.values()`,</span>
<span class="sd">    but what if you want a column-view?</span>
<span class="sd">    Here&#39;s how:</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3): ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s = Sig(f)</span>
<span class="sd">    &gt;&gt;&gt; s.kinds  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    {&#39;w&#39;: &lt;_ParameterKind.POSITIONAL_ONLY: 0&gt;,</span>
<span class="sd">    &#39;x&#39;: &lt;_ParameterKind.POSITIONAL_OR_KEYWORD: 1&gt;,</span>
<span class="sd">    &#39;y&#39;: &lt;_ParameterKind.POSITIONAL_OR_KEYWORD: 1&gt;,</span>
<span class="sd">    &#39;z&#39;: &lt;_ParameterKind.KEYWORD_ONLY: 3&gt;}</span>

<span class="sd">    &gt;&gt;&gt; s.annotations</span>
<span class="sd">    {&#39;x&#39;: &lt;class &#39;float&#39;&gt;, &#39;z&#39;: &lt;class &#39;int&#39;&gt;}</span>
<span class="sd">    &gt;&gt;&gt; assert s.annotations == f.__annotations__  # same as what you get in `__annotations__`</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s.defaults</span>
<span class="sd">    {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;z&#39;: 3}</span>
<span class="sd">    &gt;&gt;&gt; # Note that it&#39;s not the same as you get in __defaults__ though:</span>
<span class="sd">    &gt;&gt;&gt; assert s.defaults != f.__defaults__ == (1, 2)  # not 3, since __kwdefaults__ has that!</span>

<span class="sd">    We can sum (i.e. merge) and subtract (i.e. remove arguments) Sig instances.</span>
<span class="sd">    Also, Sig instance is callable. It has the effect of inserting it&#39;s signature in the input</span>
<span class="sd">    (in `__signature__`, but also inserting the resulting `__defaults__` and `__kwdefaults__`).</span>
<span class="sd">    One of the intents is to be able to do things like:</span>

<span class="sd">    &gt;&gt;&gt; import inspect</span>
<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1): ...</span>
<span class="sd">    &gt;&gt;&gt; def g(i, w, j=2): ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @Sig.from_objs(f, g, [&#39;a&#39;, (&#39;b&#39;, 3.14), (&#39;c&#39;, 42, int)])</span>
<span class="sd">    ... def some_func(*args, **kwargs):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(some_func)</span>
<span class="sd">    &lt;Signature (w, i, a, x: float = 1, y=1, z: int = 1, j=2, b=3.14, c: int = 42)&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; sig = Sig(f) + g + [&#39;a&#39;, (&#39;b&#39;, 3.14), (&#39;c&#39;, 42, int)] - &#39;b&#39; - [&#39;a&#39;, &#39;z&#39;]</span>
<span class="sd">    &gt;&gt;&gt; @sig</span>
<span class="sd">    ... def some_func(*args, **kwargs):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(some_func)</span>
<span class="sd">    &lt;Signature (w, i, x: float = 1, y=1, j=2, c: int = 42)&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">ParamsAble</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                 <span class="n">return_annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span>
                 <span class="n">__validate_parameters__</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a Sig instance.</span>
<span class="sd">        See Also: `ensure_params` to see what kind of objects you can make `Sig`s with.</span>

<span class="sd">        :param obj: A ParamsAble object, which could be:</span>
<span class="sd">            - a callable,</span>
<span class="sd">            - and iterable of Parameter instances</span>
<span class="sd">            - an iterable of strings (representing annotation-less, default-less) argument names,</span>
<span class="sd">            - tuples: (argname, default) or (argname, default, annotation),</span>
<span class="sd">            - dicts: ``{&#39;name&#39;: REQUIRED,...}`` with optional `kind`, `default` and `annotation` fields</span>
<span class="sd">            - None (which will produce an argument-less Signature)</span>

<span class="sd">        &gt;&gt;&gt; Sig([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &lt;Sig (a, b, c)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig([&#39;a&#39;, (&#39;b&#39;, None), (&#39;c&#39;, 42, int)])  # specifying defaults and annotations</span>
<span class="sd">        &lt;Sig (a, b=None, c: int = 42)&gt;</span>
<span class="sd">        &gt;&gt;&gt; import inspect</span>
<span class="sd">        &gt;&gt;&gt; Sig([&#39;a&#39;, (&#39;b&#39;, inspect._empty, int)])  # specifying an annotation without a default</span>
<span class="sd">        &lt;Sig (a, b: int)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], return_annotation=str)  # specifying return annotation</span>
<span class="sd">        &lt;Sig (a, b, c) -&gt; str&gt;</span>

<span class="sd">        But you can always specify parameters the &quot;long&quot; way</span>

<span class="sd">        &gt;&gt;&gt; Sig([inspect.Parameter(name=&#39;kws&#39;, kind=inspect.Parameter.VAR_KEYWORD)], return_annotation=str)</span>
<span class="sd">        &lt;Sig (**kws) -&gt; str&gt;</span>

<span class="sd">        And note that:</span>
<span class="sd">        &gt;&gt;&gt; Sig()</span>
<span class="sd">        &lt;Sig ()&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(None)</span>
<span class="sd">        &lt;Sig ()&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="n">return_annotation</span> <span class="ow">is</span> <span class="n">empty</span><span class="p">:</span>
            <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">Signature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ensure_params</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span>
                         <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">,</span>
                         <span class="n">__validate_parameters__</span><span class="o">=</span><span class="n">__validate_parameters__</span><span class="p">)</span>

<div class="viewcode-block" id="Sig.wrap"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig.wrap">[docs]</a>    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the input function the signature.</span>
<span class="sd">        This is similar to the `functools.wraps` function, but parametrized by a signature</span>
<span class="sd">        (not a callable). Also, where as both write to the input func&#39;s `__signature__`</span>
<span class="sd">        attribute, here we also write to</span>
<span class="sd">        - `__defaults__` and `__kwdefaults__`, extracting these from `__signature__`</span>
<span class="sd">            (functools.wraps doesn&#39;t do that at the time of writing this</span>
<span class="sd">            (see https://github.com/python/cpython/pull/21379)).</span>
<span class="sd">        - `__annotations__` (also extracted from `__signature__`)</span>
<span class="sd">        - does not write to `__module__`, `__name__`, `__qualname__`, `__doc__`</span>
<span class="sd">            (because again, we&#39;re basinig the injecton on a signature, not a function,</span>
<span class="sd">            so we have no name, doc, etc...)</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, z: int = 3):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; f(0, 1)  # 0 + 1 * 2 ** 3</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; f.__defaults__</span>
<span class="sd">        (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; assert 8 == f(0) == f(0, 1) == f(0, 1, 2) == f(0, 1, 2, 3)</span>

<span class="sd">        Now let&#39;s create a very similar function to f, but where:</span>
<span class="sd">        - w is not position-only</span>
<span class="sd">        - x annot is int instead of float, and doesn&#39;t have a default</span>
<span class="sd">        - z&#39;s default changes to 10</span>
<span class="sd">        &gt;&gt;&gt; def g(w, x: int, y=2, z: int = 10):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; s = Sig(g)</span>
<span class="sd">        &gt;&gt;&gt; f = s.wrap(f)</span>
<span class="sd">        &gt;&gt;&gt; import inspect</span>
<span class="sd">        &gt;&gt;&gt; inspect.signature(f)  # see that</span>
<span class="sd">        &lt;Signature (w, x: int, y=2, z: int = 10)&gt;</span>
<span class="sd">        &gt;&gt;&gt; # But (unlike with functools.wraps) here we get __defaults__ and __kwdefault__</span>
<span class="sd">        &gt;&gt;&gt; f.__defaults__  # see that x has no more default, and z&#39;s default changed to 10</span>
<span class="sd">        (2, 10)</span>
<span class="sd">        &gt;&gt;&gt; f(0, 1)  # see that now we get a different output because using different defaults</span>
<span class="sd">        1024</span>

<span class="sd">        TODO: Something goes wrong when using keyword only arguments.</span>
<span class="sd">            Note that the same problem occurs with functools.wraps, and even boltons.funcutils.wraps.</span>
<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; f(0)  # 0 + 1 * 2 ** 3</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; f(0, 1, 2, 3)  # error expected!</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: f() takes from 1 to 3 positional arguments but 4 were given</span>
<span class="sd">        &gt;&gt;&gt; def g(w, x: int, y=2, *, z: int = 10):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; s = Sig(g)</span>
<span class="sd">        &gt;&gt;&gt; f = s.wrap(f)</span>
<span class="sd">        &gt;&gt;&gt; f.__defaults__</span>
<span class="sd">        (2,)</span>
<span class="sd">        &gt;&gt;&gt; f.__kwdefaults__</span>
<span class="sd">        {&#39;z&#39;: 10}</span>
<span class="sd">        &gt;&gt;&gt; f(0, 1, 2, 3)  # error not expected! TODO: Make it work!!</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: f() takes from 2 to 3 positional arguments but 4 were given</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                                       <span class="n">return_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span>
        <span class="c1"># endow the function with __defaults__ and __kwdefaults__ (not the default of functools.wraps!)</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__kwdefaults__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dunder_defaults_and_kwdefaults</span><span class="p">()</span>
        <span class="c1"># &quot;copy&quot; over all other non-dunder attributes (not the default of functools.wraps!)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">),</span> <span class="nb">dir</span><span class="p">(</span><span class="n">func</span><span class="p">)):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">func</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the input function the signature.</span>
<span class="sd">        Just calls Sig.wrap so see docs of Sig.wrap (which contains examples and doctests).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

<div class="viewcode-block" id="Sig.sig_or_none"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig.sig_or_none">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sig_or_none</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a Sig instance, or None if there was a ValueError trying to construct it.</span>
<span class="sd">        One use case is to be able to tell if an object has a signature or not.</span>

<span class="sd">        &gt;&gt;&gt; has_signature = lambda obj: bool(Sig.sig_or_none(obj))</span>
<span class="sd">        &gt;&gt;&gt; has_signature(print)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; has_signature(Sig)</span>
<span class="sd">        True</span>

<span class="sd">        This means we can more easily get signatures in bulk without having to write try/catches:</span>

<span class="sd">        &gt;&gt;&gt; len(list(filter(None, map(Sig.sig_or_none, (Sig, print, map, filter, Sig.wrap)))))</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">cls</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_dunder_defaults_and_kwdefaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the __defaults__, __kwdefaults__ (i.e. what would be the dunders baring these names in a python callable)</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=1, *, z: int = 1): ...</span>
<span class="sd">        &gt;&gt;&gt; __defaults__, __kwdefaults__ = Sig(foo)._dunder_defaults_and_kwdefaults()</span>
<span class="sd">        &gt;&gt;&gt; __defaults__</span>
<span class="sd">        (1,)</span>
<span class="sd">        &gt;&gt;&gt; __kwdefaults__</span>
<span class="sd">        {&#39;z&#39;: 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ko_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_for_kind</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">KO</span><span class="p">)</span>
        <span class="n">dflts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaults</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">dflts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dflts</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ko_names</span><span class="p">),</span>
            <span class="c1"># as known as __defaults__ in python callables</span>
            <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">dflts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dflts</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ko_names</span><span class="p">}</span>  <span class="c1"># as known as __kwdefaults__ in python callables</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Sig.to_signature_kwargs"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig.to_signature_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">to_signature_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The dict of keyword arguments to make this signature instance.</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 2, y=1, *, z: int = 0) -&gt; float: ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(f).to_signature_kwargs()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        {&#39;parameters&#39;:</span>
<span class="sd">            [&lt;Parameter &quot;w&quot;&gt;,</span>
<span class="sd">            &lt;Parameter &quot;x: float = 2&quot;&gt;,</span>
<span class="sd">            &lt;Parameter &quot;y=1&quot;&gt;,</span>
<span class="sd">            &lt;Parameter &quot;z: int = 0&quot;&gt;],</span>
<span class="sd">        &#39;return_annotation&#39;: &lt;class &#39;float&#39;&gt;}</span>

<span class="sd">        Note that this does NOT return:</span>
<span class="sd">        ```</span>
<span class="sd">                {&#39;parameters&#39;: self.parameters,</span>
<span class="sd">                &#39;return_annotation&#39;: self.return_annotation}</span>
<span class="sd">        ```</span>
<span class="sd">        which would not actually work as keyword arguments of ``Signature``.</span>
<span class="sd">        Yeah, I know. Don&#39;t ask me, ask the authors of `Signature`!</span>

<span class="sd">        Instead, `parammeters` will be ``list(self.parameters.values())``, which does work.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;parameters&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                <span class="s1">&#39;return_annotation&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">}</span></div>

<div class="viewcode-block" id="Sig.to_simple_signature"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig.to_simple_signature">[docs]</a>    <span class="k">def</span> <span class="nf">to_simple_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A builtin ``inspect.Signature`` instance equivalent (i.e. without the extra properties and methods)</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 2, y=1, *, z: int = 0): ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(f).to_simple_signature()</span>
<span class="sd">        &lt;Signature (w, /, x: float = 2, y=1, *, z: int = 0)&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">to_signature_kwargs</span><span class="p">())</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_objs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">objs</span><span class="p">,</span> <span class="o">**</span><span class="n">name_and_dflts</span><span class="p">):</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="n">name_and_dflts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">([{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">:</span> <span class="n">PK</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">default</span><span class="p">}])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">first_obj</span><span class="p">,</span> <span class="o">*</span><span class="n">objs</span> <span class="o">=</span> <span class="n">objs</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">ensure_params</span><span class="p">(</span><span class="n">first_obj</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">+</span> <span class="n">obj</span>
            <span class="k">return</span> <span class="n">sig</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if no objs are given</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">()</span>  <span class="c1"># return an empty signature</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_params</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Just list(self.parameters.values()), because that&#39;s often what we want.</span>
<span class="sd">        Why a Sig.params property when we already have a Sig.parameters property?</span>

<span class="sd">        Well, as much as is boggles my mind, it so happens that the Signature.parameters</span>
<span class="sd">        is a name-&gt;Parameter mapping, but the Signature argument `parameters`, though baring the same name,</span>
<span class="sd">        is expected to be a list of Parameter instances.</span>

<span class="sd">        So Sig.params is there to restore semantic consistence sanity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="o">!=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;{arg_name: annotation, ...} dict of annotations of the signature.</span>
<span class="sd">        What `func.__annotations__` would give you.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">annotation</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">annotation</span> <span class="o">!=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">}</span>

    <span class="c1"># def substitute(self, **sub_for_name):</span>
    <span class="c1">#     def gen():</span>
    <span class="c1">#</span>
    <span class="c1">#         for name, substitution in sub_for_name.items():</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">names_for_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">kind</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_var_kinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">var_param_kinds</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_var_positional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">VP</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_var_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">VK</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

<div class="viewcode-block" id="Sig.merge_with_sig"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig.merge_with_sig">[docs]</a>    <span class="k">def</span> <span class="nf">merge_with_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">,</span> <span class="n">ch_to_all_pk</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a signature obtained by merging self signature with another signature.</span>
<span class="sd">        Insofar as it can, given the kind precedence rules, the arguments of self will appear first.</span>

<span class="sd">        :param sig: The signature to merge with.</span>
<span class="sd">        :param ch_to_all_pk: Whether to change all kinds of both signatures to PK (POSITIONAL_OR_KEYWORD)</span>
<span class="sd">        :return:</span>

<span class="sd">        &gt;&gt;&gt; from py2store.utils.signatures import Sig, KO</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def func(a=None, *, b=1, c=2): ...</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; s = Sig(func)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        &lt;Sig (a=None, *, b=1, c=2)&gt;</span>

<span class="sd">        Observe where the new arguments ``d`` and ``e`` are placed,</span>
<span class="sd">        according to whether they have defaults and what their kind is:</span>

<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&#39;d&#39;, &#39;e&#39;])</span>
<span class="sd">        &lt;Sig (d, e, a=None, *, b=1, c=2)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&#39;d&#39;, (&#39;e&#39;, 4)])</span>
<span class="sd">        &lt;Sig (d, a=None, e=4, *, b=1, c=2)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&#39;d&#39;, dict(name=&#39;e&#39;, kind=KO, default=4)])</span>
<span class="sd">        &lt;Sig (d, a=None, *, b=1, c=2, e=4)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([dict(name=&#39;d&#39;, kind=KO), dict(name=&#39;e&#39;, kind=KO, default=4)])</span>
<span class="sd">        &lt;Sig (a=None, *, d, b=1, c=2, e=4)&gt;</span>

<span class="sd">        If the kind of the params is not important, but order is, you can specify ``ch_to_all_pk=True``:</span>

<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&#39;d&#39;, &#39;e&#39;], ch_to_all_pk=True)</span>
<span class="sd">        &lt;Sig (d, e, a=None, b=1, c=2)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([(&#39;d&#39;, 3), (&#39;e&#39;, 4)], ch_to_all_pk=True)</span>
<span class="sd">        &lt;Sig (a=None, b=1, c=2, d=3, e=4)&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ch_to_all_pk</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">ch_signature_to_all_pk</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">ch_signature_to_all_pk</span><span class="p">(</span><span class="n">ensure_signature</span><span class="p">(</span><span class="n">sig</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

        <span class="n">_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Happened during an attempt to merge </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">sig</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">_self</span><span class="o">.</span><span class="n">has_var_keyword</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_sig</span><span class="o">.</span><span class="n">has_var_keyword</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;Can&#39;t merge two signatures if they both have a VAR_POSITIONAL parameter:</span><span class="si">{</span><span class="n">_msg</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">_self</span><span class="o">.</span><span class="n">has_var_keyword</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_sig</span><span class="o">.</span><span class="n">has_var_keyword</span><span class="p">,</span> \
            <span class="s2">&quot;Can&#39;t merge two signatures if they both have a VAR_KEYWORD parameter:</span><span class="si">{_msg}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">((</span><span class="n">_self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">_self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">default</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">_sig</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">_sig</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">_sig</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> \
            <span class="sa">f</span><span class="s2">&quot;During a signature merge, if two names are the same, they must have the same kind and default:</span><span class="si">{</span><span class="n">_msg</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chain_params_of_signatures</span><span class="p">(</span>
            <span class="n">_self</span><span class="o">.</span><span class="n">without_defaults</span><span class="p">,</span> <span class="n">_sig</span><span class="o">.</span><span class="n">without_defaults</span><span class="p">,</span> <span class="n">_self</span><span class="o">.</span><span class="n">with_defaults</span><span class="p">,</span> <span class="n">_sig</span><span class="o">.</span><span class="n">with_defaults</span><span class="p">))</span>
        <span class="n">params</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">params</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge two signatures (casting all non-VAR kinds to POSITIONAL_OR_KEYWORD before hand)</span>

<span class="sd">        Important Notes:</span>
<span class="sd">        - The resulting Sig will loose it&#39;s return_annotation if it had one.</span>
<span class="sd">            This is to avoid making too many assumptions about how the sig sum will be used.</span>
<span class="sd">            If a return_annotation is needed (say, for composition, the last return_annotation</span>
<span class="sd">            summed), one can subclass Sig and overwrite __add__</span>
<span class="sd">        - POSITION_ONLY and KEYWORD_ONLY kinds will be replaced by POSITIONAL_OR_KEYWORD kind.</span>
<span class="sd">        This is to simplify the interface and code.</span>
<span class="sd">        If the user really wants to maintain those kinds, they can replace them back after the fact.</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1): ...</span>
<span class="sd">        &gt;&gt;&gt; def h(i, j, w): ...  # has a &#39;w&#39; argument, like f and g</span>
<span class="sd">        &gt;&gt;&gt; def different(a, b: str, c=None): ...  # No argument names in common with other functions</span>

<span class="sd">        &gt;&gt;&gt; Sig(f) + Sig(different)</span>
<span class="sd">        &lt;Sig (w, a, b: str, x: float = 1, y=1, z: int = 1, c=None)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(different) + Sig(f)</span>
<span class="sd">        &lt;Sig (a, b: str, w, c=None, x: float = 1, y=1, z: int = 1)&gt;</span>

<span class="sd">        The order of the first signature will take precedence over the second,</span>
<span class="sd">        but default-less arguments have to come before arguments with defaults.</span>
<span class="sd">         first, and Note the difference of the orders.</span>
<span class="sd">        &gt;&gt;&gt; Sig(f) + Sig(h)</span>
<span class="sd">        &lt;Sig (w, i, j, x: float = 1, y=1, z: int = 1)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(h) + Sig(f)</span>
<span class="sd">        &lt;Sig (i, j, w, x: float = 1, y=1, z: int = 1)&gt;</span>

<span class="sd">        The sum of two Sig&#39;s takes a safe-or-blow-up-now approach.</span>
<span class="sd">        If any of the arguments have different defaults or annotations, summing will raise an AssertionError.</span>
<span class="sd">        It&#39;s up to the user to decorate their input functions to express the default they actually desire.</span>

<span class="sd">        &gt;&gt;&gt; def ff(w, /, x: float, y=1, *, z: int = 1): ...  # just like f, but without the default for x</span>
<span class="sd">        &gt;&gt;&gt; Sig(f) + Sig(ff)  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AssertionError: During a signature merge, if two names are the same, they must have the same kind and default:</span>
<span class="sd">        Happened during an attempt to merge (w, /, x: float = 1, y=1, *, z: int = 1) and (w, /, x: float, y=1, *, z: int = 1)</span>


<span class="sd">        &gt;&gt;&gt; def hh(i, j, w=1): ...  # like h, but w has a default</span>
<span class="sd">        &gt;&gt;&gt; Sig(h) + Sig(hh)  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AssertionError: During a signature merge, if two names are the same, they must have the same kind and default:</span>
<span class="sd">        Happened during an attempt to merge (i, j, w) and (i, j, w=1)</span>


<span class="sd">        &gt;&gt;&gt; Sig(f) + [&#39;w&#39;, (&#39;y&#39;, 1), (&#39;d&#39;, 1.0, float),</span>
<span class="sd">        ...                dict(name=&#39;special&#39;, kind=Parameter.KEYWORD_ONLY, default=0)]</span>
<span class="sd">        &lt;Sig (w, x: float = 1, y=1, z: int = 1, d: float = 1.0, special=0)&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">ch_to_all_pk</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adding on the right.</span>
<span class="sd">        The raison d&#39;√™tre for this is so that you can start your summing with any signature speccifying</span>
<span class="sd">         object that Sig will be able to resolve into a signature. Like this:</span>

<span class="sd">        &gt;&gt;&gt; [&#39;first_arg&#39;, (&#39;second_arg&#39;, 42)] + Sig(lambda x, y: x * y)</span>
<span class="sd">        &lt;Sig (first_arg, x, y, second_arg=42)&gt;</span>

<span class="sd">        Note that the ``second_arg`` doesn&#39;t actually end up being the second argument because</span>
<span class="sd">        it has a default and x and y don&#39;t. But if you did this:</span>

<span class="sd">        &gt;&gt;&gt; [&#39;first_arg&#39;, (&#39;second_arg&#39;, 42)] + Sig(lambda x=0, y=1: x * y)</span>
<span class="sd">        &lt;Sig (first_arg, second_arg=42, x=0, y=1)&gt;</span>

<span class="sd">        you&#39;d get what you expect.</span>

<span class="sd">        Of course, we could have just obliged you to say ``Sig([&#39;first_arg&#39;, (&#39;second_arg&#39;, 42)])``</span>
<span class="sd">        explicitly and spare ourselves yet another method.</span>
<span class="sd">        The reason we made ``__radd__`` is so we can make it handle 0 + Sig(...), so that you can</span>
<span class="sd">        merge an iterable of signatures like this:</span>

<span class="sd">        &gt;&gt;&gt; def f(a, b, c): ...</span>
<span class="sd">        &gt;&gt;&gt; def g(c, b, e): ...</span>
<span class="sd">        &gt;&gt;&gt; sigs = map(Sig, [f, g])</span>
<span class="sd">        &gt;&gt;&gt; sum(sigs)</span>
<span class="sd">        &lt;Sig (a, b, c, e)&gt;</span>

<span class="sd">        Let&#39;s say, for whatever reason (don&#39;t ask me), you wanted to make a function that contains all the</span>
<span class="sd">        arguments of all the functions of ``os.path`` (that don&#39;t contain any var arg kinds).</span>

<span class="sd">        &gt;&gt;&gt; import os.path</span>
<span class="sd">        &gt;&gt;&gt; funcs = list(filter(callable, (getattr(os.path, a) for a in dir(os.path) if not a.startswith(&#39;_&#39;))))</span>
<span class="sd">        &gt;&gt;&gt; sigs = filter(lambda sig: not sig.has_var_kinds, map(Sig, funcs))</span>
<span class="sd">        &gt;&gt;&gt; sum(sigs)</span>
<span class="sd">        &lt;Sig (path, p, paths, m, filename, s, f1, f2, fp1, fp2, s1, s2, start=None)&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sig</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># so that we can do ``sum(iterable_of_sigs)``</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sig</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">names</span><span class="p">)}</span>
        <span class="n">new_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_names</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_chain_params_of_signatures</span><span class="p">(</span><span class="o">*</span><span class="n">sigs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yields Parameter instances taken from sigs without repeating the same name twice.</span>
<span class="sd">        &gt;&gt;&gt; str(list(Sig._chain_params_of_signatures(Sig(lambda x, *args, y=1: ...),</span>
<span class="sd">        ...     Sig(lambda x, y, z, **kwargs: ...))))</span>
<span class="sd">        &#39;[&lt;Parameter &quot;x&quot;&gt;, &lt;Parameter &quot;*args&quot;&gt;, &lt;Parameter &quot;y=1&quot;&gt;, &lt;Parameter &quot;z&quot;&gt;, &lt;Parameter &quot;**kwargs&quot;&gt;]&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">already_merged_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sigs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">already_merged_names</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">p</span>
                <span class="n">already_merged_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">without_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from i2.signatures import Sig</span>
<span class="sd">        &gt;&gt;&gt; list(Sig(lambda *args, a, b, x=1, y=1, **kwargs: ...).without_defaults)</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">param_has_default_or_is_var_kind</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">with_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from i2.signatures import Sig</span>
<span class="sd">        &gt;&gt;&gt; list(Sig(lambda *args, a, b, x=1, y=1, **kwargs: ...).with_defaults)</span>
<span class="sd">        [&#39;args&#39;, &#39;x&#39;, &#39;y&#39;, &#39;kwargs&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">param_has_default_or_is_var_kind</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">normalize_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">changed_params</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_param_kinds</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">p</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">changed_params</span><span class="p">()),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>

<div class="viewcode-block" id="Sig.kwargs_from_args_and_kwargs"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig.kwargs_from_args_and_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                                    <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_excess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts a dict of input argument values for target signature, from args and kwargs.</span>

<span class="sd">        When you need to manage how the arguments of a function are specified, you need to take care of</span>
<span class="sd">        multiple cases depending on whether they were specified as positional arguments</span>
<span class="sd">        (`args`) or keyword arguments (`kwargs`).</span>

<span class="sd">        The `kwargs_from_args_and_kwargs` (and it&#39;s sorta-inverse inverse, `args_and_kwargs_from_kwargs`)</span>
<span class="sd">        are there to help you manage this.</span>

<span class="sd">        If you could rely on the the fact that only `kwargs` were given it would reduce the complexity of your code.</span>
<span class="sd">        This is why we have the `ch_signature_to_all_pk` function in `signatures.py`.</span>

<span class="sd">        We also need to have a means to make a `kwargs` only from the actual `(*args, **kwargs)` used at runtime.</span>
<span class="sd">        We have `Signature.bind` (and `bind_partial`) for that.</span>

<span class="sd">        But these methods will fail if there is extra stuff in the `kwargs`.</span>
<span class="sd">        Yet sometimes we&#39;d like to have a `dict` that services several functions that will extract their needs from it.</span>

<span class="sd">        That&#39;s where  `Sig.extract_kwargs(*args, **kwargs)` is needed.</span>
<span class="sd">        :param args: The args the function will be called with.</span>
<span class="sd">        :param kwargs: The kwargs the function will be called with.</span>
<span class="sd">        :param apply_defaults: (bool) Whether to apply signature defaults to the non-specified argument names</span>
<span class="sd">        :param allow_partial: (bool) True iff you want to allow partial signature fulfillment.</span>
<span class="sd">        :param allow_excess: (bool) Set to True iff you want to allow extra kwargs items to be ignored.</span>
<span class="sd">        :param ignore_kind: (bool) Set to True iff you want to ignore the position and keyword only kinds,</span>
<span class="sd">            in order to be able to accept args and kwargs in such a way that there can be cross-over</span>
<span class="sd">            (args that are supposed to be keyword only, and kwargs that are supposed to be positional only)</span>
<span class="sd">        :return: An {argname: argval, ...} dict</span>

<span class="sd">        See also the sorta-inverse of this function: args_and_kwargs_from_kwargs</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=&#39;YY&#39;, *, z: str = &#39;ZZ&#39;): ...</span>
<span class="sd">        &gt;&gt;&gt; sig = Sig(foo)</span>
<span class="sd">        &gt;&gt;&gt; assert (</span>
<span class="sd">        ...     sig.kwargs_from_args_and_kwargs((11, 22, &#39;you&#39;), dict(z=&#39;zoo&#39;))</span>
<span class="sd">        ...     == sig.kwargs_from_args_and_kwargs((11, 22), dict(y=&#39;you&#39;, z=&#39;zoo&#39;))</span>
<span class="sd">        ...     == {&#39;w&#39;: 11, &#39;x&#39;: 22, &#39;y&#39;: &#39;you&#39;, &#39;z&#39;: &#39;zoo&#39;})</span>

<span class="sd">        By default, `apply_defaults=False`, which will lead to only get those arguments you input.</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(11,), kwargs={&#39;x&#39;: 22})</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        But if you specify `apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(11,), kwargs={&#39;x&#39;: 22}, apply_defaults=True)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22, &#39;y&#39;: &#39;YY&#39;, &#39;z&#39;: &#39;ZZ&#39;}</span>

<span class="sd">        By default, `ignore_excess=False`, so specifying kwargs that are not in the signature will lead to an exception.</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(11,), kwargs={&#39;x&#39;: 22, &#39;not_in_sig&#39;: -1})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        TypeError: Got unexpected keyword arguments: not_in_sig</span>

<span class="sd">        Specifying `allow_excess=True` will ignore such excess fields of kwargs.</span>
<span class="sd">        This is useful when you want to source several functions from a same dict.</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(11,), kwargs={&#39;x&#39;: 22, &#39;not_in_sig&#39;: -1}, allow_excess=True)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        On the other side of `ignore_excess` you have `allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being completed later).</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(), kwargs={&#39;x&#39;: 22})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `allow_partial=True`...</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(), kwargs={&#39;x&#39;: 22}, allow_partial=True)</span>
<span class="sd">        {&#39;x&#39;: 22}</span>

<span class="sd">        That&#39;s a lot of control (eight combinations total), but not everything is controllable here:</span>
<span class="sd">        Position only and keyword only kinds need to be respected:</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(1, 2, 3, 4), kwargs={})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: too many positional arguments</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(), kwargs=dict(w=1, x=2, y=3, z=4))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        But if you want to ignore the kind of parameter, just say so:</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(1, 2, 3, 4), kwargs={}, ignore_kind=True)</span>
<span class="sd">        {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 4}</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(), kwargs=dict(w=1, x=2, y=3, z=4), ignore_kind=True)</span>
<span class="sd">        {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 4}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ignore_kind</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_kind</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">no_var_kw</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">sig</span><span class="o">.</span><span class="n">has_var_keyword</span>
        <span class="k">if</span> <span class="n">no_var_kw</span><span class="p">:</span>  <span class="c1"># has no var keyword kinds</span>
            <span class="n">sig_relevant_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sig</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>  <span class="c1"># take only what you need</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig_relevant_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>  <span class="c1"># take all the kwargs</span>

        <span class="n">binder</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind_partial</span> <span class="k">if</span> <span class="n">allow_partial</span> <span class="k">else</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">binder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">sig_relevant_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">apply_defaults</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">apply_defaults</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">no_var_kw</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_excess</span><span class="p">:</span>  <span class="c1"># don&#39;t ignore excess kwargs</span>
            <span class="n">excess</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">arguments</span>
            <span class="k">if</span> <span class="n">excess</span><span class="p">:</span>
                <span class="n">excess_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">excess</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got unexpected keyword arguments: </span><span class="si">{</span><span class="n">excess_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sig.args_and_kwargs_from_kwargs"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig.args_and_kwargs_from_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span>
                                    <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_excess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an (args, kwargs) tuple from the kwargs, where args contain the position only arguments.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">        ...     return ((w + x) * y) ** z</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).args_and_kwargs_from_kwargs(dict(w=4, x=3, y=2, z=1))</span>
<span class="sd">        &gt;&gt;&gt; assert (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: 1})</span>
<span class="sd">        &gt;&gt;&gt; assert foo(*args, **kwargs) == foo(4, 3, 2, z=1) == 14</span>

<span class="sd">        See kwargs_from_args_and_kwargs (namely for the description of the arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">position_only_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">PO</span><span class="p">}</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">position_only_names</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># kwargs = self.kwargs_from_args_and_kwargs(args, kwargs, apply_defaults, allow_partial, allow_excess)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">position_only_names</span><span class="p">}</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="n">apply_defaults</span><span class="p">,</span>
                                                  <span class="n">allow_partial</span><span class="o">=</span><span class="n">allow_partial</span><span class="p">,</span> <span class="n">allow_excess</span><span class="o">=</span><span class="n">allow_excess</span><span class="p">,</span>
                                                  <span class="n">ignore_kind</span><span class="o">=</span><span class="n">ignore_kind</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">position_only_names</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span></div>

<div class="viewcode-block" id="Sig.extract_kwargs"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig.extract_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">extract_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convenience method that calls kwargs_from_args_and_kwargs with defaults, and ignore_kind=True.</span>

<span class="sd">        Strict in the sense that the kwargs cannot contain any arguments that are not</span>
<span class="sd">        valid argument names (as per the signature).</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=&#39;YY&#39;, *, z: str = &#39;ZZ&#39;): ...</span>
<span class="sd">        &gt;&gt;&gt; sig = Sig(foo)</span>
<span class="sd">        &gt;&gt;&gt; assert (</span>
<span class="sd">        ...     sig.extract_kwargs(1, 2, 3, z=4)</span>
<span class="sd">        ...     == sig.extract_kwargs(1, 2, y=3, z=4)</span>
<span class="sd">        ...     == {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 4})</span>

<span class="sd">        What about var positional and var keywords?</span>
<span class="sd">        &gt;&gt;&gt; def bar(*args, **kwargs): ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(bar).extract_kwargs(1, 2, y=3, z=4)</span>
<span class="sd">        {&#39;args&#39;: (1, 2), &#39;kwargs&#39;: {&#39;y&#39;: 3, &#39;z&#39;: 4}}</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=11` as a keyword argument too (by default):</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(w=11, x=22)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(w=11, x=22, _ignore_kind=False)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being completed later).</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(x=3, y=2)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(x=3, y=2, _allow_partial=True)</span>
<span class="sd">        {&#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those arguments you input.</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(4, x=3, y=2)</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(4, x=3, y=2, _apply_defaults=True)</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: &#39;ZZ&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span> <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span> <span class="n">allow_excess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sig.extract_args_and_kwargs"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig.extract_args_and_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">extract_args_and_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Source the (args, kwargs) for the signature instance, ignoring excess arguments.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=2, *, z: int = 1):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(4, x=3, y=2)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        The difference with extract_kwargs is that here the output is ready to be called by the</span>
<span class="sd">        function whose signature we have, since the position-only arguments will be returned as</span>
<span class="sd">        args.</span>

<span class="sd">        &gt;&gt;&gt; foo(*args, **kwargs)</span>
<span class="sd">        10</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=4` as a keyword argument too (by default):</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(w=4, x=3, y=2)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_args_and_kwargs(w=4, x=3, y=2, _ignore_kind=False)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being completed later).</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_args_and_kwargs(x=3, y=2)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(x=3, y=2, _allow_partial=True)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those arguments you input.</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(4, x=3, y=2)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(4, x=3, y=2, _apply_defaults=True)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: 1})</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">_ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span> <span class="n">_allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
                                     <span class="n">_apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sig.source_kwargs"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig.source_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">source_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Source the kwargs for the signature instance, ignoring excess arguments.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=&#39;YY&#39;, *, z: str = &#39;ZZ&#39;): ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(11, x=22, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=11` as a keyword argument too (by default):</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(w=11, x=22, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(w=11, x=22, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _ignore_kind=False)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being completed later).</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _allow_partial=True)</span>
<span class="sd">        {&#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those arguments you input.</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _apply_defaults=True)</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: &#39;ZZ&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span> <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span> <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sig.source_args_and_kwargs"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.Sig.source_args_and_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">source_args_and_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Source the (args, kwargs) for the signature instance, ignoring excess arguments.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=2, *, z: int = 1):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        &gt;&gt;&gt;</span>

<span class="sd">        The difference with source_kwargs is that here the output is ready to be called by the</span>
<span class="sd">        function whose signature we have, since the position-only arguments will be returned as</span>
<span class="sd">        args.</span>

<span class="sd">        &gt;&gt;&gt; foo(*args, **kwargs)</span>
<span class="sd">        10</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=4` as a keyword argument too (by default):</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(w=4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_args_and_kwargs(w=4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _ignore_kind=False)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being completed later).</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_args_and_kwargs(x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _allow_partial=True)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those arguments you input.</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _apply_defaults=True)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: 1})</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
                                                  <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
                                                <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">)</span></div></div>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Recipes</span>

<div class="viewcode-block" id="mk_sig_from_args"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.mk_sig_from_args">[docs]</a><span class="k">def</span> <span class="nf">mk_sig_from_args</span><span class="p">(</span><span class="o">*</span><span class="n">args_without_default</span><span class="p">,</span> <span class="o">**</span><span class="n">args_with_defaults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a Signature instance by specifying args_without_default and args_with_defaults.</span>
<span class="sd">    &gt;&gt;&gt; mk_sig_from_args(&#39;a&#39;, &#39;b&#39;, c=1, d=&#39;bar&#39;)</span>
<span class="sd">    &lt;Signature (a, b, c=1, d=&#39;bar&#39;)&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args_without_default</span><span class="p">),</span> <span class="s2">&quot;all default-less arguments must be strings&quot;</span>
    <span class="k">return</span> <span class="n">Sig</span><span class="o">.</span><span class="n">from_objs</span><span class="p">(</span><span class="o">*</span><span class="n">args_without_default</span><span class="p">,</span> <span class="o">**</span><span class="n">args_with_defaults</span><span class="p">)</span><span class="o">.</span><span class="n">to_simple_signature</span><span class="p">()</span></div>


<div class="viewcode-block" id="call_forgivingly"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.call_forgivingly">[docs]</a><span class="k">def</span> <span class="nf">call_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Call function on giben args and kwargs, but only taking what the function needs</span>
<span class="sd">    (not choking if they&#39;re extras variables)&quot;&quot;&quot;</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">source_args_and_kwargs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">has_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">Sig</span><span class="o">.</span><span class="n">sig_or_none</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">number_of_required_arguments</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">defaults</span><span class="p">)</span>


<span class="c1">########################################################################################################################</span>
<span class="c1"># TODO: Encorporate in Sig</span>
<div class="viewcode-block" id="insert_annotations"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.insert_annotations">[docs]</a><span class="k">def</span> <span class="nf">insert_annotations</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Signature</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span> <span class="o">**</span><span class="n">annotations</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Insert annotations in a signature.</span>
<span class="sd">    (Note: not really insert but returns a copy of input signature)</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; s = signature(lambda a, b, c=1, d=&#39;bar&#39;: 0)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    &lt;Signature (a, b, c=1, d=&#39;bar&#39;)&gt;</span>
<span class="sd">    &gt;&gt;&gt; ss = insert_annotations(s, b=int, d=str)</span>
<span class="sd">    &gt;&gt;&gt; ss</span>
<span class="sd">    &lt;Signature (a, b: int, c=1, d: str = &#39;bar&#39;)&gt;</span>
<span class="sd">    &gt;&gt;&gt; insert_annotations(s, b=int, d=str, e=list)  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AssertionError: These argument names weren&#39;t found in the signature: {&#39;e&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="p">),</span> \
        <span class="sa">f</span><span class="s2">&quot;These argument names weren&#39;t found in the signature: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span></div>


<div class="viewcode-block" id="common_and_diff_argnames"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.common_and_diff_argnames">[docs]</a><span class="k">def</span> <span class="nf">common_and_diff_argnames</span><span class="p">(</span><span class="n">func1</span><span class="p">:</span> <span class="n">callable</span><span class="p">,</span> <span class="n">func2</span><span class="p">:</span> <span class="n">callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Get list of argument names that are common to two functions, as well as the two lists of names that are different</span>

<span class="sd">    Args:</span>
<span class="sd">        func1: First function</span>
<span class="sd">        func2: Second function</span>

<span class="sd">    Returns: A dict with fields &#39;common&#39;, &#39;func1_not_func2&#39;, and &#39;func2_not_func1&#39;</span>

<span class="sd">    &gt;&gt;&gt; def f(t, h, i, n, k): ...</span>
<span class="sd">    &gt;&gt;&gt; def g(t, w, i, c, e): ...</span>
<span class="sd">    &gt;&gt;&gt; common_and_diff_argnames(f, g)</span>
<span class="sd">    {&#39;common&#39;: [&#39;t&#39;, &#39;i&#39;], &#39;func1_not_func2&#39;: [&#39;h&#39;, &#39;n&#39;, &#39;k&#39;], &#39;func2_not_func1&#39;: [&#39;w&#39;, &#39;c&#39;, &#39;e&#39;]}</span>
<span class="sd">    &gt;&gt;&gt; common_and_diff_argnames(g, f)</span>
<span class="sd">    {&#39;common&#39;: [&#39;t&#39;, &#39;i&#39;], &#39;func1_not_func2&#39;: [&#39;w&#39;, &#39;c&#39;, &#39;e&#39;], &#39;func2_not_func1&#39;: [&#39;h&#39;, &#39;n&#39;, &#39;k&#39;]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func1</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func2</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;common&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p1</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p2</span><span class="p">],</span>
        <span class="s1">&#39;func1_not_func2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p1</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p2</span><span class="p">],</span>
        <span class="s1">&#39;func2_not_func1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p2</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p1</span><span class="p">],</span>
    <span class="p">}</span></div>


<span class="n">dflt_name_for_kind</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span> <span class="s1">&#39;args&#39;</span><span class="p">,</span>
    <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span> <span class="s1">&#39;kwargs&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">arg_order_for_param_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;annotation&#39;</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="set_signature_of_func"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.set_signature_of_func">[docs]</a><span class="k">def</span> <span class="nf">set_signature_of_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span> <span class="n">__validate_parameters__</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the signature of a function, with sugar.</span>

<span class="sd">    Args:</span>
<span class="sd">        func: Function whose signature you want to set</span>
<span class="sd">        signature: A list of parameter specifications. This could be an inspect.Parameter object or anything that</span>
<span class="sd">            the mk_param function can resolve into an inspect.Parameter object.</span>
<span class="sd">        return_annotation: Passed on to inspect.Signature.</span>
<span class="sd">        __validate_parameters__: Passed on to inspect.Signature.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None (but sets the signature of the input function)</span>

<span class="sd">    &gt;&gt;&gt; import inspect</span>
<span class="sd">    &gt;&gt;&gt; def foo(*args, **kwargs):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (*args, **kwargs)&gt;</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(foo, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (a, b, c)&gt;</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(foo, [&#39;a&#39;, (&#39;b&#39;, None), (&#39;c&#39;, 42, int)])  # specifying defaults and annotations</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (a, b=None, c: int = 42)&gt;</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(foo, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], return_annotation=str)  # specifying return annotation</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (a, b, c) -&gt; str&gt;</span>
<span class="sd">    &gt;&gt;&gt; # But you can always specify parameters the &quot;long&quot; way</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(</span>
<span class="sd">    ...  foo,</span>
<span class="sd">    ...  [inspect.Parameter(name=&#39;kws&#39;, kind=inspect.Parameter.VAR_KEYWORD)], return_annotation=str)</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (**kws) -&gt; str&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span>
              <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">,</span>
              <span class="n">__validate_parameters__</span><span class="o">=</span><span class="n">__validate_parameters__</span><span class="p">)</span>
    <span class="n">func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">to_simple_signature</span><span class="p">()</span></div>
    <span class="c1"># Not returning func so it&#39;s clear(er) that the function is transformed in place</span>


<span class="c1">############# Tools for testing ########################################################################################</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>


<div class="viewcode-block" id="param_for_kind"><a class="viewcode-back" href="../../../test.html#py2store.utils.signatures.param_for_kind">[docs]</a><span class="k">def</span> <span class="nf">param_for_kind</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;positional_or_keyword&#39;</span><span class="p">,</span> <span class="n">with_default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to easily and flexibly make inspect.Parameter objects for testing.</span>

<span class="sd">    It&#39;s annoying to have to compose parameters from scratch to testing things.</span>
<span class="sd">    This tool should help making it less annoying.</span>

<span class="sd">    &gt;&gt;&gt; from i2.signatures import param_kinds</span>
<span class="sd">    &gt;&gt;&gt; list(map(param_for_kind, param_kinds))</span>
<span class="sd">    [&lt;Parameter &quot;POSITIONAL_ONLY&quot;&gt;, &lt;Parameter &quot;POSITIONAL_OR_KEYWORD&quot;&gt;, &lt;Parameter &quot;VAR_POSITIONAL&quot;&gt;, &lt;Parameter &quot;KEYWORD_ONLY&quot;&gt;, &lt;Parameter &quot;VAR_KEYWORD&quot;&gt;]</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.positional_or_keyword()</span>
<span class="sd">    &lt;Parameter &quot;POSITIONAL_OR_KEYWORD&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.positional_or_keyword(&#39;foo&#39;)</span>
<span class="sd">    &lt;Parameter &quot;foo&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.keyword_only()</span>
<span class="sd">    &lt;Parameter &quot;KEYWORD_ONLY&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.keyword_only(&#39;baz&#39;, with_default=True)</span>
<span class="sd">    &lt;Parameter &quot;baz=&#39;dflt_keyword_only&#39;&quot;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">kind_obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
    <span class="n">kind</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">kind_obj</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">default</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;dflt_</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">with_default</span> <span class="ow">and</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;var_positional&#39;</span><span class="p">,</span> <span class="s1">&#39;var_keyword&#39;</span><span class="p">}</span> <span class="k">else</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
    <span class="k">return</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                     <span class="n">kind</span><span class="o">=</span><span class="n">kind_obj</span><span class="p">,</span>
                     <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span>
                     <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">)</span></div>


<span class="n">param_kinds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">))</span>

<span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">param_kinds</span><span class="p">:</span>
    <span class="n">lower_kind</span> <span class="o">=</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">lower_kind</span><span class="p">,</span>
            <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">))</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="s1">&#39;with_default&#39;</span><span class="p">,</span>
            <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">with_default</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">lower_kind</span><span class="p">),</span> <span class="s1">&#39;with_default&#39;</span><span class="p">,</span>
            <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">with_default</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="s1">&#39;with_default&#39;</span><span class="p">),</span> <span class="n">lower_kind</span><span class="p">,</span>
            <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">with_default</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">ch_signature_to_all_pk</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">changed_params</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_param_kinds</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">p</span>

    <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">changed_params</span><span class="p">()),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">sig</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">py2store</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html">py2store.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.misc">py2store.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.mixins">py2store.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.test.util">py2store.test.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-test-quick">py2store.test.quick</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.test">py2store.test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-test-simple">py2store.test.simple</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-test-scrap">py2store.test.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.util">py2store.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-ext-docx">py2store.ext.docx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.ext.gitlab">py2store.ext.gitlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-ext-hdf">py2store.ext.hdf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.ext">py2store.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-ext-matlab">py2store.ext.matlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.ext.kaggle">py2store.ext.kaggle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-ext-module-imports">py2store.ext.module_imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.ext.audio">py2store.ext.audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-ext-github">py2store.ext.github</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.ext.dataframes">py2store.ext.dataframes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.access">py2store.access</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.__init__">py2store.__init__</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.stores.s3_store">py2store.stores.s3_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.stores.delegation_stores">py2store.stores.delegation_stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.stores.sql_w_sqlalchemy">py2store.stores.sql_w_sqlalchemy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-stores-arangodb-store">py2store.stores.arangodb_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-stores-dropbox-store">py2store.stores.dropbox_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.stores.local_store">py2store.stores.local_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.stores">py2store.stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-stores-couchdb-store">py2store.stores.couchdb_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.stores.mongo_store">py2store.stores.mongo_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.core">py2store.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils.uri_utils">py2store.utils.uri_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils.explicit">py2store.utils.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils.timeseries_caching">py2store.utils.timeseries_caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-utils-attr-dict-py-attr-dict">py2store.utils.attr_dict.py.attr_dict</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-utils-attr-dict-py">py2store.utils.attr_dict.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils.cumul_aggreg_write">py2store.utils.cumul_aggreg_write</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils">py2store.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils.cache_descriptors">py2store.utils.cache_descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils.appendable">py2store.utils.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils.affine_conversion">py2store.utils.affine_conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils.signatures">py2store.utils.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils.sliceable">py2store.utils.sliceable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils.mappify">py2store.utils.mappify</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.utils.glom">py2store.utils.glom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-persisters-sql-w-odbc">py2store.persisters.sql_w_odbc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters.dynamodb_w_boto3">py2store.persisters.dynamodb_w_boto3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-persisters-couchdb-w-couchdb">py2store.persisters.couchdb_w_couchdb</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters.ftp_persister">py2store.persisters.ftp_persister</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters.dropbox_w_urllib">py2store.persisters.dropbox_w_urllib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters._google_drive_in_progress">py2store.persisters._google_drive_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-persisters-dropbox-w-dropbox">py2store.persisters.dropbox_w_dropbox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-persisters-redis-w-redis">py2store.persisters.redis_w_redis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters.sql_w_sqlalchemy">py2store.persisters.sql_w_sqlalchemy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters.new_s3">py2store.persisters.new_s3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters">py2store.persisters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters.dropbox_w_requests">py2store.persisters.dropbox_w_requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters.w_aiofile">py2store.persisters.w_aiofile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters.local_files">py2store.persisters.local_files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-persisters-arangodb-w-pyarango">py2store.persisters.arangodb_w_pyarango</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters._cassandra_in_progress">py2store.persisters._cassandra_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters._couchdb_in_progress">py2store.persisters._couchdb_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters.s3_w_boto3">py2store.persisters.s3_w_boto3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-persisters-postgres-w-psycopg2-in-progress">py2store.persisters._postgres_w_psycopg2_in_progress</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-persisters-ssh-persister">py2store.persisters.ssh_persister</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.persisters.mongo_w_pymongo">py2store.persisters.mongo_w_pymongo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-persisters-googledrive-w-pydrive">py2store.persisters.googledrive_w_pydrive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.sources">py2store.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.dig">py2store.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.serializers.pickled">py2store.serializers.pickled</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.serializers.jsonization">py2store.serializers.jsonization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.serializers">py2store.serializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.serializers.sequential">py2store.serializers.sequential</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.serializers.regular_panel_data">py2store.serializers.regular_panel_data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.serializers.audio">py2store.serializers.audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.caching">py2store.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.scrap">py2store.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.scrap.new_gen_local">py2store.scrap.new_gen_local</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.examples.write_caches">py2store.examples.write_caches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.examples">py2store.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.examples.python_code_stats">py2store.examples.python_code_stats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.examples.kv_walking">py2store.examples.kv_walking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.my">py2store.my</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.my.grabbers">py2store.my.grabbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.trans">py2store.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.key_mappers.str_utils">py2store.key_mappers.str_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.key_mappers.tuples">py2store.key_mappers.tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.key_mappers.paths">py2store.key_mappers.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.key_mappers.naming">py2store.key_mappers.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.key_mappers">py2store.key_mappers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.errors">py2store.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.slib.s_configparser">py2store.slib.s_configparser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.slib">py2store.slib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.slib.s_zipfile">py2store.slib.s_zipfile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.base">py2store.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-selectors-mg-selectors">py2store.selectors.mg_selectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-selectors-mongoquery">py2store.selectors.mongoquery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#py2store-selectors">py2store.selectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test.html#module-py2store.parse_format">py2store.parse_format</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  <li><a href="../../py2store.html">py2store</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>