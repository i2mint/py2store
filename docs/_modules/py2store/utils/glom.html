
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>py2store.utils.glom &#8212; py2store 0.1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for py2store.utils.glom</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;*glom is a util to extract stuff from nested structures.*</span>
<span class="sd">It&#39;s one of those excellent utils that I&#39;ve written many times, but never got quite right.</span>
<span class="sd">Mahmoud Hashemi got it right.</span>

<span class="sd">:BEGIN LICENSE:</span>

<span class="sd">Copyright (c) 2018, Mahmoud Hashemi</span>

<span class="sd">Redistribution and use in source and binary forms, with or without</span>
<span class="sd">modification, are permitted provided that the following conditions are</span>
<span class="sd">met:</span>

<span class="sd">    * Redistributions of source code must retain the above copyright</span>
<span class="sd">      notice, this list of conditions and the following disclaimer.</span>

<span class="sd">    * Redistributions in binary form must reproduce the above</span>
<span class="sd">      copyright notice, this list of conditions and the following</span>
<span class="sd">      disclaimer in the documentation and/or other materials provided</span>
<span class="sd">      with the distribution.</span>

<span class="sd">    * The names of the contributors may not be used to endorse or</span>
<span class="sd">      promote products derived from this software without specific</span>
<span class="sd">      prior written permission.</span>

<span class="sd">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="sd">&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="sd">LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="sd">A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="sd">OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="sd">SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="sd">LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="sd">DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="sd">THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="sd">(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="sd">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="sd">:END LICENSE:</span>


<span class="sd">Now, at the time of writing this, I&#39;ve already transformed it to bend it to my liking.</span>
<span class="sd">At some point it may become something else, but I wanted there to be a trace of what my seed was.</span>
<span class="sd">Though I can&#39;t promise I&#39;ll maintain the same functionality as I transform this module, here&#39;s</span>
<span class="sd">a tutorial on how to use it in it&#39;s original form:</span>
<span class="sd">    https://glom.readthedocs.io/en/latest/</span>


<span class="sd">I only took the main (core) module from the glom project.</span>
<span class="sd">Here&#39;s the original docs of this glom module.</span>

<span class="sd">If there was ever a Python example of &quot;big things come in small</span>
<span class="sd">packages&quot;, ``glom`` might be it.</span>

<span class="sd">The ``glom`` package has one central entrypoint,</span>
<span class="sd">:func:`glom.glom`. Everything else in the package revolves around that</span>
<span class="sd">one function.</span>

<span class="sd">A couple of conventional terms you&#39;ll see repeated many times below:</span>

<span class="sd">* **target** - glom is built to work on any data, so we simply</span>
<span class="sd">  refer to the object being accessed as the *&quot;target&quot;*</span>
<span class="sd">* **spec** - *(aka &quot;glomspec&quot;, short for specification)* The</span>
<span class="sd">  accompanying template used to specify the structure of the return</span>
<span class="sd">  value.</span>

<span class="sd">Now that you know the terms, let&#39;s take a look around glom&#39;s powerful</span>
<span class="sd">semantics.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pdb</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">ChainMap</span>

<span class="kn">from</span> <span class="nn">py2store.util</span> <span class="kn">import</span> <span class="n">format_invocation</span>

<span class="n">_AbstractIterableBase</span> <span class="o">=</span> <span class="n">ABCMeta</span><span class="p">(</span><span class="s1">&#39;_AbstractIterableBase&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{})</span>

<span class="n">_type_type</span> <span class="o">=</span> <span class="nb">type</span>


<div class="viewcode-block" id="make_sentinel"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.make_sentinel">[docs]</a><span class="k">def</span> <span class="nf">make_sentinel</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;_MISSING&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates and returns a new **instance** of a new class, suitable for</span>
<span class="sd">    usage as a &quot;sentinel&quot;, a kind of singleton often used to indicate</span>
<span class="sd">    a value is missing when ``None`` is a valid input.</span>

<span class="sd">    Args:</span>
<span class="sd">        name (str): Name of the Sentinel</span>
<span class="sd">        var_name (str): Set this name to the name of the variable in</span>
<span class="sd">            its respective module enable pickleability.</span>

<span class="sd">    &gt;&gt;&gt; make_sentinel(var_name=&#39;_MISSING&#39;)</span>
<span class="sd">    _MISSING</span>

<span class="sd">    The most common use cases here in boltons are as default values</span>
<span class="sd">    for optional function arguments, partly because of its</span>
<span class="sd">    less-confusing appearance in automatically generated</span>
<span class="sd">    documentation. Sentinels also function well as placeholders in queues</span>
<span class="sd">    and linked lists.</span>

<span class="sd">    .. note::</span>

<span class="sd">      By design, additional calls to ``make_sentinel`` with the same</span>
<span class="sd">      values will not produce equivalent objects.</span>

<span class="sd">      &gt;&gt;&gt; make_sentinel(&#39;TEST&#39;) == make_sentinel(&#39;TEST&#39;)</span>
<span class="sd">      False</span>
<span class="sd">      &gt;&gt;&gt; type(make_sentinel(&#39;TEST&#39;)) == type(make_sentinel(&#39;TEST&#39;))</span>
<span class="sd">      False</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">Sentinel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span> <span class="o">=</span> <span class="n">var_name</span>

        <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">var_name</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span>

        <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

    <span class="k">return</span> <span class="n">Sentinel</span><span class="p">()</span></div>


<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>


<div class="viewcode-block" id="is_iterable"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.is_iterable">[docs]</a><span class="k">def</span> <span class="nf">is_iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Similar in nature to :func:`callable`, ``is_iterable`` returns</span>
<span class="sd">    ``True`` if an object is `iterable`_, ``False`` if not.</span>
<span class="sd">    &gt;&gt;&gt; is_iterable([])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_iterable(1)</span>
<span class="sd">    False&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span></div>


<span class="n">_MISSING</span> <span class="o">=</span> <span class="n">make_sentinel</span><span class="p">(</span><span class="s1">&#39;_MISSING&#39;</span><span class="p">)</span>
<span class="n">SKIP</span> <span class="o">=</span> <span class="n">make_sentinel</span><span class="p">(</span><span class="s1">&#39;SKIP&#39;</span><span class="p">)</span>
<span class="n">SKIP</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">The ``SKIP`` singleton can be returned from a function or included</span>
<span class="s1">via a :class:`~glom.Literal` to cancel assignment into the output</span>
<span class="s1">object.</span>

<span class="s1">&gt;&gt;&gt; target = {&#39;a&#39;: &#39;b&#39;}</span>
<span class="s1">&gt;&gt;&gt; spec = {&#39;a&#39;: lambda t: t[&#39;a&#39;] if t[&#39;a&#39;] == &#39;a&#39; else SKIP}</span>
<span class="s1">&gt;&gt;&gt; glom(target, spec)</span>
<span class="si">{}</span><span class="s1"></span>
<span class="s1">&gt;&gt;&gt; target = {&#39;a&#39;: &#39;a&#39;}</span>
<span class="s1">&gt;&gt;&gt; glom(target, spec)</span>
<span class="s1">{&#39;a&#39;: &#39;a&#39;}</span>

<span class="s1">Mostly used to drop keys from dicts (as above) or filter objects from</span>
<span class="s1">lists.</span>

<span class="s1">.. note::</span>

<span class="s1">   SKIP was known as OMIT in versions 18.3.1 and prior. Versions 19+</span>
<span class="s1">   will remove the OMIT alias entirely.</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="n">OMIT</span> <span class="o">=</span> <span class="n">SKIP</span>  <span class="c1"># backwards compat, remove in 19+</span>

<span class="n">STOP</span> <span class="o">=</span> <span class="n">make_sentinel</span><span class="p">(</span><span class="s1">&#39;STOP&#39;</span><span class="p">)</span>
<span class="n">STOP</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">The ``STOP`` singleton can be used to halt iteration of a list or</span>
<span class="s1">execution of a tuple of subspecs.</span>

<span class="s1">&gt;&gt;&gt; target = range(10)</span>
<span class="s1">&gt;&gt;&gt; spec = [lambda x: x if x &lt; 5 else STOP]</span>
<span class="s1">&gt;&gt;&gt; glom(target, spec)</span>
<span class="s1">[0, 1, 2, 3, 4]</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="n">LAST_CHILD_SCOPE</span> <span class="o">=</span> <span class="n">make_sentinel</span><span class="p">(</span><span class="s1">&#39;LAST_CHILD_SCOPE&#39;</span><span class="p">)</span>
<span class="n">LAST_CHILD_SCOPE</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">Marker that can be used by parents to keep track of the last child</span>
<span class="s1">scope executed.  Useful for &quot;lifting&quot; results out of child scopes</span>
<span class="s1">for scopes that want to chain the scopes of their children together</span>
<span class="s1">similar to tuple.</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="n">MODE</span> <span class="o">=</span> <span class="n">make_sentinel</span><span class="p">(</span><span class="s1">&#39;MODE&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="GlomError"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.GlomError">[docs]</a><span class="k">class</span> <span class="nc">GlomError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The base exception for all the errors that might be raised from</span>
<span class="sd">    :func:`glom` processing logic.</span>

<span class="sd">    By default, exceptions raised from within functions passed to glom</span>
<span class="sd">    (e.g., ``len``, ``sum``, any ``lambda``) will not be wrapped in a</span>
<span class="sd">    GlomError.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="PathAccessError"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.PathAccessError">[docs]</a><span class="k">class</span> <span class="nc">PathAccessError</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">,</span> <span class="n">GlomError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This :exc:`GlomError` subtype represents a failure to access an</span>
<span class="sd">    attribute as dictated by the spec. The most commonly-seen error</span>
<span class="sd">    when using glom, it maintains a copy of the original exception and</span>
<span class="sd">    produces a readable error message for easy debugging.</span>

<span class="sd">    If you see this error, you may want to:</span>

<span class="sd">       * Check the target data is accurate using :class:`~glom.Inspect`</span>
<span class="sd">       * Catch the exception and return a semantically meaningful error message</span>
<span class="sd">       * Use :class:`glom.Coalesce` to specify a default</span>
<span class="sd">       * Use the top-level ``default`` kwarg on :func:`~glom.glom()`</span>

<span class="sd">    In any case, be glad you got this error and not the one it was</span>
<span class="sd">    wrapping!</span>

<span class="sd">    Args:</span>
<span class="sd">       exc (Exception): The error that arose when we tried to access</span>
<span class="sd">          *path*. Typically an instance of KeyError, AttributeError,</span>
<span class="sd">          IndexError, or TypeError, and sometimes others.</span>
<span class="sd">       path (Path): The full Path glom was in the middle of accessing</span>
<span class="sd">          when the error occurred.</span>
<span class="sd">       part_idx (int): The index of the part of the *path* that caused</span>
<span class="sd">          the error.</span>

<span class="sd">    &gt;&gt;&gt; target = {&#39;a&#39;: {&#39;b&#39;: None}}</span>
<span class="sd">    &gt;&gt;&gt; glom(target, &#39;a.b.c&#39;)  # doctest: +SKIP</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    glom.PathAccessError: could not access &#39;c&#39;, part 2 of Path(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), got error: ...</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">part_idx</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exc</span> <span class="o">=</span> <span class="n">exc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">part_idx</span> <span class="o">=</span> <span class="n">part_idx</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">part_idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;could not access </span><span class="si">%r</span><span class="s1">, part </span><span class="si">%r</span><span class="s1"> of </span><span class="si">%r</span><span class="s1">, got error: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">part_idx</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">part_idx</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exc</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="CoalesceError"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.CoalesceError">[docs]</a><span class="k">class</span> <span class="nc">CoalesceError</span><span class="p">(</span><span class="n">GlomError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This :exc:`GlomError` subtype is raised from within a</span>
<span class="sd">    :class:`Coalesce` spec&#39;s processing, when none of the subspecs</span>
<span class="sd">    match and no default is provided.</span>

<span class="sd">    The exception object itself keeps track of several values which</span>
<span class="sd">    may be useful for processing:</span>

<span class="sd">    Args:</span>
<span class="sd">       coal_obj (Coalesce): The original failing spec, see</span>
<span class="sd">          :class:`Coalesce`&#39;s docs for details.</span>
<span class="sd">       skipped (list): A list of ignored values and exceptions, in the</span>
<span class="sd">          order that their respective subspecs appear in the original</span>
<span class="sd">          *coal_obj*.</span>
<span class="sd">       path: Like many GlomErrors, this exception knows the path at</span>
<span class="sd">          which it occurred.</span>

<span class="sd">    &gt;&gt;&gt; target = {}</span>
<span class="sd">    &gt;&gt;&gt; glom(target, Coalesce(&#39;a&#39;, &#39;b&#39;))  # doctest: +SKIP</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    glom.CoalesceError: no valid values found. Tried (&#39;a&#39;, &#39;b&#39;) and got (PathAccessError, PathAccessError) ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coal_obj</span><span class="p">,</span> <span class="n">skipped</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coal_obj</span> <span class="o">=</span> <span class="n">coal_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipped</span> <span class="o">=</span> <span class="n">skipped</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coal_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">skipped</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">missed_specs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coal_obj</span><span class="o">.</span><span class="n">subspecs</span><span class="p">)</span>
        <span class="n">skipped_vals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">v</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coal_obj</span><span class="o">.</span><span class="n">skip_exc</span><span class="p">)</span>
            <span class="k">else</span> <span class="s1">&#39;&lt;skipped </span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="n">v</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">skipped</span>
        <span class="p">]</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;no valid values found. Tried </span><span class="si">%r</span><span class="s1"> and got (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">missed_specs</span><span class="p">,</span>
            <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">skipped_vals</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coal_obj</span><span class="o">.</span><span class="n">skip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_MISSING</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;, skip set to </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coal_obj</span><span class="o">.</span><span class="n">skip</span><span class="p">,)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coal_obj</span><span class="o">.</span><span class="n">skip_exc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">GlomError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;, skip_exc set to </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coal_obj</span><span class="o">.</span><span class="n">skip_exc</span><span class="p">,)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39; (at path </span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">msg</span></div>


<div class="viewcode-block" id="UnregisteredTarget"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.UnregisteredTarget">[docs]</a><span class="k">class</span> <span class="nc">UnregisteredTarget</span><span class="p">(</span><span class="n">GlomError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This :class:`GlomError` subtype is raised when a spec calls for an</span>
<span class="sd">    unsupported action on a target type. For instance, trying to</span>
<span class="sd">    iterate on an non-iterable target:</span>

<span class="sd">    &gt;&gt;&gt; glom(object(), [&#39;a.b.c&#39;])  # doctest: +SKIP</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    glom.UnregisteredTarget: target type &#39;object&#39; not registered for &#39;iterate&#39;, expected one of registered types: (...)</span>

<span class="sd">    It should be noted that this is a pretty uncommon occurrence in</span>
<span class="sd">    production glom usage. See the :ref:`setup-and-registration`</span>
<span class="sd">    section for details on how to avoid this error.</span>

<span class="sd">    An UnregisteredTarget takes and tracks a few values:</span>

<span class="sd">    Args:</span>
<span class="sd">       op (str): The name of the operation being performed (&#39;get&#39; or &#39;iterate&#39;)</span>
<span class="sd">       target_type (type): The type of the target being processed.</span>
<span class="sd">       type_map (dict): A mapping of target types that do support this operation</span>
<span class="sd">       path: The path at which the error occurred.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">target_type</span><span class="p">,</span> <span class="n">type_map</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_type</span> <span class="o">=</span> <span class="n">target_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_map</span> <span class="o">=</span> <span class="n">type_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="c1"># &lt;type %r&gt; is because Python 3 inexplicably changed the type</span>
        <span class="c1"># repr from &lt;type *&gt; to &lt;class *&gt;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%r</span><span class="s1">, &lt;type </span><span class="si">%r</span><span class="s1">&gt;, </span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">cn</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type_map</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="s2">&quot;glom() called without registering any types for operation &#39;</span><span class="si">%s</span><span class="s2">&#39;. see&quot;</span>
                <span class="s2">&quot; glom.register() or Glommer&#39;s constructor for details.&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="n">reg_types</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">h</span><span class="p">])</span>
        <span class="n">reg_types_str</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;()&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reg_types</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reg_types</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;target type </span><span class="si">%r</span><span class="s2"> not registered for &#39;</span><span class="si">%s</span><span class="s2">&#39;, expected one of&quot;</span>
            <span class="s1">&#39; registered types: </span><span class="si">%s</span><span class="s1">&#39;</span>
            <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">reg_types_str</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39; (at </span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">msg</span></div>


<div class="viewcode-block" id="Path"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Path">[docs]</a><span class="k">class</span> <span class="nc">Path</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Path objects specify explicit paths when the default</span>
<span class="sd">    ``&#39;a.b.c&#39;``-style general access syntax won&#39;t work or isn&#39;t</span>
<span class="sd">    desirable. Use this to wrap ints, datetimes, and other valid</span>
<span class="sd">    keys, as well as strings with dots that shouldn&#39;t be expanded.</span>

<span class="sd">    &gt;&gt;&gt; target = {&#39;a&#39;: {&#39;b&#39;: &#39;c&#39;, &#39;d.e&#39;: &#39;f&#39;, 2: 3}}</span>
<span class="sd">    &gt;&gt;&gt; glom(target, Path(&#39;a&#39;, 2))</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; glom(target, Path(&#39;a&#39;, &#39;d.e&#39;))</span>
<span class="sd">    &#39;f&#39;</span>

<span class="sd">    Paths can be used to join together other Path objects, as</span>
<span class="sd">    well as :data:`~glom.T` objects:</span>

<span class="sd">    &gt;&gt;&gt; Path(T[&#39;a&#39;], T[&#39;b&#39;])</span>
<span class="sd">    T[&#39;a&#39;][&#39;b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; Path(Path(&#39;a&#39;, &#39;b&#39;), Path(&#39;c&#39;, &#39;d&#39;))</span>
<span class="sd">    Path(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)</span>

<span class="sd">    Paths also support indexing and slicing, with each access</span>
<span class="sd">    returning a new Path object:</span>

<span class="sd">    &gt;&gt;&gt; path = Path(&#39;a&#39;, &#39;b&#39;, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; path[0]</span>
<span class="sd">    Path(&#39;a&#39;)</span>
<span class="sd">    &gt;&gt;&gt; path[-2:]</span>
<span class="sd">    Path(1, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">path_parts</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path_parts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path_t</span> <span class="o">=</span> <span class="n">T</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TType</span><span class="p">):</span>
            <span class="n">path_t</span> <span class="o">=</span> <span class="n">path_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">path_t</span> <span class="o">=</span> <span class="n">T</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">path_parts</span><span class="p">[</span><span class="n">offset</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">path_t</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">TType</span><span class="p">):</span>
                <span class="n">sub_parts</span> <span class="o">=</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="n">part</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sub_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">T</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;path segment must be path from T, not </span><span class="si">%r</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="n">sub_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_parts</span><span class="p">):</span>
                    <span class="n">path_t</span> <span class="o">=</span> <span class="n">_t_child</span><span class="p">(</span><span class="n">path_t</span><span class="p">,</span> <span class="n">sub_parts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sub_parts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">path_t</span> <span class="o">=</span> <span class="n">_t_child</span><span class="p">(</span><span class="n">path_t</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_t</span> <span class="o">=</span> <span class="n">path_t</span>

<div class="viewcode-block" id="Path.from_text"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Path.from_text">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_text</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a Path from .-delimited text:</span>

<span class="sd">        &gt;&gt;&gt; Path.from_text(&#39;a.b.c&#39;)</span>
<span class="sd">        Path(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">glomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="c1"># The entrypoint for the Path extension</span>
        <span class="k">return</span> <span class="n">_t_eval</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_t</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path_t</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Path</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path_t</span><span class="p">]</span> <span class="o">==</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">path_t</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">TType</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path_t</span><span class="p">]</span> <span class="o">==</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="n">other</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<div class="viewcode-block" id="Path.values"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Path.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of values referenced in this path.</span>

<span class="sd">        &gt;&gt;&gt; Path(T.a.b, &#39;c&#39;, T[&#39;d&#39;]).values()</span>
<span class="sd">        (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cur_t_path</span> <span class="o">=</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path_t</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cur_t_path</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span></div>

<div class="viewcode-block" id="Path.items"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Path.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of (operation, value) pairs.</span>

<span class="sd">        &gt;&gt;&gt; Path(T.a.b, &#39;c&#39;, T[&#39;d&#39;]).items()</span>
<span class="sd">        ((&#39;.&#39;, &#39;a&#39;), (&#39;.&#39;, &#39;b&#39;), (&#39;P&#39;, &#39;c&#39;), (&#39;[&#39;, &#39;d&#39;))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cur_t_path</span> <span class="o">=</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path_t</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cur_t_path</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">cur_t_path</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span></div>

    <span class="k">def</span> <span class="nf">startswith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">path_t</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;can only check if Path starts with string, Path or T&#39;</span>
            <span class="p">)</span>
        <span class="n">o_path</span> <span class="o">=</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="n">other</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path_t</span><span class="p">][:</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_path</span><span class="p">)]</span> <span class="o">==</span> <span class="n">o_path</span>

<div class="viewcode-block" id="Path.from_t"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Path.from_t">[docs]</a>    <span class="k">def</span> <span class="nf">from_t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the same path but starting from T&quot;&quot;&quot;</span>
        <span class="n">t_path</span> <span class="o">=</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path_t</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">t_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">S</span><span class="p">:</span>
            <span class="n">new_t</span> <span class="o">=</span> <span class="n">TType</span><span class="p">()</span>
            <span class="n">_T_PATHS</span><span class="p">[</span><span class="n">new_t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,)</span> <span class="o">+</span> <span class="n">t_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">new_t</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="n">cur_t_path</span> <span class="o">=</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path_t</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">step</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">start</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">stop</span>

            <span class="n">start</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">start</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="k">else</span> <span class="p">(</span><span class="n">start</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_t_path</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">stop</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                    <span class="k">else</span> <span class="p">(</span><span class="n">stop</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_t_path</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_t_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_t_path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Path index out of range&#39;</span><span class="p">)</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="k">else</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_t_path</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">new_t</span> <span class="o">=</span> <span class="n">TType</span><span class="p">()</span>
        <span class="n">new_path</span> <span class="o">=</span> <span class="n">cur_t_path</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">new_path</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">new_path</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))[::</span><span class="n">step</span><span class="p">]</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">new_path</span><span class="p">,</span> <span class="p">())</span>
        <span class="n">_T_PATHS</span><span class="p">[</span><span class="n">new_t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cur_t_path</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">new_path</span>
        <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">new_t</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_format_path</span><span class="p">(</span><span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path_t</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span></div>


<span class="k">def</span> <span class="nf">_format_path</span><span class="p">(</span><span class="n">t_path</span><span class="p">):</span>
    <span class="n">path_parts</span><span class="p">,</span> <span class="n">cur_t_path</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_path</span><span class="p">):</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">t_path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur_t_path</span><span class="p">:</span>
                <span class="n">path_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_t_path</span><span class="p">)</span>
                <span class="n">cur_t_path</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">path_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_t_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="n">cur_t_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path_parts</span> <span class="ow">and</span> <span class="n">cur_t_path</span><span class="p">:</span>
        <span class="n">path_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_t_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">path_parts</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">cur_t_path</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;Path(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">_format_t</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">path_parts</span>
            <span class="p">]</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">_format_t</span><span class="p">(</span><span class="n">cur_t_path</span><span class="p">)</span>


<div class="viewcode-block" id="Literal"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Literal">[docs]</a><span class="k">class</span> <span class="nc">Literal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Literal objects specify literal values in rare cases when part of</span>
<span class="sd">    the spec should not be interpreted as a glommable</span>
<span class="sd">    subspec. Wherever a Literal object is encountered in a spec, it is</span>
<span class="sd">    replaced with its wrapped *value* in the output.</span>

<span class="sd">    &gt;&gt;&gt; target = {&#39;a&#39;: {&#39;b&#39;: &#39;c&#39;}}</span>
<span class="sd">    &gt;&gt;&gt; spec = {&#39;a&#39;: &#39;a.b&#39;, &#39;readability&#39;: Literal(&#39;counts&#39;)}</span>
<span class="sd">    &gt;&gt;&gt; pprint(glom(target, spec))</span>
<span class="sd">    {&#39;a&#39;: &#39;c&#39;, &#39;readability&#39;: &#39;counts&#39;}</span>

<span class="sd">    Instead of accessing ``&#39;counts&#39;`` as a key like it did with</span>
<span class="sd">    ``&#39;a.b&#39;``, :func:`~glom.glom` just unwrapped the literal and</span>
<span class="sd">    included the value.</span>

<span class="sd">    :class:`~glom.Literal` takes one argument, the literal value that should appear</span>
<span class="sd">    in the glom output.</span>

<span class="sd">    This could also be achieved with a callable, e.g., ``lambda x:</span>
<span class="sd">    &#39;literal_string&#39;`` in the spec, but using a :class:`~glom.Literal`</span>
<span class="sd">    object adds explicitness, code clarity, and a clean :func:`repr`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">glomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Spec"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Spec">[docs]</a><span class="k">class</span> <span class="nc">Spec</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Spec objects serve three purposes, here they are, roughly ordered</span>
<span class="sd">    by utility:</span>

<span class="sd">      1. As a form of compiled or &quot;curried&quot; glom call, similar to</span>
<span class="sd">         Python&#39;s built-in :func:`re.compile`.</span>
<span class="sd">      2. A marker as an object as representing a spec rather than a</span>
<span class="sd">         literal value in certain cases where that might be ambiguous.</span>
<span class="sd">      3. A way to update the scope within another Spec.</span>

<span class="sd">    In the second usage, Spec objects are the complement to</span>
<span class="sd">    :class:`~glom.Literal`, wrapping a value and marking that it</span>
<span class="sd">    should be interpreted as a glom spec, rather than a literal value.</span>
<span class="sd">    This is useful in places where it would be interpreted as a value</span>
<span class="sd">    by default. (Such as T[key], Call(func) where key and func are</span>
<span class="sd">    assumed to be literal values and not specs.)</span>

<span class="sd">    Args:</span>
<span class="sd">        spec: The glom spec.</span>
<span class="sd">        scope (dict): additional values to add to the scope when</span>
<span class="sd">          evaluating this Spec</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">glom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">)</span>
        <span class="n">scope</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scope&#39;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;scope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="n">glom_</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">glom</span><span class="p">,</span> <span class="n">glom</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">glom_</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">glomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="n">scope</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%r</span><span class="s1">, scope=</span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coalesce"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Coalesce">[docs]</a><span class="k">class</span> <span class="nc">Coalesce</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Coalesce objects specify fallback behavior for a list of</span>
<span class="sd">    subspecs.</span>

<span class="sd">    Subspecs are passed as positional arguments, and keyword arguments</span>
<span class="sd">    control defaults. Each subspec is evaluated in turn, and if none</span>
<span class="sd">    match, a :exc:`CoalesceError` is raised, or a default is returned,</span>
<span class="sd">    depending on the options used.</span>

<span class="sd">    .. note::</span>

<span class="sd">      This operation may seem very familar if you have experience with</span>
<span class="sd">      `SQL`_ or even `C# and others`_.</span>


<span class="sd">    In practice, this fallback behavior&#39;s simplicity is only surpassed</span>
<span class="sd">    by its utility:</span>

<span class="sd">    &gt;&gt;&gt; target = {&#39;c&#39;: &#39;d&#39;}</span>
<span class="sd">    &gt;&gt;&gt; glom(target, Coalesce(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">    &#39;d&#39;</span>

<span class="sd">    glom tries to get ``&#39;a&#39;`` from ``target``, but gets a</span>
<span class="sd">    KeyError. Rather than raise a :exc:`~glom.PathAccessError` as usual,</span>
<span class="sd">    glom *coalesces* into the next subspec, ``&#39;b&#39;``. The process</span>
<span class="sd">    repeats until it gets to ``&#39;c&#39;``, which returns our value,</span>
<span class="sd">    ``&#39;d&#39;``. If our value weren&#39;t present, we&#39;d see:</span>

<span class="sd">    &gt;&gt;&gt; target = {}</span>
<span class="sd">    &gt;&gt;&gt; glom(target, Coalesce(&#39;a&#39;, &#39;b&#39;))  # doctest: +SKIP</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    glom.CoalesceError: no valid values found. Tried (&#39;a&#39;, &#39;b&#39;) and got (PathAccessError, PathAccessError) (at path [])</span>

<span class="sd">    Same process, but because ``target`` is empty, we get a</span>
<span class="sd">    :exc:`CoalesceError`. If we want to avoid an exception, and we</span>
<span class="sd">    know which value we want by default, we can set *default*:</span>

<span class="sd">    &gt;&gt;&gt; target = {}</span>
<span class="sd">    &gt;&gt;&gt; glom(target, Coalesce(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), default=&#39;d-fault&#39;)</span>
<span class="sd">    &#39;d-fault&#39;</span>

<span class="sd">    ``&#39;a&#39;``, ``&#39;b&#39;``, and ``&#39;c&#39;`` weren&#39;t present so we got ``&#39;d-fault&#39;``.</span>

<span class="sd">    Args:</span>

<span class="sd">       subspecs: One or more glommable subspecs</span>
<span class="sd">       default: A value to return if no subspec results in a valid value</span>
<span class="sd">       default_factory: A callable whose result will be returned as a default</span>
<span class="sd">       skip: A value, tuple of values, or predicate function</span>
<span class="sd">         representing values to ignore</span>
<span class="sd">       skip_exc: An exception or tuple of exception types to catch and</span>
<span class="sd">         move on to the next subspec. Defaults to :exc:`GlomError`, the</span>
<span class="sd">         parent type of all glom runtime exceptions.</span>

<span class="sd">    If all subspecs produce skipped values or exceptions, a</span>
<span class="sd">    :exc:`CoalesceError` will be raised. For more examples, check out</span>
<span class="sd">    the :doc:`tutorial`, which makes extensive use of Coalesce.</span>

<span class="sd">    .. _SQL: https://en.wikipedia.org/w/index.php?title=Null_(SQL)&amp;oldid=833093792#COALESCE</span>
<span class="sd">    .. _C# and others: https://en.wikipedia.org/w/index.php?title=Null_coalescing_operator&amp;oldid=839493322#C#</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">subspecs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspecs</span> <span class="o">=</span> <span class="n">subspecs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">_MISSING</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_factory</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;default_factory&#39;</span><span class="p">,</span> <span class="n">_MISSING</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_factory</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;expected one of &quot;default&quot; or &quot;default_factory&quot;, not both&#39;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;skip&#39;</span><span class="p">,</span> <span class="n">_MISSING</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip</span> <span class="ow">is</span> <span class="n">_MISSING</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skip</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skip</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_exc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;skip_exc&#39;</span><span class="p">,</span> <span class="n">GlomError</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;unexpected keyword args: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()),)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">glomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="n">skipped</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">subspec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspecs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="n">subspec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_func</span><span class="p">(</span><span class="n">ret</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="n">skipped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_exc</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">skipped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_MISSING</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_factory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_MISSING</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_factory</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CoalesceError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skipped</span><span class="p">,</span> <span class="n">scope</span><span class="p">[</span><span class="n">Path</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="n">format_invocation</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspecs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Inspect"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Inspect">[docs]</a><span class="k">class</span> <span class="nc">Inspect</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The :class:`~glom.Inspect` specifier type provides a way to get</span>
<span class="sd">    visibility into glom&#39;s evaluation of a specification, enabling</span>
<span class="sd">    debugging of those tricky problems that may arise with unexpected</span>
<span class="sd">    data.</span>

<span class="sd">    :class:`~glom.Inspect` can be inserted into an existing spec in one of two</span>
<span class="sd">    ways. First, as a wrapper around the spec in question, or second,</span>
<span class="sd">    as an argument-less placeholder wherever a spec could be.</span>

<span class="sd">    :class:`~glom.Inspect` supports several modes, controlled by</span>
<span class="sd">    keyword arguments. Its default, no-argument mode, simply echos the</span>
<span class="sd">    state of the glom at the point where it appears:</span>

<span class="sd">      &gt;&gt;&gt; target = {&#39;a&#39;: {&#39;b&#39;: {}}}</span>
<span class="sd">      &gt;&gt;&gt; val = glom(target, Inspect(&#39;a.b&#39;))  # wrapping a spec</span>
<span class="sd">      ---</span>
<span class="sd">      path:   [&#39;a.b&#39;]</span>
<span class="sd">      target: {&#39;a&#39;: {&#39;b&#39;: {}}}</span>
<span class="sd">      output: {}</span>
<span class="sd">      ---</span>

<span class="sd">    Debugging behavior aside, :class:`~glom.Inspect` has no effect on</span>
<span class="sd">    values in the target, spec, or result.</span>

<span class="sd">    Args:</span>
<span class="sd">       echo (bool): Whether to print the path, target, and output of</span>
<span class="sd">         each inspected glom. Defaults to True.</span>
<span class="sd">       recursive (bool): Whether or not the Inspect should be applied</span>
<span class="sd">         at every level, at or below the spec that it wraps. Defaults</span>
<span class="sd">         to False.</span>
<span class="sd">       breakpoint (bool): This flag controls whether a debugging prompt</span>
<span class="sd">         should appear before evaluating each inspected spec. Can also</span>
<span class="sd">         take a callable. Defaults to False.</span>
<span class="sd">       post_mortem (bool): This flag controls whether exceptions</span>
<span class="sd">         should be caught and interactively debugged with :mod:`pdb` on</span>
<span class="sd">         inspected specs.</span>

<span class="sd">    All arguments above are keyword-only to avoid overlap with a</span>
<span class="sd">    wrapped spec.</span>

<span class="sd">    .. note::</span>

<span class="sd">       Just like ``pdb.set_trace()``, be careful about leaving stray</span>
<span class="sd">       ``Inspect()`` instances in production glom specs.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span> <span class="k">else</span> <span class="n">Path</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recursive</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;recursive&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">echo</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;echo&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">breakpoint</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;breakpoint&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">breakpoint</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">breakpoint</span> <span class="o">=</span> <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span>
        <span class="k">if</span> <span class="n">breakpoint</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">breakpoint</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;breakpoint expected bool or callable, not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">breakpoint</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint</span> <span class="o">=</span> <span class="n">breakpoint</span>
        <span class="n">post_mortem</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;post_mortem&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">post_mortem</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">post_mortem</span> <span class="o">=</span> <span class="n">pdb</span><span class="o">.</span><span class="n">post_mortem</span>
        <span class="k">if</span> <span class="n">post_mortem</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">post_mortem</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;post_mortem expected bool or callable, not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">post_mortem</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_mortem</span> <span class="o">=</span> <span class="n">post_mortem</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;INSPECT&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">glomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="c1"># stash the real handler under Inspect,</span>
        <span class="c1"># and replace the child handler with a trace callback</span>
        <span class="n">scope</span><span class="p">[</span><span class="n">Inspect</span><span class="p">]</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">]</span>
        <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span>
        <span class="k">return</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">recursive</span><span class="p">:</span>
            <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">]</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">Inspect</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">echo</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;---&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;path:  &#39;</span><span class="p">,</span> <span class="n">scope</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">spec</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;target:&#39;</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">Inspect</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_mortem</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">post_mortem</span><span class="p">()</span>
            <span class="k">raise</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">echo</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;output:&#39;</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;---&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Call"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Call">[docs]</a><span class="k">class</span> <span class="nc">Call</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;:class:`Call` specifies when a target should be passed to a function,</span>
<span class="sd">    *func*.</span>

<span class="sd">    :class:`Call` is similar to :func:`~functools.partial` in that</span>
<span class="sd">    it is no more powerful than ``lambda`` or other functions, but</span>
<span class="sd">    it is designed to be more readable, with a better ``repr``.</span>

<span class="sd">    Args:</span>
<span class="sd">       func (callable): a function or other callable to be called with</span>
<span class="sd">          the target</span>

<span class="sd">    :class:`Call` combines well with :attr:`~glom.T` to construct objects. For</span>
<span class="sd">    instance, to generate a dict and then pass it to a constructor:</span>

<span class="sd">    &gt;&gt;&gt; class ExampleClass(object):</span>
<span class="sd">    ...    def __init__(self, attr):</span>
<span class="sd">    ...        self.attr = attr</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; target = {&#39;attr&#39;: 3.14}</span>
<span class="sd">    &gt;&gt;&gt; glom(target, Call(ExampleClass, kwargs=T)).attr</span>
<span class="sd">    3.14</span>

<span class="sd">    This does the same as ``glom(target, lambda target:</span>
<span class="sd">    ExampleClass(**target))``, but it&#39;s easy to see which one reads</span>
<span class="sd">    better.</span>

<span class="sd">    .. note::</span>

<span class="sd">       ``Call`` is mostly for functions. Use a :attr:`~glom.T` object</span>
<span class="sd">       if you need to call a method.</span>

<span class="sd">    .. warning::</span>

<span class="sd">       :class:`Call` has a successor with a fuller-featured API, new</span>
<span class="sd">       in 19.3.0: the :class:`Invoke` specifier type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">T</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="n">Spec</span><span class="p">,</span> <span class="n">TType</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;expected func to be a callable or T&#39;</span>
                <span class="s1">&#39; expression, not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">func</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="Call.glomit"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Call.glomit">[docs]</a>    <span class="k">def</span> <span class="nf">glomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="s1">&#39;run against the current target&#39;</span>

        <span class="k">def</span> <span class="nf">_eval</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Spec</span><span class="p">,</span> <span class="n">TType</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">t</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="ow">is</span> <span class="n">TType</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">_eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">_eval</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="ow">is</span> <span class="n">TType</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">_eval</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">_eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%r</span><span class="s1">, args=</span><span class="si">%r</span><span class="s1">, kwargs=</span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">cn</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_is_spec</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># a little util for codifying the spec type checking in glom</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">TType</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Spec</span>
    <span class="c1"># TODO: revisit line below</span>
    <span class="k">return</span> <span class="n">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;glomit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">obj</span><span class="p">,</span> <span class="nb">type</span>
    <span class="p">)</span>  <span class="c1"># pragma: no cover</span>


<div class="viewcode-block" id="Invoke"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Invoke">[docs]</a><span class="k">class</span> <span class="nc">Invoke</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Specifier type designed for easy invocation of callables from glom.</span>

<span class="sd">    Args:</span>
<span class="sd">      func (callable): A function or other callable object.</span>

<span class="sd">    ``Invoke`` is similar to :func:`functools.partial`, but with the</span>
<span class="sd">    ability to set up a &quot;templated&quot; call which interleaves constants and</span>
<span class="sd">    glom specs.</span>

<span class="sd">    For example, the following creates a spec which can be used to</span>
<span class="sd">    check if targets are integers:</span>

<span class="sd">    &gt;&gt;&gt; is_int = Invoke(isinstance).specs(T).constants(int)</span>
<span class="sd">    &gt;&gt;&gt; glom(5, is_int)</span>
<span class="sd">    True</span>

<span class="sd">    And this composes like any other glom spec:</span>

<span class="sd">    &gt;&gt;&gt; target = [7, object(), 9]</span>
<span class="sd">    &gt;&gt;&gt; glom(target, [is_int])</span>
<span class="sd">    [True, False, True]</span>

<span class="sd">    Another example, mixing positional and keyword arguments:</span>

<span class="sd">    &gt;&gt;&gt; spec = Invoke(sorted).specs(T).constants(key=int, reverse=True)</span>
<span class="sd">    &gt;&gt;&gt; target = [&#39;10&#39;, &#39;5&#39;, &#39;20&#39;, &#39;1&#39;]</span>
<span class="sd">    &gt;&gt;&gt; glom(target, spec)</span>
<span class="sd">    [&#39;20&#39;, &#39;10&#39;, &#39;5&#39;, &#39;1&#39;]</span>

<span class="sd">    Invoke also helps with evaluating zero-argument functions:</span>

<span class="sd">    &gt;&gt;&gt; glom(target={}, spec=Invoke(int))</span>
<span class="sd">    0</span>

<span class="sd">    (A trivial example, but from timestamps to UUIDs, zero-arg calls do come up!)</span>

<span class="sd">    .. note::</span>

<span class="sd">       ``Invoke`` is mostly for functions, object construction, and callable</span>
<span class="sd">       objects. For calling methods, consider the :attr:`~glom.T` object.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_spec</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;expected func to be a callable or Spec instance,&#39;</span>
                <span class="s1">&#39; not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">func</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="p">()</span>
        <span class="c1"># a registry of every known kwarg to its freshest value as set</span>
        <span class="c1"># by the methods below. the **kw dict is used as a unique marker.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cur_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Invoke.specfunc"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Invoke.specfunc">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">specfunc</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an :class:`Invoke` instance where the function is</span>
<span class="sd">        indicated by a spec.</span>

<span class="sd">        &gt;&gt;&gt; spec = Invoke.specfunc(&#39;func&#39;).constants(5)</span>
<span class="sd">        &gt;&gt;&gt; glom({&#39;func&#39;: range}, (spec, list))</span>
<span class="sd">        [0, 1, 2, 3, 4]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">Spec</span><span class="p">(</span><span class="n">spec</span><span class="p">))</span></div>

<div class="viewcode-block" id="Invoke.constants"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Invoke.constants">[docs]</a>    <span class="k">def</span> <span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a new :class:`Invoke` spec, with the provided positional</span>
<span class="sd">        and keyword argument values stored for passing to the</span>
<span class="sd">        underlying function.</span>

<span class="sd">        &gt;&gt;&gt; spec = Invoke(T).constants(5)</span>
<span class="sd">        &gt;&gt;&gt; glom(range, (spec, list))</span>
<span class="sd">        [0, 1, 2, 3, 4]</span>

<span class="sd">        Subsequent positional arguments are appended:</span>

<span class="sd">        &gt;&gt;&gt; spec = Invoke(T).constants(2).constants(10, 2)</span>
<span class="sd">        &gt;&gt;&gt; glom(range, (spec, list))</span>
<span class="sd">        [2, 4, 6, 8]</span>

<span class="sd">        Keyword arguments also work as one might expect:</span>

<span class="sd">        &gt;&gt;&gt; round_2 = Invoke(round).constants(ndigits=2).specs(T)</span>
<span class="sd">        &gt;&gt;&gt; glom(3.14159, round_2)</span>
<span class="sd">        3.14</span>

<span class="sd">        :meth:`~Invoke.constants()` and other :class:`Invoke`</span>
<span class="sd">        methods may be called multiple times, just remember that every</span>
<span class="sd">        call returns a new spec.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_cur_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cur_kwargs</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_cur_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">kw</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Invoke.specs"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Invoke.specs">[docs]</a>    <span class="k">def</span> <span class="nf">specs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a new :class:`Invoke` spec, with the provided positional</span>
<span class="sd">        and keyword arguments stored to be interpreted as specs, with</span>
<span class="sd">        the results passed to the underlying function.</span>

<span class="sd">        &gt;&gt;&gt; spec = Invoke(range).specs(&#39;value&#39;)</span>
<span class="sd">        &gt;&gt;&gt; glom({&#39;value&#39;: 5}, (spec, list))</span>
<span class="sd">        [0, 1, 2, 3, 4]</span>

<span class="sd">        Subsequent positional arguments are appended:</span>

<span class="sd">        &gt;&gt;&gt; spec = Invoke(range).specs(&#39;start&#39;).specs(&#39;end&#39;, &#39;step&#39;)</span>
<span class="sd">        &gt;&gt;&gt; target = {&#39;start&#39;: 2, &#39;end&#39;: 10, &#39;step&#39;: 2}</span>
<span class="sd">        &gt;&gt;&gt; glom(target, (spec, list))</span>
<span class="sd">        [2, 4, 6, 8]</span>

<span class="sd">        Keyword arguments also work as one might expect:</span>

<span class="sd">        &gt;&gt;&gt; multiply = lambda x, y: x * y</span>
<span class="sd">        &gt;&gt;&gt; times_3 = Invoke(multiply).constants(y=3).specs(x=&#39;value&#39;)</span>
<span class="sd">        &gt;&gt;&gt; glom({&#39;value&#39;: 5}, times_3)</span>
<span class="sd">        15</span>

<span class="sd">        :meth:`~Invoke.specs()` and other :class:`Invoke`</span>
<span class="sd">        methods may be called multiple times, just remember that every</span>
<span class="sd">        call returns a new spec.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_cur_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cur_kwargs</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_cur_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">kw</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Invoke.star"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Invoke.star">[docs]</a>    <span class="k">def</span> <span class="nf">star</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a new :class:`Invoke` spec, with *args* and/or *kwargs*</span>
<span class="sd">        specs set to be &quot;starred&quot; or &quot;star-starred&quot; (respectively)</span>

<span class="sd">        &gt;&gt;&gt; import os.path</span>
<span class="sd">        &gt;&gt;&gt; spec = Invoke(os.path.join).star(args=&#39;path&#39;)</span>
<span class="sd">        &gt;&gt;&gt; target = {&#39;path&#39;: [&#39;path&#39;, &#39;to&#39;, &#39;dir&#39;]}</span>
<span class="sd">        &gt;&gt;&gt; glom(target, spec)</span>
<span class="sd">        &#39;path/to/dir&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">           args (spec): A spec to be evaluated and &quot;starred&quot; into the</span>
<span class="sd">              underlying function.</span>
<span class="sd">           kwargs (spec): A spec to be evaluated and &quot;star-starred&quot; into</span>
<span class="sd">              the underlying function.</span>

<span class="sd">        One or both of the above arguments should be set.</span>

<span class="sd">        The :meth:`~Invoke.star()`, like other :class:`Invoke`</span>
<span class="sd">        methods, may be called multiple times. The *args* and *kwargs*</span>
<span class="sd">        will be stacked in the order in which they are provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;expected one or both of args/kwargs to be passed&#39;</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_cur_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cur_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
        <span class="n">fname_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="s1">&#39;constants&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="s1">&#39;specs&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="s1">&#39;star&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Spec</span><span class="p">:</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;.specfunc(</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">spec</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;(</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">op</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="p">:</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">fname_map</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;.</span><span class="si">{}</span><span class="s1">(&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">):</span>
                <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
                        <span class="o">+</span> <span class="p">[</span>
                            <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="n">kwargs</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;args=&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;kwargs=&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">glomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="n">all_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">recurse</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">spec</span><span class="p">:</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">recurse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_is_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">op</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="p">:</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                <span class="n">all_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                <span class="n">all_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="n">kwargs</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
                <span class="n">all_args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">recurse</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
                <span class="n">all_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">k</span><span class="p">:</span> <span class="n">recurse</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="n">kwargs</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">all_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">recurse</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">all_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">recurse</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">all_args</span><span class="p">,</span> <span class="o">**</span><span class="n">all_kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TType"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.TType">[docs]</a><span class="k">class</span> <span class="nc">TType</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;``T``, short for &quot;target&quot;. A singleton object that enables</span>
<span class="sd">    object-oriented expression of a glom specification.</span>

<span class="sd">    .. note::</span>

<span class="sd">       ``T`` is a singleton, and does not need to be constructed.</span>

<span class="sd">    Basically, think of ``T`` as your data&#39;s stunt double. Everything</span>
<span class="sd">    that you do to ``T`` will be recorded and executed during the</span>
<span class="sd">    :func:`glom` call. Take this example:</span>

<span class="sd">    &gt;&gt;&gt; spec = T[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; target = {&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: &#39;d&#39;}}}</span>
<span class="sd">    &gt;&gt;&gt; glom(target, spec)</span>
<span class="sd">    &#39;d&#39;</span>

<span class="sd">    So far, we&#39;ve relied on the ``&#39;a.b.c&#39;``-style shorthand for</span>
<span class="sd">    access, or used the :class:`~glom.Path` objects, but if you want</span>
<span class="sd">    to explicitly do attribute and key lookups, look no further than</span>
<span class="sd">    ``T``.</span>

<span class="sd">    But T doesn&#39;t stop with unambiguous access. You can also call</span>
<span class="sd">    methods and perform almost any action you would with a normal</span>
<span class="sd">    object:</span>

<span class="sd">    &gt;&gt;&gt; spec = (&#39;a&#39;, (T[&#39;b&#39;].items(), list))  # reviewed below</span>
<span class="sd">    &gt;&gt;&gt; glom(target, spec)</span>
<span class="sd">    [(&#39;c&#39;, &#39;d&#39;)]</span>

<span class="sd">    A ``T`` object can go anywhere in the spec. As seen in the example</span>
<span class="sd">    above, we access ``&#39;a&#39;``, use a ``T`` to get ``&#39;b&#39;`` and iterate</span>
<span class="sd">    over its ``items``, turning them into a ``list``.</span>

<span class="sd">    You can even use ``T`` with :class:`~glom.Call` to construct objects:</span>

<span class="sd">    &gt;&gt;&gt; class ExampleClass(object):</span>
<span class="sd">    ...    def __init__(self, attr):</span>
<span class="sd">    ...        self.attr = attr</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; target = {&#39;attr&#39;: 3.14}</span>
<span class="sd">    &gt;&gt;&gt; glom(target, Call(ExampleClass, kwargs=T)).attr</span>
<span class="sd">    3.14</span>

<span class="sd">    On a further note, while ``lambda`` works great in glom specs, and</span>
<span class="sd">    can be very handy at times, ``T`` and :class:`~glom.Call`</span>
<span class="sd">    eliminate the need for the vast majority of ``lambda`` usage with</span>
<span class="sd">    glom.</span>

<span class="sd">    Unlike ``lambda`` and other functions, ``T`` roundtrips</span>
<span class="sd">    beautifully and transparently:</span>

<span class="sd">    &gt;&gt;&gt; T[&#39;a&#39;].b[&#39;c&#39;](&#39;success&#39;)</span>
<span class="sd">    T[&#39;a&#39;].b[&#39;c&#39;](&#39;success&#39;)</span>

<span class="sd">    ``T``-related access errors raise a :exc:`~glom.PathAccessError`</span>
<span class="sd">    during the :func:`~glom.glom` call.</span>

<span class="sd">    .. note::</span>

<span class="sd">       While ``T`` is clearly useful, powerful, and here to stay, its</span>
<span class="sd">       semantics are still being refined. Currently, operations beyond</span>
<span class="sd">       method calls and attribute/item access are considered</span>
<span class="sd">       experimental and should not be relied upon.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__weakref__&#39;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;T instances reserve dunder attributes&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_t_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_t_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_t_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t_path</span> <span class="o">=</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_format_t</span><span class="p">(</span><span class="n">t_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">t_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t_path</span> <span class="o">=</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="s1">&#39;T&#39;</span> <span class="k">if</span> <span class="n">t_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">T</span> <span class="k">else</span> <span class="s1">&#39;S&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="n">t_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">_T_PATHS</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span> <span class="k">else</span> <span class="n">S</span><span class="p">,)</span> <span class="o">+</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span></div>


<span class="n">_T_PATHS</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_t_child</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">TType</span><span class="p">()</span>
    <span class="n">_T_PATHS</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>


<span class="k">def</span> <span class="nf">_t_eval</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">_t</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
    <span class="n">t_path</span> <span class="o">=</span> <span class="n">_T_PATHS</span><span class="p">[</span><span class="n">_t</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">t_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">T</span><span class="p">:</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">target</span>
    <span class="k">elif</span> <span class="n">t_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">S</span><span class="p">:</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">scope</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;TType instance with invalid root object&#39;</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_path</span><span class="p">):</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">t_path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Spec</span><span class="p">,</span> <span class="n">TType</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PathAccessError</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Path</span><span class="p">(</span><span class="n">_t</span><span class="p">),</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;[&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PathAccessError</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Path</span><span class="p">(</span><span class="n">_t</span><span class="p">),</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span>
            <span class="c1"># Path type stuff (fuzzy match)</span>
            <span class="n">get</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">TargetRegistry</span><span class="p">]</span><span class="o">.</span><span class="n">get_handler</span><span class="p">(</span>
                <span class="s1">&#39;get&#39;</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">t_path</span><span class="p">[</span><span class="mi">2</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">:</span> <span class="mi">2</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PathAccessError</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Path</span><span class="p">(</span><span class="n">_t</span><span class="p">),</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="n">scope</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span> <span class="o">+=</span> <span class="n">t_path</span><span class="p">[</span><span class="mi">2</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">:</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="n">Call</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">),</span> <span class="n">scope</span><span class="p">)</span>
            <span class="c1"># call with target rather than cur,</span>
            <span class="c1"># because it is probably more intuitive</span>
            <span class="c1"># if args to the call &quot;reset&quot; their path</span>
            <span class="c1"># e.g. &quot;T.a&quot; should mean the same thing</span>
            <span class="c1"># in both of these specs: T.a and T.b(T.a)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">cur</span>


<span class="n">T</span> <span class="o">=</span> <span class="n">TType</span><span class="p">()</span>  <span class="c1"># target aka Mr. T aka &quot;this&quot;</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TType</span><span class="p">()</span>  <span class="c1"># like T, but means grab stuff from Scope, not Target</span>

<span class="n">_T_PATHS</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,)</span>
<span class="n">_T_PATHS</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span><span class="p">,)</span>
<span class="n">UP</span> <span class="o">=</span> <span class="n">make_sentinel</span><span class="p">(</span><span class="s1">&#39;UP&#39;</span><span class="p">)</span>
<span class="n">ROOT</span> <span class="o">=</span> <span class="n">make_sentinel</span><span class="p">(</span><span class="s1">&#39;ROOT&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_format_invocation</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="c1"># TODO: add to boltons</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">a_text</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">kwarg_items</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kwarg_items</span> <span class="o">=</span> <span class="n">kwargs</span>
    <span class="n">kw_text</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwarg_items</span><span class="p">])</span>

    <span class="n">star_args_text</span> <span class="o">=</span> <span class="n">a_text</span>
    <span class="k">if</span> <span class="n">star_args_text</span> <span class="ow">and</span> <span class="n">kw_text</span><span class="p">:</span>
        <span class="n">star_args_text</span> <span class="o">+=</span> <span class="s1">&#39;, &#39;</span>
    <span class="n">star_args_text</span> <span class="o">+=</span> <span class="n">kw_text</span>

    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">star_args_text</span><span class="p">)</span>


<div class="viewcode-block" id="Let"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Let">[docs]</a><span class="k">class</span> <span class="nc">Let</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This specifier type assigns variables to the scope.</span>

<span class="sd">    &gt;&gt;&gt; target = {&#39;data&#39;: {&#39;val&#39;: 9}}</span>
<span class="sd">    &gt;&gt;&gt; spec = (Let(value=T[&#39;data&#39;][&#39;val&#39;]), {&#39;val&#39;: S[&#39;value&#39;]})</span>
<span class="sd">    &gt;&gt;&gt; glom(target, spec)</span>
<span class="sd">    {&#39;val&#39;: 9}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kw</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;expected at least one keyword argument&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binding</span> <span class="o">=</span> <span class="n">kw</span>

    <span class="k">def</span> <span class="nf">glomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="n">scope</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binding</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">target</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="n">_format_invocation</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_binding</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_format_t</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">T</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">kwarg_fmt</span><span class="p">(</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kw</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">kw</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>

    <span class="n">prepr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span> <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="n">T</span> <span class="k">else</span> <span class="s1">&#39;S&#39;</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
            <span class="n">prepr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;[&#39;</span><span class="p">:</span>
            <span class="n">prepr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%r</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="n">prepr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">)&#39;</span>
                <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
                    <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">kwarg_fmt</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_format_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">prepr</span><span class="p">)</span>


<div class="viewcode-block" id="CheckError"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.CheckError">[docs]</a><span class="k">class</span> <span class="nc">CheckError</span><span class="p">(</span><span class="n">GlomError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This :exc:`GlomError` subtype is raised when target data fails to</span>
<span class="sd">    pass a :class:`Check`&#39;s specified validation.</span>

<span class="sd">    An uncaught ``CheckError`` looks like this::</span>

<span class="sd">       &gt;&gt;&gt; target = {&#39;a&#39;: {&#39;b&#39;: &#39;c&#39;}}</span>
<span class="sd">       &gt;&gt;&gt; glom(target, {&#39;b&#39;: (&#39;a.b&#39;, Check(type=int))})  # doctest: +SKIP</span>
<span class="sd">       Traceback (most recent call last):</span>
<span class="sd">       ...</span>
<span class="sd">       glom.CheckError: target at path [&#39;a.b&#39;] failed check, got error: &quot;expected type to be &#39;int&#39;, found type &#39;str&#39;&quot;</span>


<span class="sd">    If the ``Check`` contains more than one condition, there may be</span>
<span class="sd">    more than one error message. The string rendition of the</span>
<span class="sd">    ``CheckError`` will include all messages.</span>

<span class="sd">    You can also catch the ``CheckError`` and programmatically access</span>
<span class="sd">    messages through the ``msgs`` attribute on the ``CheckError``</span>
<span class="sd">    instance.</span>

<span class="sd">    .. note::</span>

<span class="sd">       As of 2018-07-05 (glom v18.2.0), the validation subsystem is</span>
<span class="sd">       still very new. Exact error message formatting may be enhanced</span>
<span class="sd">       in future releases.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msgs</span><span class="p">,</span> <span class="n">check</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msgs</span> <span class="o">=</span> <span class="n">msgs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_obj</span> <span class="o">=</span> <span class="n">check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msgs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;target at path </span><span class="si">%s</span><span class="s1"> failed check,&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_obj</span><span class="o">.</span><span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">T</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39; subtarget at </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">check_obj</span><span class="o">.</span><span class="n">spec</span><span class="p">,)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msgs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39; got error: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msgs</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39; got </span><span class="si">%s</span><span class="s1"> errors: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msgs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">msgs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span></div>


<span class="n">RAISE</span> <span class="o">=</span> <span class="n">make_sentinel</span><span class="p">(</span><span class="s1">&#39;RAISE&#39;</span><span class="p">)</span>  <span class="c1"># flag object for &quot;raise on check failure&quot;</span>


<div class="viewcode-block" id="Check"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Check">[docs]</a><span class="k">class</span> <span class="nc">Check</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check objects are used to make assertions about the target data,</span>
<span class="sd">    and either pass through the data or raise exceptions if there is a</span>
<span class="sd">    problem.</span>

<span class="sd">    If any check condition fails, a :class:`~glom.CheckError` is raised.</span>

<span class="sd">    Args:</span>

<span class="sd">       spec: a sub-spec to extract the data to which other assertions will</span>
<span class="sd">          be checked (defaults to applying checks to the target itself)</span>
<span class="sd">       type: a type or sequence of types to be checked for exact match</span>
<span class="sd">       equal_to: a value to be checked for equality match (&quot;==&quot;)</span>
<span class="sd">       validate: a callable or list of callables, each representing a</span>
<span class="sd">          check condition. If one or more return False or raise an</span>
<span class="sd">          exception, the Check will fail.</span>
<span class="sd">       instance_of: a type or sequence of types to be checked with isinstance()</span>
<span class="sd">       one_of: an iterable of values, any of which can match the target (&quot;in&quot;)</span>
<span class="sd">       default: an optional default value to replace the value when the check fails</span>
<span class="sd">                (if default is not specified, GlomCheckError will be raised)</span>

<span class="sd">    Aside from *spec*, all arguments are keyword arguments. Each</span>
<span class="sd">    argument, except for *default*, represent a check</span>
<span class="sd">    condition. Multiple checks can be passed, and if all check</span>
<span class="sd">    conditions are left unset, Check defaults to performing a basic</span>
<span class="sd">    truthy check on the value.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: the next level of Check would be to play with the Scope to</span>
    <span class="c1"># allow checking to continue across the same level of</span>
    <span class="c1"># dictionary. Basically, collect as many errors as possible before</span>
    <span class="c1"># raising the unified CheckError.</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">RAISE</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_get_arg_val</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">can_be_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="n">_MISSING</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_iterable</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">,)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">val</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">can_be_empty</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;expected </span><span class="si">%r</span><span class="s1"> argument to contain at least one value,&#39;</span>
                    <span class="s1">&#39; not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">func</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;expected </span><span class="si">%r</span><span class="s1"> argument to be </span><span class="si">%s</span><span class="s1">, not: </span><span class="si">%r</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>

        <span class="c1"># if there are other common validation functions, maybe a</span>
        <span class="c1"># small set of special strings would work as valid arguments</span>
        <span class="c1"># to validate, too.</span>
        <span class="k">def</span> <span class="nf">truthy</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">validate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;validate&#39;</span><span class="p">,</span> <span class="n">_MISSING</span> <span class="k">if</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">truthy</span><span class="p">)</span>
        <span class="n">type_arg</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="n">_MISSING</span><span class="p">)</span>
        <span class="n">instance_of</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;instance_of&#39;</span><span class="p">,</span> <span class="n">_MISSING</span><span class="p">)</span>
        <span class="n">equal_to</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;equal_to&#39;</span><span class="p">,</span> <span class="n">_MISSING</span><span class="p">)</span>
        <span class="n">one_of</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;one_of&#39;</span><span class="p">,</span> <span class="n">_MISSING</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unexpected keyword arguments: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">validators</span> <span class="o">=</span> <span class="n">_get_arg_val</span><span class="p">(</span>
            <span class="s1">&#39;validate&#39;</span><span class="p">,</span> <span class="s1">&#39;callable&#39;</span><span class="p">,</span> <span class="n">callable</span><span class="p">,</span> <span class="n">validate</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance_of</span> <span class="o">=</span> <span class="n">_get_arg_val</span><span class="p">(</span>
            <span class="s1">&#39;instance_of&#39;</span><span class="p">,</span>
            <span class="s1">&#39;a type&#39;</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span>
            <span class="n">instance_of</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">_get_arg_val</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;a type&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="n">type_arg</span><span class="p">,</span> <span class="kc">False</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">equal_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_MISSING</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">equal_to</span><span class="p">,)</span>
            <span class="k">if</span> <span class="n">one_of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_MISSING</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;expected &quot;one_of&quot; argument to be unset when&#39;</span>
                    <span class="s1">&#39; &quot;equal_to&quot; argument is passed&#39;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">one_of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_MISSING</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_iterable</span><span class="p">(</span><span class="n">one_of</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;expected &quot;one_of&quot; argument to be iterable&#39;</span>
                    <span class="s1">&#39; , not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">one_of</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">one_of</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;expected &quot;one_of&quot; to contain at least&#39;</span>
                    <span class="s1">&#39; one value, not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">one_of</span><span class="p">,)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">one_of</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">return</span>

    <span class="k">class</span> <span class="nc">_ValidationError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
        <span class="s1">&#39;for internal use inside of Check only&#39;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">glomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">target</span>
        <span class="n">errs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">T</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">RAISE</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
            <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s1">&#39;expected type to be </span><span class="si">%r</span><span class="s1">, found type </span><span class="si">%r</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="k">else</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">]),</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="ow">and</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">RAISE</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s1">&#39;expected </span><span class="si">{}</span><span class="s1">, found </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s1">&#39;expected one of </span><span class="si">{}</span><span class="s1">, found </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">validators</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">validator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validators</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">validator</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ValidationError</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;expected </span><span class="si">%r</span><span class="s1"> check to validate target&#39;</span> <span class="o">%</span> <span class="nb">getattr</span><span class="p">(</span>
                        <span class="n">validator</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="kc">None</span>
                    <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;#</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ValidationError</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">RAISE</span><span class="p">:</span>
                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39; (got exception: </span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">e</span>
                    <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_of</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_of</span><span class="p">):</span>
            <span class="c1"># TODO: can these early returns be done without so much copy-paste?</span>
            <span class="c1"># (early return to avoid potentially expensive or even error-causeing</span>
            <span class="c1"># string formats)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">RAISE</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
            <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s1">&#39;expected instance of </span><span class="si">%r</span><span class="s1">, found instance of </span><span class="si">%r</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instance_of</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance_of</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="k">else</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_of</span><span class="p">]),</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">errs</span><span class="p">:</span>
            <span class="c1"># TODO: due to the usage of basic path (not a Path</span>
            <span class="c1"># object), the format can be a bit inconsistent here</span>
            <span class="c1"># (e.g., &#39;a.b&#39; and [&#39;a&#39;, &#39;b&#39;])</span>
            <span class="k">raise</span> <span class="n">CheckError</span><span class="p">(</span><span class="n">errs</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">[</span><span class="n">Path</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">posargs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">,)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">T</span> <span class="k">else</span> <span class="p">()</span>
        <span class="k">return</span> <span class="n">format_invocation</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="n">posargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Auto"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Auto">[docs]</a><span class="k">class</span> <span class="nc">Auto</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Switch to Auto mode (the default)</span>

<span class="sd">    TODO: this seems like it should be a sub-class of class Spec() --</span>
<span class="sd">    if Spec() could help define the interface for new &quot;modes&quot; or dialects</span>
<span class="sd">    that would also help make match mode feel less duct-taped on</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="k">def</span> <span class="nf">glomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="n">scope</span><span class="p">[</span><span class="n">MODE</span><span class="p">]</span> <span class="o">=</span> <span class="n">_glom_auto</span>
        <span class="k">return</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">rpr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="n">rpr</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_AbstractIterable</span><span class="p">(</span><span class="n">_AbstractIterableBase</span><span class="p">):</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__subclasshook__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">C</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_get_sequence_item</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">target</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span>


<span class="c1"># handlers are 3-arg callables, with args (spec, target, scope)</span>
<span class="c1"># spec is the first argument for convenience in the case</span>
<span class="c1"># that the handler is a method of the spec type</span>
<span class="k">def</span> <span class="nf">_handle_dict</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
        <span class="n">spec</span>
    <span class="p">)()</span>  <span class="c1"># TODO: works for dict + ordereddict, but sufficient for all?</span>
    <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">subspec</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="n">subspec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="n">SKIP</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Spec</span><span class="p">,</span> <span class="n">TType</span><span class="p">):</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">_handle_list</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
    <span class="n">subspec</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">iterate</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">TargetRegistry</span><span class="p">]</span><span class="o">.</span><span class="n">get_handler</span><span class="p">(</span>
        <span class="s1">&#39;iterate&#39;</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">scope</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="n">iterate</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;failed to iterate on instance of type </span><span class="si">%r</span><span class="s1"> at </span><span class="si">%r</span><span class="s1"> (got </span><span class="si">%r</span><span class="s1">)&#39;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">Path</span><span class="p">(</span><span class="o">*</span><span class="n">scope</span><span class="p">[</span><span class="n">Path</span><span class="p">]),</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">base_path</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
        <span class="n">scope</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_path</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">t</span><span class="p">,</span> <span class="n">subspec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="n">SKIP</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="n">STOP</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">_handle_tuple</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">target</span>
    <span class="k">for</span> <span class="n">subspec</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">:</span>
        <span class="n">nxt</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">res</span><span class="p">,</span> <span class="n">subspec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nxt</span> <span class="ow">is</span> <span class="n">SKIP</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">nxt</span> <span class="ow">is</span> <span class="n">STOP</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">nxt</span>
        <span class="c1"># this makes it so that specs in a tuple effectively nest.</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">[</span><span class="n">LAST_CHILD_SCOPE</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subspec</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">scope</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">subspec</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="n">subspec</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">res</span>


<div class="viewcode-block" id="TargetRegistry"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.TargetRegistry">[docs]</a><span class="k">class</span> <span class="nc">TargetRegistry</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    responsible for registration of target types for iteration</span>
<span class="sd">    and attribute walking</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">register_default_types</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_tree</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># see _register_fuzzy_type for details</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_op_auto_map</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># op name to function that returns handler function</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_register_builtin_ops</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">register_default_types</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_default_types</span><span class="p">()</span>
        <span class="k">return</span>

<div class="viewcode-block" id="TargetRegistry.get_handler"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.TargetRegistry.get_handler">[docs]</a>    <span class="k">def</span> <span class="nf">get_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">raise_exc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;for an operation and object **instance**, obj, return the</span>
<span class="sd">        closest-matching handler function, raising UnregisteredTarget</span>
<span class="sd">        if no handler can be found for *obj* (or False if</span>
<span class="sd">        raise_exc=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">obj_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">type_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type_map</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">type_map</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">type_map</span><span class="p">[</span><span class="n">obj_type</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">type_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_tree</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="p">{})</span>
                <span class="n">closest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_closest_type</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">type_tree</span><span class="o">=</span><span class="n">type_tree</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">closest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">type_map</span><span class="p">[</span><span class="n">closest</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">raise_exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnregisteredTarget</span><span class="p">(</span>
                <span class="n">op</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">type_map</span><span class="o">=</span><span class="n">type_map</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">get_type_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_map</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_closest_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">type_tree</span><span class="p">):</span>
        <span class="n">default</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">cur_type</span><span class="p">,</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="n">type_tree</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cur_type</span><span class="p">):</span>
                <span class="n">sub_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_closest_type</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">type_tree</span><span class="o">=</span><span class="n">sub_tree</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">cur_type</span> <span class="k">if</span> <span class="n">sub_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sub_type</span>
                <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">_register_default_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">get</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">get</span><span class="o">=</span><span class="n">_get_sequence_item</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">get</span><span class="o">=</span><span class="n">_get_sequence_item</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">_AbstractIterable</span><span class="p">,</span> <span class="n">iterate</span><span class="o">=</span><span class="nb">iter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_register_fuzzy_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">new_type</span><span class="p">,</span> <span class="n">_type_tree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a &quot;type tree&quot;, an OrderedDict mapping registered types to</span>
<span class="sd">        their subtypes</span>

<span class="sd">        The type tree&#39;s invariant is that a key in the mapping is a</span>
<span class="sd">        valid parent type of all its children.</span>

<span class="sd">        Order is preserved such that non-overlapping parts of the</span>
<span class="sd">        subtree take precedence by which was most recently added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_type_tree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_type_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_tree</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">_type_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_tree</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">registered</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">cur_type</span><span class="p">,</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">_type_tree</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">cur_type</span><span class="p">,</span> <span class="n">new_type</span><span class="p">):</span>
                <span class="n">sub_tree</span> <span class="o">=</span> <span class="n">_type_tree</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                    <span class="n">cur_type</span>
                <span class="p">)</span>  <span class="c1"># mutation for recursion brevity</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_type_tree</span><span class="p">[</span><span class="n">new_type</span><span class="p">][</span><span class="n">cur_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_tree</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">_type_tree</span><span class="p">[</span><span class="n">new_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">({</span><span class="n">cur_type</span><span class="p">:</span> <span class="n">sub_tree</span><span class="p">})</span>
                <span class="n">registered</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="n">cur_type</span><span class="p">):</span>
                <span class="n">_type_tree</span><span class="p">[</span><span class="n">cur_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_register_fuzzy_type</span><span class="p">(</span>
                    <span class="n">op</span><span class="p">,</span> <span class="n">new_type</span><span class="p">,</span> <span class="n">_type_tree</span><span class="o">=</span><span class="n">sub_tree</span>
                <span class="p">)</span>
                <span class="n">registered</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">registered</span><span class="p">:</span>
            <span class="n">_type_tree</span><span class="p">[</span><span class="n">new_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">_type_tree</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_type</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;register expected a type, not an instance: </span><span class="si">%r</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">target_type</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="n">exact</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;exact&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">new_op_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_op_auto_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_op_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">):</span>
            <span class="n">cur_type_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_map</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">new_op_map</span><span class="p">:</span>
                <span class="n">handler</span> <span class="o">=</span> <span class="n">new_op_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">target_type</span> <span class="ow">in</span> <span class="n">cur_type_map</span><span class="p">:</span>
                <span class="n">handler</span> <span class="o">=</span> <span class="n">cur_type_map</span><span class="p">[</span><span class="n">target_type</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_auto_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">](</span><span class="n">target_type</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;error while determining support for operation&#39;</span>
                        <span class="s1">&#39; &quot;</span><span class="si">%s</span><span class="s1">&quot; on target type: </span><span class="si">%s</span><span class="s1"> (got </span><span class="si">%r</span><span class="s1">)&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">target_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;expected handler for op &quot;</span><span class="si">%s</span><span class="s1">&quot; to be&#39;</span>
                    <span class="s1">&#39; callable or False, not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">new_op_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">handler</span>

        <span class="k">for</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">handler</span> <span class="ow">in</span> <span class="n">new_op_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">target_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">handler</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">exact</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">new_op_map</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_register_fuzzy_type</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">target_type</span><span class="p">)</span>

        <span class="k">return</span>

<div class="viewcode-block" id="TargetRegistry.register_op"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.TargetRegistry.register_op">[docs]</a>    <span class="k">def</span> <span class="nf">register_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">auto_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;add operations beyond the builtins (&#39;get&#39; and &#39;iterate&#39; at the time</span>
<span class="sd">        of writing).</span>

<span class="sd">        auto_func is a function that when passed a type, returns a</span>
<span class="sd">        handler associated with op_name if it&#39;s supported, or False if</span>
<span class="sd">        it&#39;s not.</span>

<span class="sd">        See glom.core.register_op() for the global version used by</span>
<span class="sd">        extensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;expected op_name to be a text name, not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">op_name</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">auto_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">auto_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">auto_func</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;expected auto_func to be callable, not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">auto_func</span><span class="p">,)</span>
            <span class="p">)</span>

        <span class="c1"># determine support for any previously known types</span>
        <span class="n">known_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_map</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span> <span class="p">[])</span>
        <span class="p">)</span>
        <span class="n">type_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
        <span class="n">type_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_tree</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">known_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">type_map</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">handler</span> <span class="o">=</span> <span class="n">auto_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;error while determining support for operation&#39;</span>
                    <span class="s1">&#39; &quot;</span><span class="si">%s</span><span class="s1">&quot; on target type: </span><span class="si">%s</span><span class="s1"> (got </span><span class="si">%r</span><span class="s1">)&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;expected handler for op &quot;</span><span class="si">%s</span><span class="s1">&quot; to be&#39;</span>
                    <span class="s1">&#39; callable or False, not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">type_map</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">handler</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">exact</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">known_types</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_register_fuzzy_type</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">_type_tree</span><span class="o">=</span><span class="n">type_tree</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_op_type_tree</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_op_auto_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">auto_func</span></div>

    <span class="k">def</span> <span class="nf">_register_builtin_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_get_iterable_handler</span><span class="p">(</span><span class="n">type_obj</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="nb">iter</span>
                <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">type_obj</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="k">else</span> <span class="kc">False</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">register_op</span><span class="p">(</span><span class="s1">&#39;iterate&#39;</span><span class="p">,</span> <span class="n">_get_iterable_handler</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_op</span><span class="p">(</span><span class="s1">&#39;get&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">)</span></div>


<span class="n">_DEFAULT_SCOPE</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">({})</span>


<div class="viewcode-block" id="glom"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.glom">[docs]</a><span class="k">def</span> <span class="nf">glom</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Access or construct a value from a given *target* based on the</span>
<span class="sd">    specification declared by *spec*.</span>

<span class="sd">    Accessing nested data, aka deep-get:</span>

<span class="sd">    &gt;&gt;&gt; target = {&#39;a&#39;: {&#39;b&#39;: &#39;c&#39;}}</span>
<span class="sd">    &gt;&gt;&gt; glom(target, &#39;a.b&#39;)</span>
<span class="sd">    &#39;c&#39;</span>

<span class="sd">    Here the *spec* was just a string denoting a path,</span>
<span class="sd">    ``&#39;a.b.``. As simple as it should be. The next example shows</span>
<span class="sd">    how to use nested data to access many fields at once, and make</span>
<span class="sd">    a new nested structure.</span>

<span class="sd">    Constructing, or restructuring more-complicated nested data:</span>

<span class="sd">    &gt;&gt;&gt; target = {&#39;a&#39;: {&#39;b&#39;: &#39;c&#39;, &#39;d&#39;: &#39;e&#39;}, &#39;f&#39;: &#39;g&#39;, &#39;h&#39;: [0, 1, 2]}</span>
<span class="sd">    &gt;&gt;&gt; spec = {&#39;a&#39;: &#39;a.b&#39;, &#39;d&#39;: &#39;a.d&#39;, &#39;h&#39;: (&#39;h&#39;, [lambda x: x * 2])}</span>
<span class="sd">    &gt;&gt;&gt; output = glom(target, spec)</span>
<span class="sd">    &gt;&gt;&gt; pprint(output)</span>
<span class="sd">    {&#39;a&#39;: &#39;c&#39;, &#39;d&#39;: &#39;e&#39;, &#39;h&#39;: [0, 2, 4]}</span>

<span class="sd">    ``glom`` also takes a keyword-argument, *default*. When set,</span>
<span class="sd">    if a ``glom`` operation fails with a :exc:`GlomError`, the</span>
<span class="sd">    *default* will be returned, very much like</span>
<span class="sd">    :meth:`dict.get()`:</span>

<span class="sd">    &gt;&gt;&gt; glom(target, &#39;a.xx&#39;, default=&#39;nada&#39;)</span>
<span class="sd">    &#39;nada&#39;</span>

<span class="sd">    The *skip_exc* keyword argument controls which errors should</span>
<span class="sd">    be ignored.</span>

<span class="sd">    &gt;&gt;&gt; glom({}, lambda x: 100.0 / len(x), default=0.0, skip_exc=ZeroDivisionError)</span>
<span class="sd">    0.0</span>

<span class="sd">    Args:</span>
<span class="sd">       target (object): the object on which the glom will operate.</span>
<span class="sd">       spec (object): Specification of the output object in the form</span>
<span class="sd">         of a dict, list, tuple, string, other glom construct, or</span>
<span class="sd">         any composition of these.</span>
<span class="sd">       default (object): An optional default to return in the case</span>
<span class="sd">         an exception, specified by *skip_exc*, is raised.</span>
<span class="sd">       skip_exc (Exception): An optional exception or tuple of</span>
<span class="sd">         exceptions to ignore and return *default* (None if</span>
<span class="sd">         omitted). If *skip_exc* and *default* are both not set,</span>
<span class="sd">         glom raises errors through.</span>
<span class="sd">       scope (dict): Additional data that can be accessed</span>
<span class="sd">         via S inside the glom-spec.</span>

<span class="sd">    It&#39;s a small API with big functionality, and glom&#39;s power is</span>
<span class="sd">    only surpassed by its intuitiveness. Give it a whirl!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: check spec up front</span>
    <span class="n">default</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="s1">&#39;skip_exc&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">_MISSING</span><span class="p">)</span>
    <span class="n">skip_exc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;skip_exc&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="n">_MISSING</span> <span class="k">else</span> <span class="n">GlomError</span><span class="p">)</span>
    <span class="n">scope</span> <span class="o">=</span> <span class="n">_DEFAULT_SCOPE</span><span class="o">.</span><span class="n">new_child</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="n">Path</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="p">[]),</span>
            <span class="n">Inspect</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;inspector&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">MODE</span><span class="p">:</span> <span class="n">_glom_auto</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="n">scope</span><span class="p">[</span><span class="n">UP</span><span class="p">]</span> <span class="o">=</span> <span class="n">scope</span>
    <span class="n">scope</span><span class="p">[</span><span class="n">ROOT</span><span class="p">]</span> <span class="o">=</span> <span class="n">scope</span>
    <span class="n">scope</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span>
    <span class="n">scope</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;scope&#39;</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unexpected keyword args: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">_glom</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">skip_exc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="n">_MISSING</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">default</span>
    <span class="k">return</span> <span class="n">ret</span></div>


<span class="k">def</span> <span class="nf">_glom</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">scope</span>
    <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">new_child</span><span class="p">()</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">LAST_CHILD_SCOPE</span><span class="p">]</span> <span class="o">=</span> <span class="n">scope</span>
    <span class="n">scope</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span>
    <span class="n">scope</span><span class="p">[</span><span class="n">Spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span>
    <span class="n">scope</span><span class="p">[</span><span class="n">UP</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">TType</span><span class="p">):</span>  <span class="c1"># must go first, due to callability</span>
        <span class="k">return</span> <span class="n">_t_eval</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="s1">&#39;glomit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">spec</span><span class="o">.</span><span class="n">glomit</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">scope</span><span class="p">[</span><span class="n">MODE</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_glom_auto</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_handle_dict</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_handle_list</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_handle_tuple</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Path</span><span class="o">.</span><span class="n">from_text</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span><span class="o">.</span><span class="n">glomit</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spec</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
        <span class="s1">&#39;expected spec to be dict, list, tuple, callable, string,&#39;</span>
        <span class="s1">&#39; or other Spec-like type, not: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spec</span><span class="p">,)</span>
    <span class="p">)</span>


<span class="n">_DEFAULT_SCOPE</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="p">{</span><span class="n">glom</span><span class="p">:</span> <span class="n">_glom</span><span class="p">,</span> <span class="n">TargetRegistry</span><span class="p">:</span> <span class="n">TargetRegistry</span><span class="p">(</span><span class="n">register_default_types</span><span class="o">=</span><span class="kc">True</span><span class="p">),}</span>
<span class="p">)</span>


<div class="viewcode-block" id="register"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.register">[docs]</a><span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="n">target_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Register *target_type* so :meth:`~Glommer.glom()` will</span>
<span class="sd">    know how to handle instances of that type as targets.</span>

<span class="sd">    Args:</span>
<span class="sd">       target_type (type): A type expected to appear in a glom()</span>
<span class="sd">          call target</span>
<span class="sd">       get (callable): A function which takes a target object and</span>
<span class="sd">          a name, acting as a default accessor. Defaults to</span>
<span class="sd">          :func:`getattr`.</span>
<span class="sd">       iterate (callable): A function which takes a target object</span>
<span class="sd">          and returns an iterator. Defaults to :func:`iter` if</span>
<span class="sd">          *target_type* appears to be iterable.</span>
<span class="sd">       exact (bool): Whether or not to match instances of subtypes</span>
<span class="sd">          of *target_type*.</span>

<span class="sd">    .. note::</span>

<span class="sd">       The module-level :func:`register()` function affects the</span>
<span class="sd">       module-level :func:`glom()` function&#39;s behavior. If this</span>
<span class="sd">       global effect is undesirable for your application, or</span>
<span class="sd">       you&#39;re implementing a library, consider instantiating a</span>
<span class="sd">       :class:`Glommer` instance, and using the</span>
<span class="sd">       :meth:`~Glommer.register()` and :meth:`Glommer.glom()`</span>
<span class="sd">       methods instead.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_DEFAULT_SCOPE</span><span class="p">[</span><span class="n">TargetRegistry</span><span class="p">]</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">target_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="register_op"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.register_op">[docs]</a><span class="k">def</span> <span class="nf">register_op</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;For extension authors needing to add operations beyond the builtin</span>
<span class="sd">    &#39;get&#39; and &#39;iterate&#39; to the default scope. See TargetRegistry for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_DEFAULT_SCOPE</span><span class="p">[</span><span class="n">TargetRegistry</span><span class="p">]</span><span class="o">.</span><span class="n">register_op</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="Glommer"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Glommer">[docs]</a><span class="k">class</span> <span class="nc">Glommer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;All the wholesome goodness that it takes to make glom work. This</span>
<span class="sd">    type mostly serves to encapsulate the type registration context so</span>
<span class="sd">    that advanced uses of glom don&#39;t need to worry about stepping on</span>
<span class="sd">    each other&#39;s toes.</span>

<span class="sd">    Glommer objects are lightweight and, once instantiated, provide</span>
<span class="sd">    the :func:`glom()` method we know and love:</span>

<span class="sd">    &gt;&gt;&gt; glommer = Glommer()</span>
<span class="sd">    &gt;&gt;&gt; glommer.glom({}, &#39;a.b.c&#39;, default=&#39;d&#39;)</span>
<span class="sd">    &#39;d&#39;</span>
<span class="sd">    &gt;&gt;&gt; Glommer().glom({&#39;vals&#39;: list(range(3))}, (&#39;vals&#39;, len))</span>
<span class="sd">    3</span>

<span class="sd">    Instances also provide :meth:`~Glommer.register()` method for</span>
<span class="sd">    localized control over type handling.</span>

<span class="sd">    Args:</span>
<span class="sd">       register_default_types (bool): Whether or not to enable the</span>
<span class="sd">          handling behaviors of the default :func:`glom()`. These</span>
<span class="sd">          default actions include dict access, list and iterable</span>
<span class="sd">          iteration, and generic object attribute access. Defaults to</span>
<span class="sd">          True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">register_default_types</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;register_default_types&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;scope&#39;</span><span class="p">,</span> <span class="n">_DEFAULT_SCOPE</span><span class="p">)</span>

        <span class="c1"># this &quot;freezes&quot; the scope in at the time of construction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">scope</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">[</span><span class="n">TargetRegistry</span><span class="p">]</span> <span class="o">=</span> <span class="n">TargetRegistry</span><span class="p">(</span>
            <span class="n">register_default_types</span><span class="o">=</span><span class="n">register_default_types</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Glommer.register"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Glommer.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register *target_type* so :meth:`~Glommer.glom()` will</span>
<span class="sd">        know how to handle instances of that type as targets.</span>

<span class="sd">        Args:</span>
<span class="sd">           target_type (type): A type expected to appear in a glom()</span>
<span class="sd">              call target</span>
<span class="sd">           get (callable): A function which takes a target object and</span>
<span class="sd">              a name, acting as a default accessor. Defaults to</span>
<span class="sd">              :func:`getattr`.</span>
<span class="sd">           iterate (callable): A function which takes a target object</span>
<span class="sd">              and returns an iterator. Defaults to :func:`iter` if</span>
<span class="sd">              *target_type* appears to be iterable.</span>
<span class="sd">           exact (bool): Whether or not to match instances of subtypes</span>
<span class="sd">              of *target_type*.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The module-level :func:`register()` function affects the</span>
<span class="sd">           module-level :func:`glom()` function&#39;s behavior. If this</span>
<span class="sd">           global effect is undesirable for your application, or</span>
<span class="sd">           you&#39;re implementing a library, consider instantiating a</span>
<span class="sd">           :class:`Glommer` instance, and using the</span>
<span class="sd">           :meth:`~Glommer.register()` and :meth:`Glommer.glom()`</span>
<span class="sd">           methods instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exact</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;exact&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">[</span><span class="n">TargetRegistry</span><span class="p">]</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">target_type</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exact</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">glom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">glom</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Fill"><a class="viewcode-back" href="../../../test.html#py2store.utils.glom.Fill">[docs]</a><span class="k">class</span> <span class="nc">Fill</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A specifier type which switches to glom into &quot;fill-mode&quot;. For the</span>
<span class="sd">    spec contained within the Fill, glom will only interpret explicit</span>
<span class="sd">    specifier types (including T objects). Whereas the default mode</span>
<span class="sd">    has special interpretations for each of these builtins, fill-mode</span>
<span class="sd">    takes a lighter touch, making Fill great for &quot;filling out&quot; Python</span>
<span class="sd">    literals, like tuples, dicts, sets, and lists.</span>

<span class="sd">    &gt;&gt;&gt; target = {&#39;data&#39;: [0, 2, 4]}</span>
<span class="sd">    &gt;&gt;&gt; spec = Fill((T[&#39;data&#39;][2], T[&#39;data&#39;][0]))</span>
<span class="sd">    &gt;&gt;&gt; glom(target, spec)</span>
<span class="sd">    (4, 0)</span>

<span class="sd">    As you can see, glom&#39;s usual built-in tuple item chaining behavior</span>
<span class="sd">    has switched into a simple tuple constructor.</span>

<span class="sd">    (Sidenote for Lisp fans: Fill is like glom&#39;s quasi-quoting.)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="k">def</span> <span class="nf">glomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="n">scope</span><span class="p">[</span><span class="n">MODE</span><span class="p">]</span> <span class="o">=</span> <span class="n">_fill</span>
        <span class="k">return</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">glom</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">rpr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="n">rpr</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_fill</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
    <span class="c1"># TODO: register an operator or two for the following to allow</span>
    <span class="c1"># extension. This operator can probably be shared with the</span>
    <span class="c1"># upcoming traversal/remap feature.</span>
    <span class="n">recurse</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">scope</span><span class="p">[</span><span class="n">glom</span><span class="p">](</span><span class="n">target</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">recurse</span><span class="p">(</span><span class="n">key</span><span class="p">):</span> <span class="n">recurse</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">recurse</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">spec</span><span class="p">)(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spec</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spec</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">py2store</a></h1>








<h3>Navigation</h3>
<p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store.html">py2store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/access.html">py2store.access</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/appendable.html">py2store.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/base.html">py2store.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/caching.html">py2store.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/core.html">py2store.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/dig.html">py2store.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/errors.html">py2store.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/examples.html">py2store.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/examples/dropbox_w_urllib.html">py2store.examples.dropbox_w_urllib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/examples/kv_walking.html">py2store.examples.kv_walking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/examples/last_key_inserted.html">py2store.examples.last_key_inserted</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/examples/python_code_stats.html">py2store.examples.python_code_stats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/examples/write_caches.html">py2store.examples.write_caches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/ext.html">py2store.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/ext/dataframes.html">py2store.ext.dataframes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/ext/docx.html">py2store.ext.docx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/ext/github.html">py2store.ext.github</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/ext/gitlab.html">py2store.ext.gitlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/ext/hdf.html">py2store.ext.hdf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/ext/matlab.html">py2store.ext.matlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/ext/wordnet.html">py2store.ext.wordnet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/filesys.html">py2store.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/key_mappers.html">py2store.key_mappers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/key_mappers/naming.html">py2store.key_mappers.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/key_mappers/paths.html">py2store.key_mappers.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/key_mappers/str_utils.html">py2store.key_mappers.str_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/key_mappers/tuples.html">py2store.key_mappers.tuples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/misc.html">py2store.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/mixins.html">py2store.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/my.html">py2store.my</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/my/grabbers.html">py2store.my.grabbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/naming.html">py2store.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/parse_format.html">py2store.parse_format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/paths.html">py2store.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/persisters.html">py2store.persisters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/persisters/dropbox_w_dropbox.html">py2store.persisters.dropbox_w_dropbox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/persisters/googledrive_w_pydrive.html">py2store.persisters.googledrive_w_pydrive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/persisters/local_files.html">py2store.persisters.local_files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/persisters/new_s3.html">py2store.persisters.new_s3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/persisters/redis_w_redis.html">py2store.persisters.redis_w_redis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/persisters/s3_w_boto3.html">py2store.persisters.s3_w_boto3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/persisters/sql_w_sqlalchemy.html">py2store.persisters.sql_w_sqlalchemy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/persisters/w_aiofile.html">py2store.persisters.w_aiofile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/serializers.html">py2store.serializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/serializers/pickled.html">py2store.serializers.pickled</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/signatures.html">py2store.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/slib.html">py2store.slib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/slib/s_configparser.html">py2store.slib.s_configparser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/slib/s_zipfile.html">py2store.slib.s_zipfile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/sources.html">py2store.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/stores.html">py2store.stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/stores/dropbox_store.html">py2store.stores.dropbox_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/stores/local_store.html">py2store.stores.local_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/stores/s3_store.html">py2store.stores.s3_store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/stores/sql_w_sqlalchemy.html">py2store.stores.sql_w_sqlalchemy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/test.html">py2store.test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/test/local_files_test.html">py2store.test.local_files_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/test/quick_test.html">py2store.test.quick_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/test/scrap.html">py2store.test.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/test/util.html">py2store.test.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/trans.html">py2store.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/util.html">py2store.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils.html">py2store.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/affine_conversion.html">py2store.utils.affine_conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/appendable.html">py2store.utils.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/attr_dict.html">py2store.utils.attr_dict</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/cache_descriptors.html">py2store.utils.cache_descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/cumul_aggreg_write.html">py2store.utils.cumul_aggreg_write</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/explicit.html">py2store.utils.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/glom.html">py2store.utils.glom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/mappify.html">py2store.utils.mappify</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/mg_selectors.html">py2store.utils.mg_selectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/mongoquery.html">py2store.utils.mongoquery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/signatures.html">py2store.utils.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/sliceable.html">py2store.utils.sliceable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/timeseries_caching.html">py2store.utils.timeseries_caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/py2store/utils/uri_utils.html">py2store.utils.uri_utils</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  <li><a href="../../py2store.html">py2store</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;NO COPYRIGHT.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>